import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// ../../node_modules/tiny-emitter/index.js
var require_tiny_emitter = __commonJS({
  "../../node_modules/tiny-emitter/index.js"(exports, module) {
    function E() {
    }
    E.prototype = {
      on: function(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name, callback, ctx) {
        var self = this;
        function listener() {
          self.off(name, listener);
          callback.apply(ctx, arguments);
        }
        ;
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? e[name] = liveEvents : delete e[name];
        return this;
      }
    };
    module.exports = E;
    module.exports.TinyEmitter = E;
  }
});

// ../../node_modules/@handsontable/formulajs/lib/utils/error.js
var require_error = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/utils/error.js"(exports) {
    exports.nil = new Error("#NULL!");
    exports.div0 = new Error("#DIV/0!");
    exports.value = new Error("#VALUE!");
    exports.ref = new Error("#REF!");
    exports.name = new Error("#NAME?");
    exports.num = new Error("#NUM!");
    exports.na = new Error("#N/A");
    exports.error = new Error("#ERROR!");
    exports.data = new Error("#GETTING_DATA");
  }
});

// ../../node_modules/@handsontable/formulajs/lib/utils/common.js
var require_common = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/utils/common.js"(exports) {
    var error2 = require_error();
    exports.flattenShallow = function(array) {
      if (!array || !array.reduce) {
        return array;
      }
      return array.reduce(function(a, b) {
        var aIsArray = Array.isArray(a);
        var bIsArray = Array.isArray(b);
        if (aIsArray && bIsArray) {
          return a.concat(b);
        }
        if (aIsArray) {
          a.push(b);
          return a;
        }
        if (bIsArray) {
          return [a].concat(b);
        }
        return [a, b];
      });
    };
    exports.isFlat = function(array) {
      if (!array) {
        return false;
      }
      for (var i = 0; i < array.length; ++i) {
        if (Array.isArray(array[i])) {
          return false;
        }
      }
      return true;
    };
    exports.flatten = function() {
      var result = exports.argsToArray.apply(null, arguments);
      while (!exports.isFlat(result)) {
        result = exports.flattenShallow(result);
      }
      return result;
    };
    exports.argsToArray = function(args) {
      var result = [];
      exports.arrayEach(args, function(value) {
        result.push(value);
      });
      return result;
    };
    exports.numbers = function() {
      var possibleNumbers = this.flatten.apply(null, arguments);
      return possibleNumbers.filter(function(el) {
        return typeof el === "number";
      });
    };
    exports.cleanFloat = function(number) {
      var power = 1e14;
      return Math.round(number * power) / power;
    };
    exports.parseBool = function(bool) {
      if (typeof bool === "boolean") {
        return bool;
      }
      if (bool instanceof Error) {
        return bool;
      }
      if (typeof bool === "number") {
        return bool !== 0;
      }
      if (typeof bool === "string") {
        var up = bool.toUpperCase();
        if (up === "TRUE") {
          return true;
        }
        if (up === "FALSE") {
          return false;
        }
      }
      if (bool instanceof Date && !isNaN(bool)) {
        return true;
      }
      return error2.value;
    };
    exports.parseNumber = function(string) {
      if (string === void 0 || string === "") {
        return error2.value;
      }
      if (!isNaN(string)) {
        return parseFloat(string);
      }
      return error2.value;
    };
    exports.parseNumberArray = function(arr) {
      var len;
      if (!arr || (len = arr.length) === 0) {
        return error2.value;
      }
      var parsed;
      while (len--) {
        parsed = exports.parseNumber(arr[len]);
        if (parsed === error2.value) {
          return parsed;
        }
        arr[len] = parsed;
      }
      return arr;
    };
    exports.parseMatrix = function(matrix) {
      var n;
      if (!matrix || (n = matrix.length) === 0) {
        return error2.value;
      }
      var pnarr;
      for (var i = 0; i < matrix.length; i++) {
        pnarr = exports.parseNumberArray(matrix[i]);
        matrix[i] = pnarr;
        if (pnarr instanceof Error) {
          return pnarr;
        }
      }
      return matrix;
    };
    var d1900 = new Date(Date.UTC(1900, 0, 1));
    exports.parseDate = function(date) {
      if (!isNaN(date)) {
        if (date instanceof Date) {
          return new Date(date);
        }
        var d = parseInt(date, 10);
        if (d < 0) {
          return error2.num;
        }
        if (d <= 60) {
          return new Date(d1900.getTime() + (d - 1) * 864e5);
        }
        return new Date(d1900.getTime() + (d - 2) * 864e5);
      }
      if (typeof date === "string") {
        date = new Date(date);
        if (!isNaN(date)) {
          return date;
        }
      }
      return error2.value;
    };
    exports.parseDateArray = function(arr) {
      var len = arr.length;
      var parsed;
      while (len--) {
        parsed = this.parseDate(arr[len]);
        if (parsed === error2.value) {
          return parsed;
        }
        arr[len] = parsed;
      }
      return arr;
    };
    exports.anyIsError = function() {
      var n = arguments.length;
      while (n--) {
        if (arguments[n] instanceof Error) {
          return true;
        }
      }
      return false;
    };
    exports.arrayValuesToNumbers = function(arr) {
      var n = arr.length;
      var el;
      while (n--) {
        el = arr[n];
        if (typeof el === "number") {
          continue;
        }
        if (el === true) {
          arr[n] = 1;
          continue;
        }
        if (el === false) {
          arr[n] = 0;
          continue;
        }
        if (typeof el === "string") {
          var number = this.parseNumber(el);
          if (number instanceof Error) {
            arr[n] = 0;
          } else {
            arr[n] = number;
          }
        }
      }
      return arr;
    };
    exports.rest = function(array, idx) {
      idx = idx || 1;
      if (!array || typeof array.slice !== "function") {
        return array;
      }
      return array.slice(idx);
    };
    exports.initial = function(array, idx) {
      idx = idx || 1;
      if (!array || typeof array.slice !== "function") {
        return array;
      }
      return array.slice(0, array.length - idx);
    };
    exports.arrayEach = function(array, iteratee) {
      var index = -1, length = array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    };
    exports.transpose = function(matrix) {
      if (!matrix) {
        return error2.value;
      }
      return matrix[0].map(function(col, i) {
        return matrix.map(function(row) {
          return row[i];
        });
      });
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/text.js
var require_text = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/text.js"(exports) {
    var utils = require_common();
    var error2 = require_error();
    exports.ASC = function() {
      throw new Error("ASC is not implemented");
    };
    exports.BAHTTEXT = function() {
      throw new Error("BAHTTEXT is not implemented");
    };
    exports.CHAR = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return String.fromCharCode(number);
    };
    exports.CLEAN = function(text) {
      text = text || "";
      var re = /[\0-\x1F]/g;
      return text.replace(re, "");
    };
    exports.CODE = function(text) {
      text = text || "";
      var result = text.charCodeAt(0);
      if (isNaN(result)) {
        result = error2.na;
      }
      return result;
    };
    exports.CONCATENATE = function() {
      var args = utils.flatten(arguments);
      var trueFound = 0;
      while ((trueFound = args.indexOf(true)) > -1) {
        args[trueFound] = "TRUE";
      }
      var falseFound = 0;
      while ((falseFound = args.indexOf(false)) > -1) {
        args[falseFound] = "FALSE";
      }
      return args.join("");
    };
    exports.DBCS = function() {
      throw new Error("DBCS is not implemented");
    };
    exports.DOLLAR = function() {
      throw new Error("DOLLAR is not implemented");
    };
    exports.EXACT = function(text1, text2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      return text1 === text2;
    };
    exports.FIND = function(find_text, within_text, position) {
      if (arguments.length < 2) {
        return error2.na;
      }
      position = position === void 0 ? 0 : position;
      return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;
    };
    exports.FIXED = function() {
      throw new Error("FIXED is not implemented");
    };
    exports.HTML2TEXT = function(value) {
      var result = "";
      if (value) {
        if (value instanceof Array) {
          value.forEach(function(line) {
            if (result !== "") {
              result += "\n";
            }
            result += line.replace(/<(?:.|\n)*?>/gm, "");
          });
        } else {
          result = value.replace(/<(?:.|\n)*?>/gm, "");
        }
      }
      return result;
    };
    exports.LEFT = function(text, number) {
      number = number === void 0 ? 1 : number;
      number = utils.parseNumber(number);
      if (number instanceof Error || typeof text !== "string") {
        return error2.value;
      }
      return text ? text.substring(0, number) : null;
    };
    exports.LEN = function(text) {
      if (arguments.length === 0) {
        return error2.error;
      }
      if (typeof text === "string") {
        return text ? text.length : 0;
      }
      if (text.length) {
        return text.length;
      }
      return error2.value;
    };
    exports.LOWER = function(text) {
      if (typeof text !== "string") {
        return error2.value;
      }
      return text ? text.toLowerCase() : text;
    };
    exports.MID = function(text, start, number) {
      start = utils.parseNumber(start);
      number = utils.parseNumber(number);
      if (utils.anyIsError(start, number) || typeof text !== "string") {
        return number;
      }
      var begin = start - 1;
      var end = begin + number;
      return text.substring(begin, end);
    };
    exports.NUMBERVALUE = function(text, decimal_separator, group_separator) {
      decimal_separator = typeof decimal_separator === "undefined" ? "." : decimal_separator;
      group_separator = typeof group_separator === "undefined" ? "," : group_separator;
      return Number(text.replace(decimal_separator, ".").replace(group_separator, ""));
    };
    exports.PRONETIC = function() {
      throw new Error("PRONETIC is not implemented");
    };
    exports.PROPER = function(text) {
      if (text === void 0 || text.length === 0) {
        return error2.value;
      }
      if (text === true) {
        text = "TRUE";
      }
      if (text === false) {
        text = "FALSE";
      }
      if (isNaN(text) && typeof text === "number") {
        return error2.value;
      }
      if (typeof text === "number") {
        text = "" + text;
      }
      return text.replace(/\w\S*/g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    };
    exports.REGEXEXTRACT = function(text, regular_expression) {
      if (arguments.length < 2) {
        return error2.na;
      }
      var match = text.match(new RegExp(regular_expression));
      return match ? match[match.length > 1 ? match.length - 1 : 0] : null;
    };
    exports.REGEXMATCH = function(text, regular_expression, full) {
      if (arguments.length < 2) {
        return error2.na;
      }
      var match = text.match(new RegExp(regular_expression));
      return full ? match : !!match;
    };
    exports.REGEXREPLACE = function(text, regular_expression, replacement) {
      if (arguments.length < 3) {
        return error2.na;
      }
      return text.replace(new RegExp(regular_expression), replacement);
    };
    exports.REPLACE = function(text, position, length, new_text) {
      position = utils.parseNumber(position);
      length = utils.parseNumber(length);
      if (utils.anyIsError(position, length) || typeof text !== "string" || typeof new_text !== "string") {
        return error2.value;
      }
      return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
    };
    exports.REPT = function(text, number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return new Array(number + 1).join(text);
    };
    exports.RIGHT = function(text, number) {
      number = number === void 0 ? 1 : number;
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return text ? text.substring(text.length - number) : error2.na;
    };
    exports.SEARCH = function(find_text, within_text, position) {
      var foundAt;
      if (typeof find_text !== "string" || typeof within_text !== "string") {
        return error2.value;
      }
      position = position === void 0 ? 0 : position;
      foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1) + 1;
      return foundAt === 0 ? error2.value : foundAt;
    };
    exports.SPLIT = function(text, separator) {
      return text.split(separator);
    };
    exports.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
      if (arguments.length < 2) {
        return error2.na;
      }
      if (!text || !old_text || !new_text) {
        return text;
      } else if (occurrence === void 0) {
        return text.replace(new RegExp(old_text, "g"), new_text);
      } else {
        var index = 0;
        var i = 0;
        while (text.indexOf(old_text, index) > 0) {
          index = text.indexOf(old_text, index + 1);
          i++;
          if (i === occurrence) {
            return text.substring(0, index) + new_text + text.substring(index + old_text.length);
          }
        }
      }
    };
    exports.T = function(value) {
      return typeof value === "string" ? value : "";
    };
    exports.TEXT = function() {
      throw new Error("TEXT is not implemented");
    };
    exports.TRIM = function(text) {
      if (typeof text !== "string") {
        return error2.value;
      }
      return text.replace(/ +/g, " ").trim();
    };
    exports.UNICHAR = exports.CHAR;
    exports.UNICODE = exports.CODE;
    exports.UPPER = function(text) {
      if (typeof text !== "string") {
        return error2.value;
      }
      return text.toUpperCase();
    };
    exports.VALUE = function() {
      throw new Error("VALUE is not implemented");
    };
  }
});

// ../../node_modules/jstat/dist/jstat.js
var require_jstat = __commonJS({
  "../../node_modules/jstat/dist/jstat.js"(exports, module) {
    (function(window, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        window.jStat = factory();
      }
    })(exports, function() {
      var jStat = function(Math2, undefined2) {
        var concat = Array.prototype.concat;
        var slice = Array.prototype.slice;
        var toString = Object.prototype.toString;
        function calcRdx(n, m) {
          var val = n > m ? n : m;
          return Math2.pow(
            10,
            17 - ~~(Math2.log(val > 0 ? val : -val) * Math2.LOG10E)
          );
        }
        var isArray = Array.isArray || function isArray2(arg) {
          return toString.call(arg) === "[object Array]";
        };
        function isFunction(arg) {
          return toString.call(arg) === "[object Function]";
        }
        function isNumber(num) {
          return typeof num === "number" ? num - num === 0 : false;
        }
        function toVector(arr) {
          return concat.apply([], arr);
        }
        function jStat2() {
          return new jStat2._init(arguments);
        }
        jStat2.fn = jStat2.prototype;
        jStat2._init = function _init(args) {
          if (isArray(args[0])) {
            if (isArray(args[0][0])) {
              if (isFunction(args[1]))
                args[0] = jStat2.map(args[0], args[1]);
              for (var i = 0; i < args[0].length; i++)
                this[i] = args[0][i];
              this.length = args[0].length;
            } else {
              this[0] = isFunction(args[1]) ? jStat2.map(args[0], args[1]) : args[0];
              this.length = 1;
            }
          } else if (isNumber(args[0])) {
            this[0] = jStat2.seq.apply(null, args);
            this.length = 1;
          } else if (args[0] instanceof jStat2) {
            return jStat2(args[0].toArray());
          } else {
            this[0] = [];
            this.length = 1;
          }
          return this;
        };
        jStat2._init.prototype = jStat2.prototype;
        jStat2._init.constructor = jStat2;
        jStat2.utils = {
          calcRdx,
          isArray,
          isFunction,
          isNumber,
          toVector
        };
        jStat2._random_fn = Math2.random;
        jStat2.setRandom = function setRandom(fn) {
          if (typeof fn !== "function")
            throw new TypeError("fn is not a function");
          jStat2._random_fn = fn;
        };
        jStat2.extend = function extend(obj) {
          var i, j;
          if (arguments.length === 1) {
            for (j in obj)
              jStat2[j] = obj[j];
            return this;
          }
          for (i = 1; i < arguments.length; i++) {
            for (j in arguments[i])
              obj[j] = arguments[i][j];
          }
          return obj;
        };
        jStat2.rows = function rows(arr) {
          return arr.length || 1;
        };
        jStat2.cols = function cols(arr) {
          return arr[0].length || 1;
        };
        jStat2.dimensions = function dimensions(arr) {
          return {
            rows: jStat2.rows(arr),
            cols: jStat2.cols(arr)
          };
        };
        jStat2.row = function row(arr, index) {
          if (isArray(index)) {
            return index.map(function(i) {
              return jStat2.row(arr, i);
            });
          }
          return arr[index];
        };
        jStat2.rowa = function rowa(arr, i) {
          return jStat2.row(arr, i);
        };
        jStat2.col = function col(arr, index) {
          if (isArray(index)) {
            var submat = jStat2.arange(arr.length).map(function() {
              return new Array(index.length);
            });
            index.forEach(function(ind, i2) {
              jStat2.arange(arr.length).forEach(function(j) {
                submat[j][i2] = arr[j][ind];
              });
            });
            return submat;
          }
          var column = new Array(arr.length);
          for (var i = 0; i < arr.length; i++)
            column[i] = [arr[i][index]];
          return column;
        };
        jStat2.cola = function cola(arr, i) {
          return jStat2.col(arr, i).map(function(a) {
            return a[0];
          });
        };
        jStat2.diag = function diag(arr) {
          var nrow = jStat2.rows(arr);
          var res = new Array(nrow);
          for (var row = 0; row < nrow; row++)
            res[row] = [arr[row][row]];
          return res;
        };
        jStat2.antidiag = function antidiag(arr) {
          var nrow = jStat2.rows(arr) - 1;
          var res = new Array(nrow);
          for (var i = 0; nrow >= 0; nrow--, i++)
            res[i] = [arr[i][nrow]];
          return res;
        };
        jStat2.transpose = function transpose(arr) {
          var obj = [];
          var objArr, rows, cols, j, i;
          if (!isArray(arr[0]))
            arr = [arr];
          rows = arr.length;
          cols = arr[0].length;
          for (i = 0; i < cols; i++) {
            objArr = new Array(rows);
            for (j = 0; j < rows; j++)
              objArr[j] = arr[j][i];
            obj.push(objArr);
          }
          return obj.length === 1 ? obj[0] : obj;
        };
        jStat2.map = function map(arr, func14, toAlter) {
          var row, nrow, ncol, res, col;
          if (!isArray(arr[0]))
            arr = [arr];
          nrow = arr.length;
          ncol = arr[0].length;
          res = toAlter ? arr : new Array(nrow);
          for (row = 0; row < nrow; row++) {
            if (!res[row])
              res[row] = new Array(ncol);
            for (col = 0; col < ncol; col++)
              res[row][col] = func14(arr[row][col], row, col);
          }
          return res.length === 1 ? res[0] : res;
        };
        jStat2.cumreduce = function cumreduce(arr, func14, toAlter) {
          var row, nrow, ncol, res, col;
          if (!isArray(arr[0]))
            arr = [arr];
          nrow = arr.length;
          ncol = arr[0].length;
          res = toAlter ? arr : new Array(nrow);
          for (row = 0; row < nrow; row++) {
            if (!res[row])
              res[row] = new Array(ncol);
            if (ncol > 0)
              res[row][0] = arr[row][0];
            for (col = 1; col < ncol; col++)
              res[row][col] = func14(res[row][col - 1], arr[row][col]);
          }
          return res.length === 1 ? res[0] : res;
        };
        jStat2.alter = function alter(arr, func14) {
          return jStat2.map(arr, func14, true);
        };
        jStat2.create = function create(rows, cols, func14) {
          var res = new Array(rows);
          var i, j;
          if (isFunction(cols)) {
            func14 = cols;
            cols = rows;
          }
          for (i = 0; i < rows; i++) {
            res[i] = new Array(cols);
            for (j = 0; j < cols; j++)
              res[i][j] = func14(i, j);
          }
          return res;
        };
        function retZero() {
          return 0;
        }
        jStat2.zeros = function zeros(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, retZero);
        };
        function retOne() {
          return 1;
        }
        jStat2.ones = function ones(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, retOne);
        };
        jStat2.rand = function rand(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, jStat2._random_fn);
        };
        function retIdent(i, j) {
          return i === j ? 1 : 0;
        }
        jStat2.identity = function identity(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, retIdent);
        };
        jStat2.symmetric = function symmetric(arr) {
          var size = arr.length;
          var row, col;
          if (arr.length !== arr[0].length)
            return false;
          for (row = 0; row < size; row++) {
            for (col = 0; col < size; col++)
              if (arr[col][row] !== arr[row][col])
                return false;
          }
          return true;
        };
        jStat2.clear = function clear(arr) {
          return jStat2.alter(arr, retZero);
        };
        jStat2.seq = function seq(min, max, length, func14) {
          if (!isFunction(func14))
            func14 = false;
          var arr = [];
          var hival = calcRdx(min, max);
          var step = (max * hival - min * hival) / ((length - 1) * hival);
          var current = min;
          var cnt;
          for (cnt = 0; current <= max && cnt < length; cnt++, current = (min * hival + step * hival * cnt) / hival) {
            arr.push(func14 ? func14(current, cnt) : current);
          }
          return arr;
        };
        jStat2.arange = function arange(start, end, step) {
          var rl = [];
          var i;
          step = step || 1;
          if (end === undefined2) {
            end = start;
            start = 0;
          }
          if (start === end || step === 0) {
            return [];
          }
          if (start < end && step < 0) {
            return [];
          }
          if (start > end && step > 0) {
            return [];
          }
          if (step > 0) {
            for (i = start; i < end; i += step) {
              rl.push(i);
            }
          } else {
            for (i = start; i > end; i += step) {
              rl.push(i);
            }
          }
          return rl;
        };
        jStat2.slice = /* @__PURE__ */ function() {
          function _slice(list, start, end, step) {
            var i;
            var rl = [];
            var length = list.length;
            if (start === undefined2 && end === undefined2 && step === undefined2) {
              return jStat2.copy(list);
            }
            start = start || 0;
            end = end || list.length;
            start = start >= 0 ? start : length + start;
            end = end >= 0 ? end : length + end;
            step = step || 1;
            if (start === end || step === 0) {
              return [];
            }
            if (start < end && step < 0) {
              return [];
            }
            if (start > end && step > 0) {
              return [];
            }
            if (step > 0) {
              for (i = start; i < end; i += step) {
                rl.push(list[i]);
              }
            } else {
              for (i = start; i > end; i += step) {
                rl.push(list[i]);
              }
            }
            return rl;
          }
          function slice2(list, rcSlice) {
            var colSlice, rowSlice;
            rcSlice = rcSlice || {};
            if (isNumber(rcSlice.row)) {
              if (isNumber(rcSlice.col))
                return list[rcSlice.row][rcSlice.col];
              var row = jStat2.rowa(list, rcSlice.row);
              colSlice = rcSlice.col || {};
              return _slice(row, colSlice.start, colSlice.end, colSlice.step);
            }
            if (isNumber(rcSlice.col)) {
              var col = jStat2.cola(list, rcSlice.col);
              rowSlice = rcSlice.row || {};
              return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);
            }
            rowSlice = rcSlice.row || {};
            colSlice = rcSlice.col || {};
            var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);
            return rows.map(function(row2) {
              return _slice(row2, colSlice.start, colSlice.end, colSlice.step);
            });
          }
          return slice2;
        }();
        jStat2.sliceAssign = function sliceAssign(A, rcSlice, B) {
          var nl, ml;
          if (isNumber(rcSlice.row)) {
            if (isNumber(rcSlice.col))
              return A[rcSlice.row][rcSlice.col] = B;
            rcSlice.col = rcSlice.col || {};
            rcSlice.col.start = rcSlice.col.start || 0;
            rcSlice.col.end = rcSlice.col.end || A[0].length;
            rcSlice.col.step = rcSlice.col.step || 1;
            nl = jStat2.arange(
              rcSlice.col.start,
              Math2.min(A.length, rcSlice.col.end),
              rcSlice.col.step
            );
            var m = rcSlice.row;
            nl.forEach(function(n2, i) {
              A[m][n2] = B[i];
            });
            return A;
          }
          if (isNumber(rcSlice.col)) {
            rcSlice.row = rcSlice.row || {};
            rcSlice.row.start = rcSlice.row.start || 0;
            rcSlice.row.end = rcSlice.row.end || A.length;
            rcSlice.row.step = rcSlice.row.step || 1;
            ml = jStat2.arange(
              rcSlice.row.start,
              Math2.min(A[0].length, rcSlice.row.end),
              rcSlice.row.step
            );
            var n = rcSlice.col;
            ml.forEach(function(m2, j) {
              A[m2][n] = B[j];
            });
            return A;
          }
          if (B[0].length === undefined2) {
            B = [B];
          }
          rcSlice.row.start = rcSlice.row.start || 0;
          rcSlice.row.end = rcSlice.row.end || A.length;
          rcSlice.row.step = rcSlice.row.step || 1;
          rcSlice.col.start = rcSlice.col.start || 0;
          rcSlice.col.end = rcSlice.col.end || A[0].length;
          rcSlice.col.step = rcSlice.col.step || 1;
          ml = jStat2.arange(
            rcSlice.row.start,
            Math2.min(A.length, rcSlice.row.end),
            rcSlice.row.step
          );
          nl = jStat2.arange(
            rcSlice.col.start,
            Math2.min(A[0].length, rcSlice.col.end),
            rcSlice.col.step
          );
          ml.forEach(function(m2, i) {
            nl.forEach(function(n2, j) {
              A[m2][n2] = B[i][j];
            });
          });
          return A;
        };
        jStat2.diagonal = function diagonal(diagArray) {
          var mat = jStat2.zeros(diagArray.length, diagArray.length);
          diagArray.forEach(function(t, i) {
            mat[i][i] = t;
          });
          return mat;
        };
        jStat2.copy = function copy(A) {
          return A.map(function(row) {
            if (isNumber(row))
              return row;
            return row.map(function(t) {
              return t;
            });
          });
        };
        var jProto = jStat2.prototype;
        jProto.length = 0;
        jProto.push = Array.prototype.push;
        jProto.sort = Array.prototype.sort;
        jProto.splice = Array.prototype.splice;
        jProto.slice = Array.prototype.slice;
        jProto.toArray = function toArray() {
          return this.length > 1 ? slice.call(this) : slice.call(this)[0];
        };
        jProto.map = function map(func14, toAlter) {
          return jStat2(jStat2.map(this, func14, toAlter));
        };
        jProto.cumreduce = function cumreduce(func14, toAlter) {
          return jStat2(jStat2.cumreduce(this, func14, toAlter));
        };
        jProto.alter = function alter(func14) {
          jStat2.alter(this, func14);
          return this;
        };
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jProto[passfunc] = function(func14) {
              var self = this, results;
              if (func14) {
                setTimeout(function() {
                  func14.call(self, jProto[passfunc].call(self));
                });
                return this;
              }
              results = jStat2[passfunc](this);
              return isArray(results) ? jStat2(results) : results;
            };
          })(funcs[i]);
        })("transpose clear symmetric rows cols dimensions diag antidiag".split(" "));
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jProto[passfunc] = function(index, func14) {
              var self = this;
              if (func14) {
                setTimeout(function() {
                  func14.call(self, jProto[passfunc].call(self, index));
                });
                return this;
              }
              return jStat2(jStat2[passfunc](this, index));
            };
          })(funcs[i]);
        })("row col".split(" "));
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jProto[passfunc] = function() {
              return jStat2(jStat2[passfunc].apply(null, arguments));
            };
          })(funcs[i]);
        })("create zeros ones rand identity".split(" "));
        return jStat2;
      }(Math);
      (function(jStat2, Math2) {
        var isFunction = jStat2.utils.isFunction;
        function ascNum(a, b) {
          return a - b;
        }
        function clip(arg, min, max) {
          return Math2.max(min, Math2.min(arg, max));
        }
        jStat2.sum = function sum(arr) {
          var sum2 = 0;
          var i = arr.length;
          while (--i >= 0)
            sum2 += arr[i];
          return sum2;
        };
        jStat2.sumsqrd = function sumsqrd(arr) {
          var sum = 0;
          var i = arr.length;
          while (--i >= 0)
            sum += arr[i] * arr[i];
          return sum;
        };
        jStat2.sumsqerr = function sumsqerr(arr) {
          var mean = jStat2.mean(arr);
          var sum = 0;
          var i = arr.length;
          var tmp;
          while (--i >= 0) {
            tmp = arr[i] - mean;
            sum += tmp * tmp;
          }
          return sum;
        };
        jStat2.sumrow = function sumrow(arr) {
          var sum = 0;
          var i = arr.length;
          while (--i >= 0)
            sum += arr[i];
          return sum;
        };
        jStat2.product = function product(arr) {
          var prod = 1;
          var i = arr.length;
          while (--i >= 0)
            prod *= arr[i];
          return prod;
        };
        jStat2.min = function min(arr) {
          var low = arr[0];
          var i = 0;
          while (++i < arr.length)
            if (arr[i] < low)
              low = arr[i];
          return low;
        };
        jStat2.max = function max(arr) {
          var high = arr[0];
          var i = 0;
          while (++i < arr.length)
            if (arr[i] > high)
              high = arr[i];
          return high;
        };
        jStat2.unique = function unique(arr) {
          var hash = {}, _arr = [];
          for (var i = 0; i < arr.length; i++) {
            if (!hash[arr[i]]) {
              hash[arr[i]] = true;
              _arr.push(arr[i]);
            }
          }
          return _arr;
        };
        jStat2.mean = function mean(arr) {
          return jStat2.sum(arr) / arr.length;
        };
        jStat2.meansqerr = function meansqerr(arr) {
          return jStat2.sumsqerr(arr) / arr.length;
        };
        jStat2.geomean = function geomean(arr) {
          var logs = arr.map(Math2.log);
          var meanOfLogs = jStat2.mean(logs);
          return Math2.exp(meanOfLogs);
        };
        jStat2.median = function median(arr) {
          var arrlen = arr.length;
          var _arr = arr.slice().sort(ascNum);
          return !(arrlen & 1) ? (_arr[arrlen / 2 - 1] + _arr[arrlen / 2]) / 2 : _arr[arrlen / 2 | 0];
        };
        jStat2.cumsum = function cumsum(arr) {
          return jStat2.cumreduce(arr, function(a, b) {
            return a + b;
          });
        };
        jStat2.cumprod = function cumprod(arr) {
          return jStat2.cumreduce(arr, function(a, b) {
            return a * b;
          });
        };
        jStat2.diff = function diff(arr) {
          var diffs = [];
          var arrLen = arr.length;
          var i;
          for (i = 1; i < arrLen; i++)
            diffs.push(arr[i] - arr[i - 1]);
          return diffs;
        };
        jStat2.rank = function(arr) {
          var i;
          var distinctNumbers = [];
          var numberCounts = {};
          for (i = 0; i < arr.length; i++) {
            var number = arr[i];
            if (numberCounts[number]) {
              numberCounts[number]++;
            } else {
              numberCounts[number] = 1;
              distinctNumbers.push(number);
            }
          }
          var sortedDistinctNumbers = distinctNumbers.sort(ascNum);
          var numberRanks = {};
          var currentRank = 1;
          for (i = 0; i < sortedDistinctNumbers.length; i++) {
            var number = sortedDistinctNumbers[i];
            var count = numberCounts[number];
            var first = currentRank;
            var last = currentRank + count - 1;
            var rank = (first + last) / 2;
            numberRanks[number] = rank;
            currentRank += count;
          }
          return arr.map(function(number2) {
            return numberRanks[number2];
          });
        };
        jStat2.mode = function mode(arr) {
          var arrLen = arr.length;
          var _arr = arr.slice().sort(ascNum);
          var count = 1;
          var maxCount = 0;
          var numMaxCount = 0;
          var mode_arr = [];
          var i;
          for (i = 0; i < arrLen; i++) {
            if (_arr[i] === _arr[i + 1]) {
              count++;
            } else {
              if (count > maxCount) {
                mode_arr = [_arr[i]];
                maxCount = count;
                numMaxCount = 0;
              } else if (count === maxCount) {
                mode_arr.push(_arr[i]);
                numMaxCount++;
              }
              count = 1;
            }
          }
          return numMaxCount === 0 ? mode_arr[0] : mode_arr;
        };
        jStat2.range = function range(arr) {
          return jStat2.max(arr) - jStat2.min(arr);
        };
        jStat2.variance = function variance(arr, flag) {
          return jStat2.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
        };
        jStat2.pooledvariance = function pooledvariance(arr) {
          var sumsqerr = arr.reduce(function(a, samples) {
            return a + jStat2.sumsqerr(samples);
          }, 0);
          var count = arr.reduce(function(a, samples) {
            return a + samples.length;
          }, 0);
          return sumsqerr / (count - arr.length);
        };
        jStat2.deviation = function(arr) {
          var mean = jStat2.mean(arr);
          var arrlen = arr.length;
          var dev = new Array(arrlen);
          for (var i = 0; i < arrlen; i++) {
            dev[i] = arr[i] - mean;
          }
          return dev;
        };
        jStat2.stdev = function stdev(arr, flag) {
          return Math2.sqrt(jStat2.variance(arr, flag));
        };
        jStat2.pooledstdev = function pooledstdev(arr) {
          return Math2.sqrt(jStat2.pooledvariance(arr));
        };
        jStat2.meandev = function meandev(arr) {
          var mean = jStat2.mean(arr);
          var a = [];
          for (var i = arr.length - 1; i >= 0; i--) {
            a.push(Math2.abs(arr[i] - mean));
          }
          return jStat2.mean(a);
        };
        jStat2.meddev = function meddev(arr) {
          var median = jStat2.median(arr);
          var a = [];
          for (var i = arr.length - 1; i >= 0; i--) {
            a.push(Math2.abs(arr[i] - median));
          }
          return jStat2.median(a);
        };
        jStat2.coeffvar = function coeffvar(arr) {
          return jStat2.stdev(arr) / jStat2.mean(arr);
        };
        jStat2.quartiles = function quartiles(arr) {
          var arrlen = arr.length;
          var _arr = arr.slice().sort(ascNum);
          return [
            _arr[Math2.round(arrlen / 4) - 1],
            _arr[Math2.round(arrlen / 2) - 1],
            _arr[Math2.round(arrlen * 3 / 4) - 1]
          ];
        };
        jStat2.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
          var sortedArray = arr.slice().sort(ascNum);
          var quantileVals = [quantilesArray.length];
          var n = arr.length;
          var i, p, m, aleph, k, gamma;
          if (typeof alphap === "undefined")
            alphap = 3 / 8;
          if (typeof betap === "undefined")
            betap = 3 / 8;
          for (i = 0; i < quantilesArray.length; i++) {
            p = quantilesArray[i];
            m = alphap + p * (1 - alphap - betap);
            aleph = n * p + m;
            k = Math2.floor(clip(aleph, 1, n - 1));
            gamma = clip(aleph - k, 0, 1);
            quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
          }
          return quantileVals;
        };
        jStat2.percentile = function percentile(arr, k, exclusive) {
          var _arr = arr.slice().sort(ascNum);
          var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);
          var index = parseInt(realIndex);
          var frac = realIndex - index;
          if (index + 1 < _arr.length) {
            return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);
          } else {
            return _arr[index - 1];
          }
        };
        jStat2.percentileOfScore = function percentileOfScore(arr, score, kind) {
          var counter = 0;
          var len = arr.length;
          var strict = false;
          var value, i;
          if (kind === "strict")
            strict = true;
          for (i = 0; i < len; i++) {
            value = arr[i];
            if (strict && value < score || !strict && value <= score) {
              counter++;
            }
          }
          return counter / len;
        };
        jStat2.histogram = function histogram(arr, binCnt) {
          binCnt = binCnt || 4;
          var first = jStat2.min(arr);
          var binWidth = (jStat2.max(arr) - first) / binCnt;
          var len = arr.length;
          var bins = [];
          var i;
          for (i = 0; i < binCnt; i++)
            bins[i] = 0;
          for (i = 0; i < len; i++)
            bins[Math2.min(Math2.floor((arr[i] - first) / binWidth), binCnt - 1)] += 1;
          return bins;
        };
        jStat2.covariance = function covariance(arr1, arr2) {
          var u = jStat2.mean(arr1);
          var v = jStat2.mean(arr2);
          var arr1Len = arr1.length;
          var sq_dev = new Array(arr1Len);
          var i;
          for (i = 0; i < arr1Len; i++)
            sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);
          return jStat2.sum(sq_dev) / (arr1Len - 1);
        };
        jStat2.corrcoeff = function corrcoeff(arr1, arr2) {
          return jStat2.covariance(arr1, arr2) / jStat2.stdev(arr1, 1) / jStat2.stdev(arr2, 1);
        };
        jStat2.spearmancoeff = function(arr1, arr2) {
          arr1 = jStat2.rank(arr1);
          arr2 = jStat2.rank(arr2);
          return jStat2.corrcoeff(arr1, arr2);
        };
        jStat2.stanMoment = function stanMoment(arr, n) {
          var mu = jStat2.mean(arr);
          var sigma = jStat2.stdev(arr);
          var len = arr.length;
          var skewSum = 0;
          for (var i = 0; i < len; i++)
            skewSum += Math2.pow((arr[i] - mu) / sigma, n);
          return skewSum / arr.length;
        };
        jStat2.skewness = function skewness(arr) {
          return jStat2.stanMoment(arr, 3);
        };
        jStat2.kurtosis = function kurtosis(arr) {
          return jStat2.stanMoment(arr, 4) - 3;
        };
        var jProto = jStat2.prototype;
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jProto[passfunc] = function(fullbool, func14) {
              var arr = [];
              var i2 = 0;
              var tmpthis = this;
              if (isFunction(fullbool)) {
                func14 = fullbool;
                fullbool = false;
              }
              if (func14) {
                setTimeout(function() {
                  func14.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                });
                return this;
              }
              if (this.length > 1) {
                tmpthis = fullbool === true ? this : this.transpose();
                for (; i2 < tmpthis.length; i2++)
                  arr[i2] = jStat2[passfunc](tmpthis[i2]);
                return arr;
              }
              return jStat2[passfunc](this[0], fullbool);
            };
          })(funcs[i]);
        })("cumsum cumprod".split(" "));
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jProto[passfunc] = function(fullbool, func14) {
              var arr = [];
              var i2 = 0;
              var tmpthis = this;
              if (isFunction(fullbool)) {
                func14 = fullbool;
                fullbool = false;
              }
              if (func14) {
                setTimeout(function() {
                  func14.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                });
                return this;
              }
              if (this.length > 1) {
                if (passfunc !== "sumrow")
                  tmpthis = fullbool === true ? this : this.transpose();
                for (; i2 < tmpthis.length; i2++)
                  arr[i2] = jStat2[passfunc](tmpthis[i2]);
                return fullbool === true ? jStat2[passfunc](jStat2.utils.toVector(arr)) : arr;
              }
              return jStat2[passfunc](this[0], fullbool);
            };
          })(funcs[i]);
        })("sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr geomean median diff rank mode range variance deviation stdev meandev meddev coeffvar quartiles histogram skewness kurtosis".split(" "));
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jProto[passfunc] = function() {
              var arr = [];
              var i2 = 0;
              var tmpthis = this;
              var args = Array.prototype.slice.call(arguments);
              var callbackFunction;
              if (isFunction(args[args.length - 1])) {
                callbackFunction = args[args.length - 1];
                var argsToPass = args.slice(0, args.length - 1);
                setTimeout(function() {
                  callbackFunction.call(
                    tmpthis,
                    jProto[passfunc].apply(tmpthis, argsToPass)
                  );
                });
                return this;
              } else {
                callbackFunction = void 0;
                var curriedFunction = function curriedFunction2(vector) {
                  return jStat2[passfunc].apply(tmpthis, [vector].concat(args));
                };
              }
              if (this.length > 1) {
                tmpthis = tmpthis.transpose();
                for (; i2 < tmpthis.length; i2++)
                  arr[i2] = curriedFunction(tmpthis[i2]);
                return arr;
              }
              return curriedFunction(this[0]);
            };
          })(funcs[i]);
        })("quantiles percentileOfScore".split(" "));
      })(jStat, Math);
      (function(jStat2, Math2) {
        jStat2.gammaln = function gammaln(x) {
          var j = 0;
          var cof = [
            76.18009172947146,
            -86.50532032941678,
            24.01409824083091,
            -1.231739572450155,
            0.001208650973866179,
            -5395239384953e-18
          ];
          var ser = 1.000000000190015;
          var xx, y, tmp;
          tmp = (y = xx = x) + 5.5;
          tmp -= (xx + 0.5) * Math2.log(tmp);
          for (; j < 6; j++)
            ser += cof[j] / ++y;
          return Math2.log(2.5066282746310007 * ser / xx) - tmp;
        };
        jStat2.loggam = function loggam(x) {
          var x0, x2, xp, gl, gl0;
          var k, n;
          var a = [
            0.08333333333333333,
            -0.002777777777777778,
            7936507936507937e-19,
            -5952380952380952e-19,
            8417508417508418e-19,
            -0.001917526917526918,
            0.00641025641025641,
            -0.02955065359477124,
            0.1796443723688307,
            -1.3924322169059
          ];
          x0 = x;
          n = 0;
          if (x == 1 || x == 2) {
            return 0;
          }
          if (x <= 7) {
            n = Math2.floor(7 - x);
            x0 = x + n;
          }
          x2 = 1 / (x0 * x0);
          xp = 2 * Math2.PI;
          gl0 = a[9];
          for (k = 8; k >= 0; k--) {
            gl0 *= x2;
            gl0 += a[k];
          }
          gl = gl0 / x0 + 0.5 * Math2.log(xp) + (x0 - 0.5) * Math2.log(x0) - x0;
          if (x <= 7) {
            for (k = 1; k <= n; k++) {
              gl -= Math2.log(x0 - 1);
              x0 -= 1;
            }
          }
          return gl;
        };
        jStat2.gammafn = function gammafn(x) {
          var p = [
            -1.716185138865495,
            24.76565080557592,
            -379.80425647094563,
            629.3311553128184,
            866.9662027904133,
            -31451.272968848367,
            -36144.413418691176,
            66456.14382024054
          ];
          var q = [
            -30.8402300119739,
            315.35062697960416,
            -1015.1563674902192,
            -3107.771671572311,
            22538.11842098015,
            4755.846277527881,
            -134659.9598649693,
            -115132.2596755535
          ];
          var fact = false;
          var n = 0;
          var xden = 0;
          var xnum = 0;
          var y = x;
          var i, z, yi, res;
          if (x > 171.6243769536076) {
            return Infinity;
          }
          if (y <= 0) {
            res = y % 1 + 36e-17;
            if (res) {
              fact = (!(y & 1) ? 1 : -1) * Math2.PI / Math2.sin(Math2.PI * res);
              y = 1 - y;
            } else {
              return Infinity;
            }
          }
          yi = y;
          if (y < 1) {
            z = y++;
          } else {
            z = (y -= n = (y | 0) - 1) - 1;
          }
          for (i = 0; i < 8; ++i) {
            xnum = (xnum + p[i]) * z;
            xden = xden * z + q[i];
          }
          res = xnum / xden + 1;
          if (yi < y) {
            res /= yi;
          } else if (yi > y) {
            for (i = 0; i < n; ++i) {
              res *= y;
              y++;
            }
          }
          if (fact) {
            res = fact / res;
          }
          return res;
        };
        jStat2.gammap = function gammap(a, x) {
          return jStat2.lowRegGamma(a, x) * jStat2.gammafn(a);
        };
        jStat2.lowRegGamma = function lowRegGamma(a, x) {
          var aln = jStat2.gammaln(a);
          var ap = a;
          var sum = 1 / a;
          var del = sum;
          var b = x + 1 - a;
          var c = 1 / 1e-30;
          var d = 1 / b;
          var h = d;
          var i = 1;
          var ITMAX = -~(Math2.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17);
          var an;
          if (x < 0 || a <= 0) {
            return NaN;
          } else if (x < a + 1) {
            for (; i <= ITMAX; i++) {
              sum += del *= x / ++ap;
            }
            return sum * Math2.exp(-x + a * Math2.log(x) - aln);
          }
          for (; i <= ITMAX; i++) {
            an = -i * (i - a);
            b += 2;
            d = an * d + b;
            c = b + an / c;
            d = 1 / d;
            h *= d * c;
          }
          return 1 - h * Math2.exp(-x + a * Math2.log(x) - aln);
        };
        jStat2.factorialln = function factorialln(n) {
          return n < 0 ? NaN : jStat2.gammaln(n + 1);
        };
        jStat2.factorial = function factorial(n) {
          return n < 0 ? NaN : jStat2.gammafn(n + 1);
        };
        jStat2.combination = function combination(n, m) {
          return n > 170 || m > 170 ? Math2.exp(jStat2.combinationln(n, m)) : jStat2.factorial(n) / jStat2.factorial(m) / jStat2.factorial(n - m);
        };
        jStat2.combinationln = function combinationln(n, m) {
          return jStat2.factorialln(n) - jStat2.factorialln(m) - jStat2.factorialln(n - m);
        };
        jStat2.permutation = function permutation(n, m) {
          return jStat2.factorial(n) / jStat2.factorial(n - m);
        };
        jStat2.betafn = function betafn(x, y) {
          if (x <= 0 || y <= 0)
            return void 0;
          return x + y > 170 ? Math2.exp(jStat2.betaln(x, y)) : jStat2.gammafn(x) * jStat2.gammafn(y) / jStat2.gammafn(x + y);
        };
        jStat2.betaln = function betaln(x, y) {
          return jStat2.gammaln(x) + jStat2.gammaln(y) - jStat2.gammaln(x + y);
        };
        jStat2.betacf = function betacf(x, a, b) {
          var fpmin = 1e-30;
          var m = 1;
          var qab = a + b;
          var qap = a + 1;
          var qam = a - 1;
          var c = 1;
          var d = 1 - qab * x / qap;
          var m2, aa, del, h;
          if (Math2.abs(d) < fpmin)
            d = fpmin;
          d = 1 / d;
          h = d;
          for (; m <= 100; m++) {
            m2 = 2 * m;
            aa = m * (b - m) * x / ((qam + m2) * (a + m2));
            d = 1 + aa * d;
            if (Math2.abs(d) < fpmin)
              d = fpmin;
            c = 1 + aa / c;
            if (Math2.abs(c) < fpmin)
              c = fpmin;
            d = 1 / d;
            h *= d * c;
            aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
            d = 1 + aa * d;
            if (Math2.abs(d) < fpmin)
              d = fpmin;
            c = 1 + aa / c;
            if (Math2.abs(c) < fpmin)
              c = fpmin;
            d = 1 / d;
            del = d * c;
            h *= del;
            if (Math2.abs(del - 1) < 3e-7)
              break;
          }
          return h;
        };
        jStat2.gammapinv = function gammapinv(p, a) {
          var j = 0;
          var a1 = a - 1;
          var EPS = 1e-8;
          var gln = jStat2.gammaln(a);
          var x, err, t, u, pp, lna1, afac;
          if (p >= 1)
            return Math2.max(100, a + 100 * Math2.sqrt(a));
          if (p <= 0)
            return 0;
          if (a > 1) {
            lna1 = Math2.log(a1);
            afac = Math2.exp(a1 * (lna1 - 1) - gln);
            pp = p < 0.5 ? p : 1 - p;
            t = Math2.sqrt(-2 * Math2.log(pp));
            x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
            if (p < 0.5)
              x = -x;
            x = Math2.max(
              1e-3,
              a * Math2.pow(1 - 1 / (9 * a) - x / (3 * Math2.sqrt(a)), 3)
            );
          } else {
            t = 1 - a * (0.253 + a * 0.12);
            if (p < t)
              x = Math2.pow(p / t, 1 / a);
            else
              x = 1 - Math2.log(1 - (p - t) / (1 - t));
          }
          for (; j < 12; j++) {
            if (x <= 0)
              return 0;
            err = jStat2.lowRegGamma(a, x) - p;
            if (a > 1)
              t = afac * Math2.exp(-(x - a1) + a1 * (Math2.log(x) - lna1));
            else
              t = Math2.exp(-x + a1 * Math2.log(x) - gln);
            u = err / t;
            x -= t = u / (1 - 0.5 * Math2.min(1, u * ((a - 1) / x - 1)));
            if (x <= 0)
              x = 0.5 * (x + t);
            if (Math2.abs(t) < EPS * x)
              break;
          }
          return x;
        };
        jStat2.erf = function erf(x) {
          var cof = [
            -1.3026537197817094,
            0.6419697923564902,
            0.019476473204185836,
            -0.00956151478680863,
            -946595344482036e-18,
            366839497852761e-18,
            42523324806907e-18,
            -20278578112534e-18,
            -1624290004647e-18,
            130365583558e-17,
            15626441722e-18,
            -85238095915e-18,
            6529054439e-18,
            5059343495e-18,
            -991364156e-18,
            -227365122e-18,
            96467911e-18,
            2394038e-18,
            -6886027e-18,
            894487e-18,
            313092e-18,
            -112708e-18,
            381e-18,
            7106e-18,
            -1523e-18,
            -94e-18,
            121e-18,
            -28e-18
          ];
          var j = cof.length - 1;
          var isneg = false;
          var d = 0;
          var dd = 0;
          var t, ty, tmp, res;
          if (x < 0) {
            x = -x;
            isneg = true;
          }
          t = 2 / (2 + x);
          ty = 4 * t - 2;
          for (; j > 0; j--) {
            tmp = d;
            d = ty * d - dd + cof[j];
            dd = tmp;
          }
          res = t * Math2.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
          return isneg ? res - 1 : 1 - res;
        };
        jStat2.erfc = function erfc(x) {
          return 1 - jStat2.erf(x);
        };
        jStat2.erfcinv = function erfcinv(p) {
          var j = 0;
          var x, err, t, pp;
          if (p >= 2)
            return -100;
          if (p <= 0)
            return 100;
          pp = p < 1 ? p : 2 - p;
          t = Math2.sqrt(-2 * Math2.log(pp / 2));
          x = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);
          for (; j < 2; j++) {
            err = jStat2.erfc(x) - pp;
            x += err / (1.1283791670955126 * Math2.exp(-x * x) - x * err);
          }
          return p < 1 ? x : -x;
        };
        jStat2.ibetainv = function ibetainv(p, a, b) {
          var EPS = 1e-8;
          var a1 = a - 1;
          var b1 = b - 1;
          var j = 0;
          var lna, lnb, pp, t, u, err, x, al, h, w, afac;
          if (p <= 0)
            return 0;
          if (p >= 1)
            return 1;
          if (a >= 1 && b >= 1) {
            pp = p < 0.5 ? p : 1 - p;
            t = Math2.sqrt(-2 * Math2.log(pp));
            x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
            if (p < 0.5)
              x = -x;
            al = (x * x - 3) / 6;
            h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
            w = x * Math2.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));
            x = a / (a + b * Math2.exp(2 * w));
          } else {
            lna = Math2.log(a / (a + b));
            lnb = Math2.log(b / (a + b));
            t = Math2.exp(a * lna) / a;
            u = Math2.exp(b * lnb) / b;
            w = t + u;
            if (p < t / w)
              x = Math2.pow(a * w * p, 1 / a);
            else
              x = 1 - Math2.pow(b * w * (1 - p), 1 / b);
          }
          afac = -jStat2.gammaln(a) - jStat2.gammaln(b) + jStat2.gammaln(a + b);
          for (; j < 10; j++) {
            if (x === 0 || x === 1)
              return x;
            err = jStat2.ibeta(x, a, b) - p;
            t = Math2.exp(a1 * Math2.log(x) + b1 * Math2.log(1 - x) + afac);
            u = err / t;
            x -= t = u / (1 - 0.5 * Math2.min(1, u * (a1 / x - b1 / (1 - x))));
            if (x <= 0)
              x = 0.5 * (x + t);
            if (x >= 1)
              x = 0.5 * (x + t + 1);
            if (Math2.abs(t) < EPS * x && j > 0)
              break;
          }
          return x;
        };
        jStat2.ibeta = function ibeta(x, a, b) {
          var bt = x === 0 || x === 1 ? 0 : Math2.exp(jStat2.gammaln(a + b) - jStat2.gammaln(a) - jStat2.gammaln(b) + a * Math2.log(x) + b * Math2.log(1 - x));
          if (x < 0 || x > 1)
            return false;
          if (x < (a + 1) / (a + b + 2))
            return bt * jStat2.betacf(x, a, b) / a;
          return 1 - bt * jStat2.betacf(1 - x, b, a) / b;
        };
        jStat2.randn = function randn(n, m) {
          var u, v, x, y, q;
          if (!m)
            m = n;
          if (n)
            return jStat2.create(n, m, function() {
              return jStat2.randn();
            });
          do {
            u = jStat2._random_fn();
            v = 1.7156 * (jStat2._random_fn() - 0.5);
            x = u - 0.449871;
            y = Math2.abs(v) + 0.386595;
            q = x * x + y * (0.196 * y - 0.25472 * x);
          } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math2.log(u) * u * u));
          return v / u;
        };
        jStat2.randg = function randg(shape, n, m) {
          var oalph = shape;
          var a1, a2, u, v, x, mat;
          if (!m)
            m = n;
          if (!shape)
            shape = 1;
          if (n) {
            mat = jStat2.zeros(n, m);
            mat.alter(function() {
              return jStat2.randg(shape);
            });
            return mat;
          }
          if (shape < 1)
            shape += 1;
          a1 = shape - 1 / 3;
          a2 = 1 / Math2.sqrt(9 * a1);
          do {
            do {
              x = jStat2.randn();
              v = 1 + a2 * x;
            } while (v <= 0);
            v = v * v * v;
            u = jStat2._random_fn();
          } while (u > 1 - 0.331 * Math2.pow(x, 4) && Math2.log(u) > 0.5 * x * x + a1 * (1 - v + Math2.log(v)));
          if (shape == oalph)
            return a1 * v;
          do {
            u = jStat2._random_fn();
          } while (u === 0);
          return Math2.pow(u, 1 / oalph) * a1 * v;
        };
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jStat2.fn[passfunc] = function() {
              return jStat2(
                jStat2.map(this, function(value) {
                  return jStat2[passfunc](value);
                })
              );
            };
          })(funcs[i]);
        })("gammaln gammafn factorial factorialln".split(" "));
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jStat2.fn[passfunc] = function() {
              return jStat2(jStat2[passfunc].apply(null, arguments));
            };
          })(funcs[i]);
        })("randn".split(" "));
      })(jStat, Math);
      (function(jStat2, Math2) {
        (function(list) {
          for (var i = 0; i < list.length; i++) (function(func14) {
            jStat2[func14] = function f(a, b, c) {
              if (!(this instanceof f))
                return new f(a, b, c);
              this._a = a;
              this._b = b;
              this._c = c;
              return this;
            };
            jStat2.fn[func14] = function(a, b, c) {
              var newthis = jStat2[func14](a, b, c);
              newthis.data = this;
              return newthis;
            };
            jStat2[func14].prototype.sample = function(arr) {
              var a = this._a;
              var b = this._b;
              var c = this._c;
              if (arr)
                return jStat2.alter(arr, function() {
                  return jStat2[func14].sample(a, b, c);
                });
              else
                return jStat2[func14].sample(a, b, c);
            };
            (function(vals) {
              for (var i2 = 0; i2 < vals.length; i2++) (function(fnfunc) {
                jStat2[func14].prototype[fnfunc] = function(x) {
                  var a = this._a;
                  var b = this._b;
                  var c = this._c;
                  if (!x && x !== 0)
                    x = this.data;
                  if (typeof x !== "number") {
                    return jStat2.fn.map.call(x, function(x2) {
                      return jStat2[func14][fnfunc](x2, a, b, c);
                    });
                  }
                  return jStat2[func14][fnfunc](x, a, b, c);
                };
              })(vals[i2]);
            })("pdf cdf inv".split(" "));
            (function(vals) {
              for (var i2 = 0; i2 < vals.length; i2++) (function(fnfunc) {
                jStat2[func14].prototype[fnfunc] = function() {
                  return jStat2[func14][fnfunc](this._a, this._b, this._c);
                };
              })(vals[i2]);
            })("mean median mode variance".split(" "));
          })(list[i]);
        })("beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy laplace lognormal noncentralt normal pareto studentt weibull uniform binomial negbin hypgeom poisson triangular tukey arcsine".split(" "));
        jStat2.extend(jStat2.beta, {
          pdf: function pdf(x, alpha, beta) {
            if (x > 1 || x < 0)
              return 0;
            if (alpha == 1 && beta == 1)
              return 1;
            if (alpha < 512 && beta < 512) {
              return Math2.pow(x, alpha - 1) * Math2.pow(1 - x, beta - 1) / jStat2.betafn(alpha, beta);
            } else {
              return Math2.exp((alpha - 1) * Math2.log(x) + (beta - 1) * Math2.log(1 - x) - jStat2.betaln(alpha, beta));
            }
          },
          cdf: function cdf(x, alpha, beta) {
            return x > 1 || x < 0 ? (x > 1) * 1 : jStat2.ibeta(x, alpha, beta);
          },
          inv: function inv(x, alpha, beta) {
            return jStat2.ibetainv(x, alpha, beta);
          },
          mean: function mean(alpha, beta) {
            return alpha / (alpha + beta);
          },
          median: function median(alpha, beta) {
            return jStat2.ibetainv(0.5, alpha, beta);
          },
          mode: function mode(alpha, beta) {
            return (alpha - 1) / (alpha + beta - 2);
          },
          // return a random sample
          sample: function sample(alpha, beta) {
            var u = jStat2.randg(alpha);
            return u / (u + jStat2.randg(beta));
          },
          variance: function variance(alpha, beta) {
            return alpha * beta / (Math2.pow(alpha + beta, 2) * (alpha + beta + 1));
          }
        });
        jStat2.extend(jStat2.centralF, {
          // This implementation of the pdf function avoids float overflow
          // See the way that R calculates this value:
          // https://svn.r-project.org/R/trunk/src/nmath/df.c
          pdf: function pdf(x, df1, df2) {
            var p, q, f;
            if (x < 0)
              return 0;
            if (df1 <= 2) {
              if (x === 0 && df1 < 2) {
                return Infinity;
              }
              if (x === 0 && df1 === 2) {
                return 1;
              }
              return 1 / jStat2.betafn(df1 / 2, df2 / 2) * Math2.pow(df1 / df2, df1 / 2) * Math2.pow(x, df1 / 2 - 1) * Math2.pow(1 + df1 / df2 * x, -(df1 + df2) / 2);
            }
            p = df1 * x / (df2 + x * df1);
            q = df2 / (df2 + x * df1);
            f = df1 * q / 2;
            return f * jStat2.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
          },
          cdf: function cdf(x, df1, df2) {
            if (x < 0)
              return 0;
            return jStat2.ibeta(df1 * x / (df1 * x + df2), df1 / 2, df2 / 2);
          },
          inv: function inv(x, df1, df2) {
            return df2 / (df1 * (1 / jStat2.ibetainv(x, df1 / 2, df2 / 2) - 1));
          },
          mean: function mean(df1, df2) {
            return df2 > 2 ? df2 / (df2 - 2) : void 0;
          },
          mode: function mode(df1, df2) {
            return df1 > 2 ? df2 * (df1 - 2) / (df1 * (df2 + 2)) : void 0;
          },
          // return a random sample
          sample: function sample(df1, df2) {
            var x1 = jStat2.randg(df1 / 2) * 2;
            var x2 = jStat2.randg(df2 / 2) * 2;
            return x1 / df1 / (x2 / df2);
          },
          variance: function variance(df1, df2) {
            if (df2 <= 4)
              return void 0;
            return 2 * df2 * df2 * (df1 + df2 - 2) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
          }
        });
        jStat2.extend(jStat2.cauchy, {
          pdf: function pdf(x, local, scale) {
            if (scale < 0) {
              return 0;
            }
            return scale / (Math2.pow(x - local, 2) + Math2.pow(scale, 2)) / Math2.PI;
          },
          cdf: function cdf(x, local, scale) {
            return Math2.atan((x - local) / scale) / Math2.PI + 0.5;
          },
          inv: function(p, local, scale) {
            return local + scale * Math2.tan(Math2.PI * (p - 0.5));
          },
          median: function median(local) {
            return local;
          },
          mode: function mode(local) {
            return local;
          },
          sample: function sample(local, scale) {
            return jStat2.randn() * Math2.sqrt(1 / (2 * jStat2.randg(0.5))) * scale + local;
          }
        });
        jStat2.extend(jStat2.chisquare, {
          pdf: function pdf(x, dof) {
            if (x < 0)
              return 0;
            return x === 0 && dof === 2 ? 0.5 : Math2.exp((dof / 2 - 1) * Math2.log(x) - x / 2 - dof / 2 * Math2.log(2) - jStat2.gammaln(dof / 2));
          },
          cdf: function cdf(x, dof) {
            if (x < 0)
              return 0;
            return jStat2.lowRegGamma(dof / 2, x / 2);
          },
          inv: function(p, dof) {
            return 2 * jStat2.gammapinv(p, 0.5 * dof);
          },
          mean: function(dof) {
            return dof;
          },
          // TODO: this is an approximation (is there a better way?)
          median: function median(dof) {
            return dof * Math2.pow(1 - 2 / (9 * dof), 3);
          },
          mode: function mode(dof) {
            return dof - 2 > 0 ? dof - 2 : 0;
          },
          sample: function sample(dof) {
            return jStat2.randg(dof / 2) * 2;
          },
          variance: function variance(dof) {
            return 2 * dof;
          }
        });
        jStat2.extend(jStat2.exponential, {
          pdf: function pdf(x, rate) {
            return x < 0 ? 0 : rate * Math2.exp(-rate * x);
          },
          cdf: function cdf(x, rate) {
            return x < 0 ? 0 : 1 - Math2.exp(-rate * x);
          },
          inv: function(p, rate) {
            return -Math2.log(1 - p) / rate;
          },
          mean: function(rate) {
            return 1 / rate;
          },
          median: function(rate) {
            return 1 / rate * Math2.log(2);
          },
          mode: function mode() {
            return 0;
          },
          sample: function sample(rate) {
            return -1 / rate * Math2.log(jStat2._random_fn());
          },
          variance: function(rate) {
            return Math2.pow(rate, -2);
          }
        });
        jStat2.extend(jStat2.gamma, {
          pdf: function pdf(x, shape, scale) {
            if (x < 0)
              return 0;
            return x === 0 && shape === 1 ? 1 / scale : Math2.exp((shape - 1) * Math2.log(x) - x / scale - jStat2.gammaln(shape) - shape * Math2.log(scale));
          },
          cdf: function cdf(x, shape, scale) {
            if (x < 0)
              return 0;
            return jStat2.lowRegGamma(shape, x / scale);
          },
          inv: function(p, shape, scale) {
            return jStat2.gammapinv(p, shape) * scale;
          },
          mean: function(shape, scale) {
            return shape * scale;
          },
          mode: function mode(shape, scale) {
            if (shape > 1) return (shape - 1) * scale;
            return void 0;
          },
          sample: function sample(shape, scale) {
            return jStat2.randg(shape) * scale;
          },
          variance: function variance(shape, scale) {
            return shape * scale * scale;
          }
        });
        jStat2.extend(jStat2.invgamma, {
          pdf: function pdf(x, shape, scale) {
            if (x <= 0)
              return 0;
            return Math2.exp(-(shape + 1) * Math2.log(x) - scale / x - jStat2.gammaln(shape) + shape * Math2.log(scale));
          },
          cdf: function cdf(x, shape, scale) {
            if (x <= 0)
              return 0;
            return 1 - jStat2.lowRegGamma(shape, scale / x);
          },
          inv: function(p, shape, scale) {
            return scale / jStat2.gammapinv(1 - p, shape);
          },
          mean: function(shape, scale) {
            return shape > 1 ? scale / (shape - 1) : void 0;
          },
          mode: function mode(shape, scale) {
            return scale / (shape + 1);
          },
          sample: function sample(shape, scale) {
            return scale / jStat2.randg(shape);
          },
          variance: function variance(shape, scale) {
            if (shape <= 2)
              return void 0;
            return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
          }
        });
        jStat2.extend(jStat2.kumaraswamy, {
          pdf: function pdf(x, alpha, beta) {
            if (x === 0 && alpha === 1)
              return beta;
            else if (x === 1 && beta === 1)
              return alpha;
            return Math2.exp(Math2.log(alpha) + Math2.log(beta) + (alpha - 1) * Math2.log(x) + (beta - 1) * Math2.log(1 - Math2.pow(x, alpha)));
          },
          cdf: function cdf(x, alpha, beta) {
            if (x < 0)
              return 0;
            else if (x > 1)
              return 1;
            return 1 - Math2.pow(1 - Math2.pow(x, alpha), beta);
          },
          inv: function inv(p, alpha, beta) {
            return Math2.pow(1 - Math2.pow(1 - p, 1 / beta), 1 / alpha);
          },
          mean: function(alpha, beta) {
            return beta * jStat2.gammafn(1 + 1 / alpha) * jStat2.gammafn(beta) / jStat2.gammafn(1 + 1 / alpha + beta);
          },
          median: function median(alpha, beta) {
            return Math2.pow(1 - Math2.pow(2, -1 / beta), 1 / alpha);
          },
          mode: function mode(alpha, beta) {
            if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
              return void 0;
            return Math2.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
          },
          variance: function variance() {
            throw new Error("variance not yet implemented");
          }
        });
        jStat2.extend(jStat2.lognormal, {
          pdf: function pdf(x, mu, sigma) {
            if (x <= 0)
              return 0;
            return Math2.exp(-Math2.log(x) - 0.5 * Math2.log(2 * Math2.PI) - Math2.log(sigma) - Math2.pow(Math2.log(x) - mu, 2) / (2 * sigma * sigma));
          },
          cdf: function cdf(x, mu, sigma) {
            if (x < 0)
              return 0;
            return 0.5 + 0.5 * jStat2.erf((Math2.log(x) - mu) / Math2.sqrt(2 * sigma * sigma));
          },
          inv: function(p, mu, sigma) {
            return Math2.exp(-1.4142135623730951 * sigma * jStat2.erfcinv(2 * p) + mu);
          },
          mean: function mean(mu, sigma) {
            return Math2.exp(mu + sigma * sigma / 2);
          },
          median: function median(mu) {
            return Math2.exp(mu);
          },
          mode: function mode(mu, sigma) {
            return Math2.exp(mu - sigma * sigma);
          },
          sample: function sample(mu, sigma) {
            return Math2.exp(jStat2.randn() * sigma + mu);
          },
          variance: function variance(mu, sigma) {
            return (Math2.exp(sigma * sigma) - 1) * Math2.exp(2 * mu + sigma * sigma);
          }
        });
        jStat2.extend(jStat2.noncentralt, {
          pdf: function pdf(x, dof, ncp) {
            var tol = 1e-14;
            if (Math2.abs(ncp) < tol)
              return jStat2.studentt.pdf(x, dof);
            if (Math2.abs(x) < tol) {
              return Math2.exp(jStat2.gammaln((dof + 1) / 2) - ncp * ncp / 2 - 0.5 * Math2.log(Math2.PI * dof) - jStat2.gammaln(dof / 2));
            }
            return dof / x * (jStat2.noncentralt.cdf(x * Math2.sqrt(1 + 2 / dof), dof + 2, ncp) - jStat2.noncentralt.cdf(x, dof, ncp));
          },
          cdf: function cdf(x, dof, ncp) {
            var tol = 1e-14;
            var min_iterations = 200;
            if (Math2.abs(ncp) < tol)
              return jStat2.studentt.cdf(x, dof);
            var flip = false;
            if (x < 0) {
              flip = true;
              ncp = -ncp;
            }
            var prob = jStat2.normal.cdf(-ncp, 0, 1);
            var value = tol + 1;
            var lastvalue = value;
            var y = x * x / (x * x + dof);
            var j = 0;
            var p = Math2.exp(-ncp * ncp / 2);
            var q = Math2.exp(-ncp * ncp / 2 - 0.5 * Math2.log(2) - jStat2.gammaln(3 / 2)) * ncp;
            while (j < min_iterations || lastvalue > tol || value > tol) {
              lastvalue = value;
              if (j > 0) {
                p *= ncp * ncp / (2 * j);
                q *= ncp * ncp / (2 * (j + 1 / 2));
              }
              value = p * jStat2.beta.cdf(y, j + 0.5, dof / 2) + q * jStat2.beta.cdf(y, j + 1, dof / 2);
              prob += 0.5 * value;
              j++;
            }
            return flip ? 1 - prob : prob;
          }
        });
        jStat2.extend(jStat2.normal, {
          pdf: function pdf(x, mean, std) {
            return Math2.exp(-0.5 * Math2.log(2 * Math2.PI) - Math2.log(std) - Math2.pow(x - mean, 2) / (2 * std * std));
          },
          cdf: function cdf(x, mean, std) {
            return 0.5 * (1 + jStat2.erf((x - mean) / Math2.sqrt(2 * std * std)));
          },
          inv: function(p, mean, std) {
            return -1.4142135623730951 * std * jStat2.erfcinv(2 * p) + mean;
          },
          mean: function(mean) {
            return mean;
          },
          median: function median(mean) {
            return mean;
          },
          mode: function(mean) {
            return mean;
          },
          sample: function sample(mean, std) {
            return jStat2.randn() * std + mean;
          },
          variance: function(mean, std) {
            return std * std;
          }
        });
        jStat2.extend(jStat2.pareto, {
          pdf: function pdf(x, scale, shape) {
            if (x < scale)
              return 0;
            return shape * Math2.pow(scale, shape) / Math2.pow(x, shape + 1);
          },
          cdf: function cdf(x, scale, shape) {
            if (x < scale)
              return 0;
            return 1 - Math2.pow(scale / x, shape);
          },
          inv: function inv(p, scale, shape) {
            return scale / Math2.pow(1 - p, 1 / shape);
          },
          mean: function mean(scale, shape) {
            if (shape <= 1)
              return void 0;
            return shape * Math2.pow(scale, shape) / (shape - 1);
          },
          median: function median(scale, shape) {
            return scale * (shape * Math2.SQRT2);
          },
          mode: function mode(scale) {
            return scale;
          },
          variance: function(scale, shape) {
            if (shape <= 2)
              return void 0;
            return scale * scale * shape / (Math2.pow(shape - 1, 2) * (shape - 2));
          }
        });
        jStat2.extend(jStat2.studentt, {
          pdf: function pdf(x, dof) {
            dof = dof > 1e100 ? 1e100 : dof;
            return 1 / (Math2.sqrt(dof) * jStat2.betafn(0.5, dof / 2)) * Math2.pow(1 + x * x / dof, -((dof + 1) / 2));
          },
          cdf: function cdf(x, dof) {
            var dof2 = dof / 2;
            return jStat2.ibeta((x + Math2.sqrt(x * x + dof)) / (2 * Math2.sqrt(x * x + dof)), dof2, dof2);
          },
          inv: function(p, dof) {
            var x = jStat2.ibetainv(2 * Math2.min(p, 1 - p), 0.5 * dof, 0.5);
            x = Math2.sqrt(dof * (1 - x) / x);
            return p > 0.5 ? x : -x;
          },
          mean: function mean(dof) {
            return dof > 1 ? 0 : void 0;
          },
          median: function median() {
            return 0;
          },
          mode: function mode() {
            return 0;
          },
          sample: function sample(dof) {
            return jStat2.randn() * Math2.sqrt(dof / (2 * jStat2.randg(dof / 2)));
          },
          variance: function variance(dof) {
            return dof > 2 ? dof / (dof - 2) : dof > 1 ? Infinity : void 0;
          }
        });
        jStat2.extend(jStat2.weibull, {
          pdf: function pdf(x, scale, shape) {
            if (x < 0 || scale < 0 || shape < 0)
              return 0;
            return shape / scale * Math2.pow(x / scale, shape - 1) * Math2.exp(-Math2.pow(x / scale, shape));
          },
          cdf: function cdf(x, scale, shape) {
            return x < 0 ? 0 : 1 - Math2.exp(-Math2.pow(x / scale, shape));
          },
          inv: function(p, scale, shape) {
            return scale * Math2.pow(-Math2.log(1 - p), 1 / shape);
          },
          mean: function(scale, shape) {
            return scale * jStat2.gammafn(1 + 1 / shape);
          },
          median: function median(scale, shape) {
            return scale * Math2.pow(Math2.log(2), 1 / shape);
          },
          mode: function mode(scale, shape) {
            if (shape <= 1)
              return 0;
            return scale * Math2.pow((shape - 1) / shape, 1 / shape);
          },
          sample: function sample(scale, shape) {
            return scale * Math2.pow(-Math2.log(jStat2._random_fn()), 1 / shape);
          },
          variance: function variance(scale, shape) {
            return scale * scale * jStat2.gammafn(1 + 2 / shape) - Math2.pow(jStat2.weibull.mean(scale, shape), 2);
          }
        });
        jStat2.extend(jStat2.uniform, {
          pdf: function pdf(x, a, b) {
            return x < a || x > b ? 0 : 1 / (b - a);
          },
          cdf: function cdf(x, a, b) {
            if (x < a)
              return 0;
            else if (x < b)
              return (x - a) / (b - a);
            return 1;
          },
          inv: function(p, a, b) {
            return a + p * (b - a);
          },
          mean: function mean(a, b) {
            return 0.5 * (a + b);
          },
          median: function median(a, b) {
            return jStat2.mean(a, b);
          },
          mode: function mode() {
            throw new Error("mode is not yet implemented");
          },
          sample: function sample(a, b) {
            return a / 2 + b / 2 + (b / 2 - a / 2) * (2 * jStat2._random_fn() - 1);
          },
          variance: function variance(a, b) {
            return Math2.pow(b - a, 2) / 12;
          }
        });
        function betinc(x, a, b, eps) {
          var a0 = 0;
          var b0 = 1;
          var a1 = 1;
          var b1 = 1;
          var m9 = 0;
          var a2 = 0;
          var c9;
          while (Math2.abs((a1 - a2) / a1) > eps) {
            a2 = a1;
            c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
            a0 = a1 + c9 * a0;
            b0 = b1 + c9 * b0;
            m9 = m9 + 1;
            c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
            a1 = a0 + c9 * a1;
            b1 = b0 + c9 * b1;
            a0 = a0 / b1;
            b0 = b0 / b1;
            a1 = a1 / b1;
            b1 = 1;
          }
          return a1 / a;
        }
        jStat2.extend(jStat2.binomial, {
          pdf: function pdf(k, n, p) {
            return p === 0 || p === 1 ? n * p === k ? 1 : 0 : jStat2.combination(n, k) * Math2.pow(p, k) * Math2.pow(1 - p, n - k);
          },
          cdf: function cdf(x, n, p) {
            var betacdf;
            var eps = 1e-10;
            if (x < 0)
              return 0;
            if (x >= n)
              return 1;
            if (p < 0 || p > 1 || n <= 0)
              return NaN;
            x = Math2.floor(x);
            var z = p;
            var a = x + 1;
            var b = n - x;
            var s = a + b;
            var bt = Math2.exp(jStat2.gammaln(s) - jStat2.gammaln(b) - jStat2.gammaln(a) + a * Math2.log(z) + b * Math2.log(1 - z));
            if (z < (a + 1) / (s + 2))
              betacdf = bt * betinc(z, a, b, eps);
            else
              betacdf = 1 - bt * betinc(1 - z, b, a, eps);
            return Math2.round((1 - betacdf) * (1 / eps)) / (1 / eps);
          }
        });
        jStat2.extend(jStat2.negbin, {
          pdf: function pdf(k, r, p) {
            if (k !== k >>> 0)
              return false;
            if (k < 0)
              return 0;
            return jStat2.combination(k + r - 1, r - 1) * Math2.pow(1 - p, k) * Math2.pow(p, r);
          },
          cdf: function cdf(x, r, p) {
            var sum = 0, k = 0;
            if (x < 0) return 0;
            for (; k <= x; k++) {
              sum += jStat2.negbin.pdf(k, r, p);
            }
            return sum;
          }
        });
        jStat2.extend(jStat2.hypgeom, {
          pdf: function pdf(k, N, m, n) {
            if (k !== k | 0) {
              return false;
            } else if (k < 0 || k < m - (N - n)) {
              return 0;
            } else if (k > n || k > m) {
              return 0;
            } else if (m * 2 > N) {
              if (n * 2 > N) {
                return jStat2.hypgeom.pdf(N - m - n + k, N, N - m, N - n);
              } else {
                return jStat2.hypgeom.pdf(n - k, N, N - m, n);
              }
            } else if (n * 2 > N) {
              return jStat2.hypgeom.pdf(m - k, N, m, N - n);
            } else if (m < n) {
              return jStat2.hypgeom.pdf(k, N, n, m);
            } else {
              var scaledPDF = 1;
              var samplesDone = 0;
              for (var i = 0; i < k; i++) {
                while (scaledPDF > 1 && samplesDone < n) {
                  scaledPDF *= 1 - m / (N - samplesDone);
                  samplesDone++;
                }
                scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
              }
              for (; samplesDone < n; samplesDone++) {
                scaledPDF *= 1 - m / (N - samplesDone);
              }
              return Math2.min(1, Math2.max(0, scaledPDF));
            }
          },
          cdf: function cdf(x, N, m, n) {
            if (x < 0 || x < m - (N - n)) {
              return 0;
            } else if (x >= n || x >= m) {
              return 1;
            } else if (m * 2 > N) {
              if (n * 2 > N) {
                return jStat2.hypgeom.cdf(N - m - n + x, N, N - m, N - n);
              } else {
                return 1 - jStat2.hypgeom.cdf(n - x - 1, N, N - m, n);
              }
            } else if (n * 2 > N) {
              return 1 - jStat2.hypgeom.cdf(m - x - 1, N, m, N - n);
            } else if (m < n) {
              return jStat2.hypgeom.cdf(x, N, n, m);
            } else {
              var scaledCDF = 1;
              var scaledPDF = 1;
              var samplesDone = 0;
              for (var i = 0; i < x; i++) {
                while (scaledCDF > 1 && samplesDone < n) {
                  var factor = 1 - m / (N - samplesDone);
                  scaledPDF *= factor;
                  scaledCDF *= factor;
                  samplesDone++;
                }
                scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
                scaledCDF += scaledPDF;
              }
              for (; samplesDone < n; samplesDone++) {
                scaledCDF *= 1 - m / (N - samplesDone);
              }
              return Math2.min(1, Math2.max(0, scaledCDF));
            }
          }
        });
        jStat2.extend(jStat2.poisson, {
          pdf: function pdf(k, l) {
            if (l < 0 || k % 1 !== 0 || k < 0) {
              return 0;
            }
            return Math2.pow(l, k) * Math2.exp(-l) / jStat2.factorial(k);
          },
          cdf: function cdf(x, l) {
            var sumarr = [], k = 0;
            if (x < 0) return 0;
            for (; k <= x; k++) {
              sumarr.push(jStat2.poisson.pdf(k, l));
            }
            return jStat2.sum(sumarr);
          },
          mean: function(l) {
            return l;
          },
          variance: function(l) {
            return l;
          },
          sampleSmall: function sampleSmall(l) {
            var p = 1, k = 0, L = Math2.exp(-l);
            do {
              k++;
              p *= jStat2._random_fn();
            } while (p > L);
            return k - 1;
          },
          sampleLarge: function sampleLarge(l) {
            var lam = l;
            var k;
            var U, V, slam, loglam, a, b, invalpha, vr, us;
            slam = Math2.sqrt(lam);
            loglam = Math2.log(lam);
            b = 0.931 + 2.53 * slam;
            a = -0.059 + 0.02483 * b;
            invalpha = 1.1239 + 1.1328 / (b - 3.4);
            vr = 0.9277 - 3.6224 / (b - 2);
            while (1) {
              U = Math2.random() - 0.5;
              V = Math2.random();
              us = 0.5 - Math2.abs(U);
              k = Math2.floor((2 * a / us + b) * U + lam + 0.43);
              if (us >= 0.07 && V <= vr) {
                return k;
              }
              if (k < 0 || us < 0.013 && V > us) {
                continue;
              }
              if (Math2.log(V) + Math2.log(invalpha) - Math2.log(a / (us * us) + b) <= -lam + k * loglam - jStat2.loggam(k + 1)) {
                return k;
              }
            }
          },
          sample: function sample(l) {
            if (l < 10)
              return this.sampleSmall(l);
            else
              return this.sampleLarge(l);
          }
        });
        jStat2.extend(jStat2.triangular, {
          pdf: function pdf(x, a, b, c) {
            if (b <= a || c < a || c > b) {
              return NaN;
            } else {
              if (x < a || x > b) {
                return 0;
              } else if (x < c) {
                return 2 * (x - a) / ((b - a) * (c - a));
              } else if (x === c) {
                return 2 / (b - a);
              } else {
                return 2 * (b - x) / ((b - a) * (b - c));
              }
            }
          },
          cdf: function cdf(x, a, b, c) {
            if (b <= a || c < a || c > b)
              return NaN;
            if (x <= a)
              return 0;
            else if (x >= b)
              return 1;
            if (x <= c)
              return Math2.pow(x - a, 2) / ((b - a) * (c - a));
            else
              return 1 - Math2.pow(b - x, 2) / ((b - a) * (b - c));
          },
          inv: function inv(p, a, b, c) {
            if (b <= a || c < a || c > b) {
              return NaN;
            } else {
              if (p <= (c - a) / (b - a)) {
                return a + (b - a) * Math2.sqrt(p * ((c - a) / (b - a)));
              } else {
                return a + (b - a) * (1 - Math2.sqrt((1 - p) * (1 - (c - a) / (b - a))));
              }
            }
          },
          mean: function mean(a, b, c) {
            return (a + b + c) / 3;
          },
          median: function median(a, b, c) {
            if (c <= (a + b) / 2) {
              return b - Math2.sqrt((b - a) * (b - c)) / Math2.sqrt(2);
            } else if (c > (a + b) / 2) {
              return a + Math2.sqrt((b - a) * (c - a)) / Math2.sqrt(2);
            }
          },
          mode: function mode(a, b, c) {
            return c;
          },
          sample: function sample(a, b, c) {
            var u = jStat2._random_fn();
            if (u < (c - a) / (b - a))
              return a + Math2.sqrt(u * (b - a) * (c - a));
            return b - Math2.sqrt((1 - u) * (b - a) * (b - c));
          },
          variance: function variance(a, b, c) {
            return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
          }
        });
        jStat2.extend(jStat2.arcsine, {
          pdf: function pdf(x, a, b) {
            if (b <= a) return NaN;
            return x <= a || x >= b ? 0 : 2 / Math2.PI * Math2.pow(Math2.pow(b - a, 2) - Math2.pow(2 * x - a - b, 2), -0.5);
          },
          cdf: function cdf(x, a, b) {
            if (x < a)
              return 0;
            else if (x < b)
              return 2 / Math2.PI * Math2.asin(Math2.sqrt((x - a) / (b - a)));
            return 1;
          },
          inv: function(p, a, b) {
            return a + (0.5 - 0.5 * Math2.cos(Math2.PI * p)) * (b - a);
          },
          mean: function mean(a, b) {
            if (b <= a) return NaN;
            return (a + b) / 2;
          },
          median: function median(a, b) {
            if (b <= a) return NaN;
            return (a + b) / 2;
          },
          mode: function mode() {
            throw new Error("mode is not yet implemented");
          },
          sample: function sample(a, b) {
            return (a + b) / 2 + (b - a) / 2 * Math2.sin(2 * Math2.PI * jStat2.uniform.sample(0, 1));
          },
          variance: function variance(a, b) {
            if (b <= a) return NaN;
            return Math2.pow(b - a, 2) / 8;
          }
        });
        function laplaceSign(x) {
          return x / Math2.abs(x);
        }
        jStat2.extend(jStat2.laplace, {
          pdf: function pdf(x, mu, b) {
            return b <= 0 ? 0 : Math2.exp(-Math2.abs(x - mu) / b) / (2 * b);
          },
          cdf: function cdf(x, mu, b) {
            if (b <= 0) {
              return 0;
            }
            if (x < mu) {
              return 0.5 * Math2.exp((x - mu) / b);
            } else {
              return 1 - 0.5 * Math2.exp(-(x - mu) / b);
            }
          },
          mean: function(mu) {
            return mu;
          },
          median: function(mu) {
            return mu;
          },
          mode: function(mu) {
            return mu;
          },
          variance: function(mu, b) {
            return 2 * b * b;
          },
          sample: function sample(mu, b) {
            var u = jStat2._random_fn() - 0.5;
            return mu - b * laplaceSign(u) * Math2.log(1 - 2 * Math2.abs(u));
          }
        });
        function tukeyWprob(w, rr, cc) {
          var nleg = 12;
          var ihalf = 6;
          var C1 = -30;
          var C2 = -50;
          var C3 = 60;
          var bb = 8;
          var wlar = 3;
          var wincr1 = 2;
          var wincr2 = 3;
          var xleg = [
            0.9815606342467192,
            0.9041172563704749,
            0.7699026741943047,
            0.5873179542866175,
            0.3678314989981802,
            0.1252334085114689
          ];
          var aleg = [
            0.04717533638651183,
            0.10693932599531843,
            0.16007832854334622,
            0.20316742672306592,
            0.2334925365383548,
            0.24914704581340277
          ];
          var qsqz = w * 0.5;
          if (qsqz >= bb)
            return 1;
          var pr_w = 2 * jStat2.normal.cdf(qsqz, 0, 1, 1, 0) - 1;
          if (pr_w >= Math2.exp(C2 / cc))
            pr_w = Math2.pow(pr_w, cc);
          else
            pr_w = 0;
          var wincr;
          if (w > wlar)
            wincr = wincr1;
          else
            wincr = wincr2;
          var blb = qsqz;
          var binc = (bb - qsqz) / wincr;
          var bub = blb + binc;
          var einsum = 0;
          var cc1 = cc - 1;
          for (var wi = 1; wi <= wincr; wi++) {
            var elsum = 0;
            var a = 0.5 * (bub + blb);
            var b = 0.5 * (bub - blb);
            for (var jj = 1; jj <= nleg; jj++) {
              var j, xx;
              if (ihalf < jj) {
                j = nleg - jj + 1;
                xx = xleg[j - 1];
              } else {
                j = jj;
                xx = -xleg[j - 1];
              }
              var c = b * xx;
              var ac = a + c;
              var qexpo = ac * ac;
              if (qexpo > C3)
                break;
              var pplus = 2 * jStat2.normal.cdf(ac, 0, 1, 1, 0);
              var pminus = 2 * jStat2.normal.cdf(ac, w, 1, 1, 0);
              var rinsum = pplus * 0.5 - pminus * 0.5;
              if (rinsum >= Math2.exp(C1 / cc1)) {
                rinsum = aleg[j - 1] * Math2.exp(-(0.5 * qexpo)) * Math2.pow(rinsum, cc1);
                elsum += rinsum;
              }
            }
            elsum *= 2 * b * cc / Math2.sqrt(2 * Math2.PI);
            einsum += elsum;
            blb = bub;
            bub += binc;
          }
          pr_w += einsum;
          if (pr_w <= Math2.exp(C1 / rr))
            return 0;
          pr_w = Math2.pow(pr_w, rr);
          if (pr_w >= 1)
            return 1;
          return pr_w;
        }
        function tukeyQinv(p, c, v) {
          var p0 = 0.322232421088;
          var q0 = 0.099348462606;
          var p1 = -1;
          var q1 = 0.588581570495;
          var p2 = -0.342242088547;
          var q2 = 0.531103462366;
          var p3 = -0.204231210125;
          var q3 = 0.10353775285;
          var p4 = -453642210148e-16;
          var q4 = 0.0038560700634;
          var c1 = 0.8832;
          var c2 = 0.2368;
          var c3 = 1.214;
          var c4 = 1.208;
          var c5 = 1.4142;
          var vmax = 120;
          var ps = 0.5 - 0.5 * p;
          var yi = Math2.sqrt(Math2.log(1 / (ps * ps)));
          var t = yi + ((((yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0) / ((((yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);
          if (v < vmax) t += (t * t * t + t) / v / 4;
          var q = c1 - c2 * t;
          if (v < vmax) q += -c3 / v + c4 * t / v;
          return t * (q * Math2.log(c - 1) + c5);
        }
        jStat2.extend(jStat2.tukey, {
          cdf: function cdf(q, nmeans, df) {
            var rr = 1;
            var cc = nmeans;
            var nlegq = 16;
            var ihalfq = 8;
            var eps1 = -30;
            var eps2 = 1e-14;
            var dhaf = 100;
            var dquar = 800;
            var deigh = 5e3;
            var dlarg = 25e3;
            var ulen1 = 1;
            var ulen2 = 0.5;
            var ulen3 = 0.25;
            var ulen4 = 0.125;
            var xlegq = [
              0.9894009349916499,
              0.9445750230732326,
              0.8656312023878318,
              0.755404408355003,
              0.6178762444026438,
              0.45801677765722737,
              0.2816035507792589,
              0.09501250983763744
            ];
            var alegq = [
              0.027152459411754096,
              0.062253523938647894,
              0.09515851168249279,
              0.12462897125553388,
              0.14959598881657674,
              0.16915651939500254,
              0.18260341504492358,
              0.1894506104550685
            ];
            if (q <= 0)
              return 0;
            if (df < 2 || rr < 1 || cc < 2) return NaN;
            if (!Number.isFinite(q))
              return 1;
            if (df > dlarg)
              return tukeyWprob(q, rr, cc);
            var f2 = df * 0.5;
            var f2lf = f2 * Math2.log(df) - df * Math2.log(2) - jStat2.gammaln(f2);
            var f21 = f2 - 1;
            var ff4 = df * 0.25;
            var ulen;
            if (df <= dhaf) ulen = ulen1;
            else if (df <= dquar) ulen = ulen2;
            else if (df <= deigh) ulen = ulen3;
            else ulen = ulen4;
            f2lf += Math2.log(ulen);
            var ans = 0;
            for (var i = 1; i <= 50; i++) {
              var otsum = 0;
              var twa1 = (2 * i - 1) * ulen;
              for (var jj = 1; jj <= nlegq; jj++) {
                var j, t1;
                if (ihalfq < jj) {
                  j = jj - ihalfq - 1;
                  t1 = f2lf + f21 * Math2.log(twa1 + xlegq[j] * ulen) - (xlegq[j] * ulen + twa1) * ff4;
                } else {
                  j = jj - 1;
                  t1 = f2lf + f21 * Math2.log(twa1 - xlegq[j] * ulen) + (xlegq[j] * ulen - twa1) * ff4;
                }
                var qsqz;
                if (t1 >= eps1) {
                  if (ihalfq < jj) {
                    qsqz = q * Math2.sqrt((xlegq[j] * ulen + twa1) * 0.5);
                  } else {
                    qsqz = q * Math2.sqrt((-(xlegq[j] * ulen) + twa1) * 0.5);
                  }
                  var wprb = tukeyWprob(qsqz, rr, cc);
                  var rotsum = wprb * alegq[j] * Math2.exp(t1);
                  otsum += rotsum;
                }
              }
              if (i * ulen >= 1 && otsum <= eps2)
                break;
              ans += otsum;
            }
            if (otsum > eps2) {
              throw new Error("tukey.cdf failed to converge");
            }
            if (ans > 1)
              ans = 1;
            return ans;
          },
          inv: function(p, nmeans, df) {
            var rr = 1;
            var cc = nmeans;
            var eps = 1e-4;
            var maxiter = 50;
            if (df < 2 || rr < 1 || cc < 2) return NaN;
            if (p < 0 || p > 1) return NaN;
            if (p === 0) return 0;
            if (p === 1) return Infinity;
            var x0 = tukeyQinv(p, cc, df);
            var valx0 = jStat2.tukey.cdf(x0, nmeans, df) - p;
            var x1;
            if (valx0 > 0)
              x1 = Math2.max(0, x0 - 1);
            else
              x1 = x0 + 1;
            var valx1 = jStat2.tukey.cdf(x1, nmeans, df) - p;
            var ans;
            for (var iter = 1; iter < maxiter; iter++) {
              ans = x1 - valx1 * (x1 - x0) / (valx1 - valx0);
              valx0 = valx1;
              x0 = x1;
              if (ans < 0) {
                ans = 0;
                valx1 = -p;
              }
              valx1 = jStat2.tukey.cdf(ans, nmeans, df) - p;
              x1 = ans;
              var xabs = Math2.abs(x1 - x0);
              if (xabs < eps)
                return ans;
            }
            throw new Error("tukey.inv failed to converge");
          }
        });
      })(jStat, Math);
      (function(jStat2, Math2) {
        var push = Array.prototype.push;
        var isArray = jStat2.utils.isArray;
        function isUsable(arg) {
          return isArray(arg) || arg instanceof jStat2;
        }
        jStat2.extend({
          // add a vector/matrix to a vector/matrix or scalar
          add: function add(arr, arg) {
            if (isUsable(arg)) {
              if (!isUsable(arg[0])) arg = [arg];
              return jStat2.map(arr, function(value, row, col) {
                return value + arg[row][col];
              });
            }
            return jStat2.map(arr, function(value) {
              return value + arg;
            });
          },
          // subtract a vector or scalar from the vector
          subtract: function subtract(arr, arg) {
            if (isUsable(arg)) {
              if (!isUsable(arg[0])) arg = [arg];
              return jStat2.map(arr, function(value, row, col) {
                return value - arg[row][col] || 0;
              });
            }
            return jStat2.map(arr, function(value) {
              return value - arg;
            });
          },
          // matrix division
          divide: function divide(arr, arg) {
            if (isUsable(arg)) {
              if (!isUsable(arg[0])) arg = [arg];
              return jStat2.multiply(arr, jStat2.inv(arg));
            }
            return jStat2.map(arr, function(value) {
              return value / arg;
            });
          },
          // matrix multiplication
          multiply: function multiply(arr, arg) {
            var row, col, nrescols, sum, nrow, ncol, res, rescols;
            if (arr.length === void 0 && arg.length === void 0) {
              return arr * arg;
            }
            nrow = arr.length, ncol = arr[0].length, res = jStat2.zeros(nrow, nrescols = isUsable(arg) ? arg[0].length : ncol), rescols = 0;
            if (isUsable(arg)) {
              for (; rescols < nrescols; rescols++) {
                for (row = 0; row < nrow; row++) {
                  sum = 0;
                  for (col = 0; col < ncol; col++)
                    sum += arr[row][col] * arg[col][rescols];
                  res[row][rescols] = sum;
                }
              }
              return nrow === 1 && rescols === 1 ? res[0][0] : res;
            }
            return jStat2.map(arr, function(value) {
              return value * arg;
            });
          },
          // outer([1,2,3],[4,5,6])
          // ===
          // [[1],[2],[3]] times [[4,5,6]]
          // ->
          // [[4,5,6],[8,10,12],[12,15,18]]
          outer: function outer(A, B) {
            return jStat2.multiply(A.map(function(t) {
              return [t];
            }), [B]);
          },
          // Returns the dot product of two matricies
          dot: function dot(arr, arg) {
            if (!isUsable(arr[0])) arr = [arr];
            if (!isUsable(arg[0])) arg = [arg];
            var left = arr[0].length === 1 && arr.length !== 1 ? jStat2.transpose(arr) : arr, right = arg[0].length === 1 && arg.length !== 1 ? jStat2.transpose(arg) : arg, res = [], row = 0, nrow = left.length, ncol = left[0].length, sum, col;
            for (; row < nrow; row++) {
              res[row] = [];
              sum = 0;
              for (col = 0; col < ncol; col++)
                sum += left[row][col] * right[row][col];
              res[row] = sum;
            }
            return res.length === 1 ? res[0] : res;
          },
          // raise every element by a scalar
          pow: function pow(arr, arg) {
            return jStat2.map(arr, function(value) {
              return Math2.pow(value, arg);
            });
          },
          // exponentiate every element
          exp: function exp(arr) {
            return jStat2.map(arr, function(value) {
              return Math2.exp(value);
            });
          },
          // generate the natural log of every element
          log: function exp(arr) {
            return jStat2.map(arr, function(value) {
              return Math2.log(value);
            });
          },
          // generate the absolute values of the vector
          abs: function abs(arr) {
            return jStat2.map(arr, function(value) {
              return Math2.abs(value);
            });
          },
          // computes the p-norm of the vector
          // In the case that a matrix is passed, uses the first row as the vector
          norm: function norm(arr, p) {
            var nnorm = 0, i = 0;
            if (isNaN(p)) p = 2;
            if (isUsable(arr[0])) arr = arr[0];
            for (; i < arr.length; i++) {
              nnorm += Math2.pow(Math2.abs(arr[i]), p);
            }
            return Math2.pow(nnorm, 1 / p);
          },
          // computes the angle between two vectors in rads
          // In case a matrix is passed, this uses the first row as the vector
          angle: function angle(arr, arg) {
            return Math2.acos(jStat2.dot(arr, arg) / (jStat2.norm(arr) * jStat2.norm(arg)));
          },
          // augment one matrix by another
          // Note: this function returns a matrix, not a jStat object
          aug: function aug(a, b) {
            var newarr = [];
            var i;
            for (i = 0; i < a.length; i++) {
              newarr.push(a[i].slice());
            }
            for (i = 0; i < newarr.length; i++) {
              push.apply(newarr[i], b[i]);
            }
            return newarr;
          },
          // The inv() function calculates the inverse of a matrix
          // Create the inverse by augmenting the matrix by the identity matrix of the
          // appropriate size, and then use G-J elimination on the augmented matrix.
          inv: function inv(a) {
            var rows = a.length;
            var cols = a[0].length;
            var b = jStat2.identity(rows, cols);
            var c = jStat2.gauss_jordan(a, b);
            var result = [];
            var i = 0;
            var j;
            for (; i < rows; i++) {
              result[i] = [];
              for (j = cols; j < c[0].length; j++)
                result[i][j - cols] = c[i][j];
            }
            return result;
          },
          // calculate the determinant of a matrix
          det: function det(a) {
            if (a.length === 2) {
              return a[0][0] * a[1][1] - a[0][1] * a[1][0];
            }
            var determinant = 0;
            for (var i = 0; i < a.length; i++) {
              var submatrix = [];
              for (var row = 1; row < a.length; row++) {
                submatrix[row - 1] = [];
                for (var col = 0; col < a.length; col++) {
                  if (col < i) {
                    submatrix[row - 1][col] = a[row][col];
                  } else if (col > i) {
                    submatrix[row - 1][col - 1] = a[row][col];
                  }
                }
              }
              var sign = i % 2 ? -1 : 1;
              determinant += det(submatrix) * a[0][i] * sign;
            }
            return determinant;
          },
          gauss_elimination: function gauss_elimination(a, b) {
            var i = 0, j = 0, n = a.length, m = a[0].length, factor = 1, sum = 0, x = [], maug, pivot, temp, k;
            a = jStat2.aug(a, b);
            maug = a[0].length;
            for (i = 0; i < n; i++) {
              pivot = a[i][i];
              j = i;
              for (k = i + 1; k < m; k++) {
                if (pivot < Math2.abs(a[k][i])) {
                  pivot = a[k][i];
                  j = k;
                }
              }
              if (j != i) {
                for (k = 0; k < maug; k++) {
                  temp = a[i][k];
                  a[i][k] = a[j][k];
                  a[j][k] = temp;
                }
              }
              for (j = i + 1; j < n; j++) {
                factor = a[j][i] / a[i][i];
                for (k = i; k < maug; k++) {
                  a[j][k] = a[j][k] - factor * a[i][k];
                }
              }
            }
            for (i = n - 1; i >= 0; i--) {
              sum = 0;
              for (j = i + 1; j <= n - 1; j++) {
                sum = sum + x[j] * a[i][j];
              }
              x[i] = (a[i][maug - 1] - sum) / a[i][i];
            }
            return x;
          },
          gauss_jordan: function gauss_jordan(a, b) {
            var m = jStat2.aug(a, b);
            var h = m.length;
            var w = m[0].length;
            var c = 0;
            var x, y, y2;
            for (y = 0; y < h; y++) {
              var maxrow = y;
              for (y2 = y + 1; y2 < h; y2++) {
                if (Math2.abs(m[y2][y]) > Math2.abs(m[maxrow][y]))
                  maxrow = y2;
              }
              var tmp = m[y];
              m[y] = m[maxrow];
              m[maxrow] = tmp;
              for (y2 = y + 1; y2 < h; y2++) {
                c = m[y2][y] / m[y][y];
                for (x = y; x < w; x++) {
                  m[y2][x] -= m[y][x] * c;
                }
              }
            }
            for (y = h - 1; y >= 0; y--) {
              c = m[y][y];
              for (y2 = 0; y2 < y; y2++) {
                for (x = w - 1; x > y - 1; x--) {
                  m[y2][x] -= m[y][x] * m[y2][y] / c;
                }
              }
              m[y][y] /= c;
              for (x = h; x < w; x++) {
                m[y][x] /= c;
              }
            }
            return m;
          },
          // solve equation
          // Ax=b
          // A is upper triangular matrix
          // A=[[1,2,3],[0,4,5],[0,6,7]]
          // b=[1,2,3]
          // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]
          // if you use matrix style
          // A=[[1,2,3],[0,4,5],[0,6,7]]
          // b=[[1],[2],[3]]
          // will return [[2.666],[0.1666],[1.666]]
          triaUpSolve: function triaUpSolve(A, b) {
            var size = A[0].length;
            var x = jStat2.zeros(1, size)[0];
            var parts;
            var matrix_mode = false;
            if (b[0].length != void 0) {
              b = b.map(function(i) {
                return i[0];
              });
              matrix_mode = true;
            }
            jStat2.arange(size - 1, -1, -1).forEach(function(i) {
              parts = jStat2.arange(i + 1, size).map(function(j) {
                return x[j] * A[i][j];
              });
              x[i] = (b[i] - jStat2.sum(parts)) / A[i][i];
            });
            if (matrix_mode)
              return x.map(function(i) {
                return [i];
              });
            return x;
          },
          triaLowSolve: function triaLowSolve(A, b) {
            var size = A[0].length;
            var x = jStat2.zeros(1, size)[0];
            var parts;
            var matrix_mode = false;
            if (b[0].length != void 0) {
              b = b.map(function(i) {
                return i[0];
              });
              matrix_mode = true;
            }
            jStat2.arange(size).forEach(function(i) {
              parts = jStat2.arange(i).map(function(j) {
                return A[i][j] * x[j];
              });
              x[i] = (b[i] - jStat2.sum(parts)) / A[i][i];
            });
            if (matrix_mode)
              return x.map(function(i) {
                return [i];
              });
            return x;
          },
          // A -> [L,U]
          // A=LU
          // L is lower triangular matrix
          // U is upper triangular matrix
          lu: function lu(A) {
            var size = A.length;
            var L = jStat2.identity(size);
            var R = jStat2.zeros(A.length, A[0].length);
            var parts;
            jStat2.arange(size).forEach(function(t) {
              R[0][t] = A[0][t];
            });
            jStat2.arange(1, size).forEach(function(l) {
              jStat2.arange(l).forEach(function(i) {
                parts = jStat2.arange(i).map(function(jj) {
                  return L[l][jj] * R[jj][i];
                });
                L[l][i] = (A[l][i] - jStat2.sum(parts)) / R[i][i];
              });
              jStat2.arange(l, size).forEach(function(j) {
                parts = jStat2.arange(l).map(function(jj) {
                  return L[l][jj] * R[jj][j];
                });
                R[l][j] = A[parts.length][j] - jStat2.sum(parts);
              });
            });
            return [L, R];
          },
          // A -> T
          // A=TT'
          // T is lower triangular matrix
          cholesky: function cholesky(A) {
            var size = A.length;
            var T = jStat2.zeros(A.length, A[0].length);
            var parts;
            jStat2.arange(size).forEach(function(i) {
              parts = jStat2.arange(i).map(function(t) {
                return Math2.pow(T[i][t], 2);
              });
              T[i][i] = Math2.sqrt(A[i][i] - jStat2.sum(parts));
              jStat2.arange(i + 1, size).forEach(function(j) {
                parts = jStat2.arange(i).map(function(t) {
                  return T[i][t] * T[j][t];
                });
                T[j][i] = (A[i][j] - jStat2.sum(parts)) / T[i][i];
              });
            });
            return T;
          },
          gauss_jacobi: function gauss_jacobi(a, b, x, r) {
            var i = 0;
            var j = 0;
            var n = a.length;
            var l = [];
            var u = [];
            var d = [];
            var xv, c, h, xk;
            for (; i < n; i++) {
              l[i] = [];
              u[i] = [];
              d[i] = [];
              for (j = 0; j < n; j++) {
                if (i > j) {
                  l[i][j] = a[i][j];
                  u[i][j] = d[i][j] = 0;
                } else if (i < j) {
                  u[i][j] = a[i][j];
                  l[i][j] = d[i][j] = 0;
                } else {
                  d[i][j] = a[i][j];
                  l[i][j] = u[i][j] = 0;
                }
              }
            }
            h = jStat2.multiply(jStat2.multiply(jStat2.inv(d), jStat2.add(l, u)), -1);
            c = jStat2.multiply(jStat2.inv(d), b);
            xv = x;
            xk = jStat2.add(jStat2.multiply(h, x), c);
            i = 2;
            while (Math2.abs(jStat2.norm(jStat2.subtract(xk, xv))) > r) {
              xv = xk;
              xk = jStat2.add(jStat2.multiply(h, xv), c);
              i++;
            }
            return xk;
          },
          gauss_seidel: function gauss_seidel(a, b, x, r) {
            var i = 0;
            var n = a.length;
            var l = [];
            var u = [];
            var d = [];
            var j, xv, c, h, xk;
            for (; i < n; i++) {
              l[i] = [];
              u[i] = [];
              d[i] = [];
              for (j = 0; j < n; j++) {
                if (i > j) {
                  l[i][j] = a[i][j];
                  u[i][j] = d[i][j] = 0;
                } else if (i < j) {
                  u[i][j] = a[i][j];
                  l[i][j] = d[i][j] = 0;
                } else {
                  d[i][j] = a[i][j];
                  l[i][j] = u[i][j] = 0;
                }
              }
            }
            h = jStat2.multiply(jStat2.multiply(jStat2.inv(jStat2.add(d, l)), u), -1);
            c = jStat2.multiply(jStat2.inv(jStat2.add(d, l)), b);
            xv = x;
            xk = jStat2.add(jStat2.multiply(h, x), c);
            i = 2;
            while (Math2.abs(jStat2.norm(jStat2.subtract(xk, xv))) > r) {
              xv = xk;
              xk = jStat2.add(jStat2.multiply(h, xv), c);
              i = i + 1;
            }
            return xk;
          },
          SOR: function SOR(a, b, x, r, w) {
            var i = 0;
            var n = a.length;
            var l = [];
            var u = [];
            var d = [];
            var j, xv, c, h, xk;
            for (; i < n; i++) {
              l[i] = [];
              u[i] = [];
              d[i] = [];
              for (j = 0; j < n; j++) {
                if (i > j) {
                  l[i][j] = a[i][j];
                  u[i][j] = d[i][j] = 0;
                } else if (i < j) {
                  u[i][j] = a[i][j];
                  l[i][j] = d[i][j] = 0;
                } else {
                  d[i][j] = a[i][j];
                  l[i][j] = u[i][j] = 0;
                }
              }
            }
            h = jStat2.multiply(
              jStat2.inv(jStat2.add(d, jStat2.multiply(l, w))),
              jStat2.subtract(
                jStat2.multiply(d, 1 - w),
                jStat2.multiply(u, w)
              )
            );
            c = jStat2.multiply(jStat2.multiply(jStat2.inv(jStat2.add(
              d,
              jStat2.multiply(l, w)
            )), b), w);
            xv = x;
            xk = jStat2.add(jStat2.multiply(h, x), c);
            i = 2;
            while (Math2.abs(jStat2.norm(jStat2.subtract(xk, xv))) > r) {
              xv = xk;
              xk = jStat2.add(jStat2.multiply(h, xv), c);
              i++;
            }
            return xk;
          },
          householder: function householder(a) {
            var m = a.length;
            var n = a[0].length;
            var i = 0;
            var w = [];
            var p = [];
            var alpha, r, k, j, factor;
            for (; i < m - 1; i++) {
              alpha = 0;
              for (j = i + 1; j < n; j++)
                alpha += a[j][i] * a[j][i];
              factor = a[i + 1][i] > 0 ? -1 : 1;
              alpha = factor * Math2.sqrt(alpha);
              r = Math2.sqrt((alpha * alpha - a[i + 1][i] * alpha) / 2);
              w = jStat2.zeros(m, 1);
              w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
              for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
              p = jStat2.subtract(
                jStat2.identity(m, n),
                jStat2.multiply(jStat2.multiply(w, jStat2.transpose(w)), 2)
              );
              a = jStat2.multiply(p, jStat2.multiply(a, p));
            }
            return a;
          },
          // A -> [Q,R]
          // Q is orthogonal matrix
          // R is upper triangular
          QR: function() {
            var sum = jStat2.sum;
            var range = jStat2.arange;
            function qr2(x) {
              var n = x.length;
              var p = x[0].length;
              var r = jStat2.zeros(p, p);
              x = jStat2.copy(x);
              var i, j, k;
              for (j = 0; j < p; j++) {
                r[j][j] = Math2.sqrt(sum(range(n).map(function(i2) {
                  return x[i2][j] * x[i2][j];
                })));
                for (i = 0; i < n; i++) {
                  x[i][j] = x[i][j] / r[j][j];
                }
                for (k = j + 1; k < p; k++) {
                  r[j][k] = sum(range(n).map(function(i2) {
                    return x[i2][j] * x[i2][k];
                  }));
                  for (i = 0; i < n; i++) {
                    x[i][k] = x[i][k] - x[i][j] * r[j][k];
                  }
                }
              }
              return [x, r];
            }
            return qr2;
          }(),
          lstsq: /* @__PURE__ */ function() {
            function R_I(A) {
              A = jStat2.copy(A);
              var size = A.length;
              var I = jStat2.identity(size);
              jStat2.arange(size - 1, -1, -1).forEach(function(i) {
                jStat2.sliceAssign(
                  I,
                  { row: i },
                  jStat2.divide(jStat2.slice(I, { row: i }), A[i][i])
                );
                jStat2.sliceAssign(
                  A,
                  { row: i },
                  jStat2.divide(jStat2.slice(A, { row: i }), A[i][i])
                );
                jStat2.arange(i).forEach(function(j) {
                  var c = jStat2.multiply(A[j][i], -1);
                  var Aj = jStat2.slice(A, { row: j });
                  var cAi = jStat2.multiply(jStat2.slice(A, { row: i }), c);
                  jStat2.sliceAssign(A, { row: j }, jStat2.add(Aj, cAi));
                  var Ij = jStat2.slice(I, { row: j });
                  var cIi = jStat2.multiply(jStat2.slice(I, { row: i }), c);
                  jStat2.sliceAssign(I, { row: j }, jStat2.add(Ij, cIi));
                });
              });
              return I;
            }
            function qr_solve(A, b) {
              var array_mode = false;
              if (b[0].length === void 0) {
                b = b.map(function(x2) {
                  return [x2];
                });
                array_mode = true;
              }
              var QR = jStat2.QR(A);
              var Q = QR[0];
              var R = QR[1];
              var attrs = A[0].length;
              var Q1 = jStat2.slice(Q, { col: { end: attrs } });
              var R1 = jStat2.slice(R, { row: { end: attrs } });
              var RI = R_I(R1);
              var Q2 = jStat2.transpose(Q1);
              if (Q2[0].length === void 0) {
                Q2 = [Q2];
              }
              var x = jStat2.multiply(jStat2.multiply(RI, Q2), b);
              if (x.length === void 0) {
                x = [[x]];
              }
              if (array_mode)
                return x.map(function(i) {
                  return i[0];
                });
              return x;
            }
            return qr_solve;
          }(),
          jacobi: function jacobi(a) {
            var condition = 1;
            var n = a.length;
            var e = jStat2.identity(n, n);
            var ev = [];
            var b, i, j, p, q, maxim, theta, s;
            while (condition === 1) {
              maxim = a[0][1];
              p = 0;
              q = 1;
              for (i = 0; i < n; i++) {
                for (j = 0; j < n; j++) {
                  if (i != j) {
                    if (maxim < Math2.abs(a[i][j])) {
                      maxim = Math2.abs(a[i][j]);
                      p = i;
                      q = j;
                    }
                  }
                }
              }
              if (a[p][p] === a[q][q])
                theta = a[p][q] > 0 ? Math2.PI / 4 : -Math2.PI / 4;
              else
                theta = Math2.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
              s = jStat2.identity(n, n);
              s[p][p] = Math2.cos(theta);
              s[p][q] = -Math2.sin(theta);
              s[q][p] = Math2.sin(theta);
              s[q][q] = Math2.cos(theta);
              e = jStat2.multiply(e, s);
              b = jStat2.multiply(jStat2.multiply(jStat2.inv(s), a), s);
              a = b;
              condition = 0;
              for (i = 1; i < n; i++) {
                for (j = 1; j < n; j++) {
                  if (i != j && Math2.abs(a[i][j]) > 1e-3) {
                    condition = 1;
                  }
                }
              }
            }
            for (i = 0; i < n; i++) ev.push(a[i][i]);
            return [e, ev];
          },
          rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
            var k1, k2, u_j1, k3, k4;
            if (order === 2) {
              while (t_j <= p) {
                k1 = h * f(t_j, u_j);
                k2 = h * f(t_j + h, u_j + k1);
                u_j1 = u_j + (k1 + k2) / 2;
                u_j = u_j1;
                t_j = t_j + h;
              }
            }
            if (order === 4) {
              while (t_j <= p) {
                k1 = h * f(t_j, u_j);
                k2 = h * f(t_j + h / 2, u_j + k1 / 2);
                k3 = h * f(t_j + h / 2, u_j + k2 / 2);
                k4 = h * f(t_j + h, u_j + k3);
                u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
                u_j = u_j1;
                t_j = t_j + h;
              }
            }
            return u_j;
          },
          romberg: function romberg(f, a, b, order) {
            var i = 0;
            var h = (b - a) / 2;
            var x = [];
            var h1 = [];
            var g = [];
            var m, a1, j, k, I;
            while (i < order / 2) {
              I = f(a);
              for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
              m = x.length;
              for (j = 1; j < m - 1; j++) {
                I += (j % 2 !== 0 ? 4 : 2) * f(x[j]);
              }
              I = h / 3 * (I + f(b));
              g[i] = I;
              h /= 2;
              i++;
            }
            a1 = g.length;
            m = 1;
            while (a1 !== 1) {
              for (j = 0; j < a1 - 1; j++)
                h1[j] = (Math2.pow(4, m) * g[j + 1] - g[j]) / (Math2.pow(4, m) - 1);
              a1 = h1.length;
              g = h1;
              h1 = [];
              m++;
            }
            return g;
          },
          richardson: function richardson(X, f, x, h) {
            function pos(X2, x2) {
              var i2 = 0;
              var n = X2.length;
              var p;
              for (; i2 < n; i2++)
                if (X2[i2] === x2) p = i2;
              return p;
            }
            var h_min = Math2.abs(x - X[pos(X, x) + 1]);
            var i = 0;
            var g = [];
            var h1 = [];
            var y1, y2, m, a, j;
            while (h >= h_min) {
              y1 = pos(X, x + h);
              y2 = pos(X, x);
              g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
              h /= 2;
              i++;
            }
            a = g.length;
            m = 1;
            while (a != 1) {
              for (j = 0; j < a - 1; j++)
                h1[j] = (Math2.pow(4, m) * g[j + 1] - g[j]) / (Math2.pow(4, m) - 1);
              a = h1.length;
              g = h1;
              h1 = [];
              m++;
            }
            return g;
          },
          simpson: function simpson(f, a, b, n) {
            var h = (b - a) / n;
            var I = f(a);
            var x = [];
            var j = a;
            var k = 0;
            var i = 1;
            var m;
            for (; j <= b; j = j + h, k++)
              x[k] = j;
            m = x.length;
            for (; i < m - 1; i++) {
              I += (i % 2 !== 0 ? 4 : 2) * f(x[i]);
            }
            return h / 3 * (I + f(b));
          },
          hermite: function hermite(X, F, dF, value) {
            var n = X.length;
            var p = 0;
            var i = 0;
            var l = [];
            var dl = [];
            var A = [];
            var B = [];
            var j;
            for (; i < n; i++) {
              l[i] = 1;
              for (j = 0; j < n; j++) {
                if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
              }
              dl[i] = 0;
              for (j = 0; j < n; j++) {
                if (i != j) dl[i] += 1 / (X[i] - X[j]);
              }
              A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
              B[i] = (value - X[i]) * (l[i] * l[i]);
              p += A[i] * F[i] + B[i] * dF[i];
            }
            return p;
          },
          lagrange: function lagrange(X, F, value) {
            var p = 0;
            var i = 0;
            var j, l;
            var n = X.length;
            for (; i < n; i++) {
              l = F[i];
              for (j = 0; j < n; j++) {
                if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
              }
              p += l;
            }
            return p;
          },
          cubic_spline: function cubic_spline(X, F, value) {
            var n = X.length;
            var i = 0, j;
            var A = [];
            var B = [];
            var alpha = [];
            var c = [];
            var h = [];
            var b = [];
            var d = [];
            for (; i < n - 1; i++)
              h[i] = X[i + 1] - X[i];
            alpha[0] = 0;
            for (i = 1; i < n - 1; i++) {
              alpha[i] = 3 / h[i] * (F[i + 1] - F[i]) - 3 / h[i - 1] * (F[i] - F[i - 1]);
            }
            for (i = 1; i < n - 1; i++) {
              A[i] = [];
              B[i] = [];
              A[i][i - 1] = h[i - 1];
              A[i][i] = 2 * (h[i - 1] + h[i]);
              A[i][i + 1] = h[i];
              B[i][0] = alpha[i];
            }
            c = jStat2.multiply(jStat2.inv(A), B);
            for (j = 0; j < n - 1; j++) {
              b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
              d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
            }
            for (j = 0; j < n; j++) {
              if (X[j] > value) break;
            }
            j -= 1;
            return F[j] + (value - X[j]) * b[j] + jStat2.sq(value - X[j]) * c[j] + (value - X[j]) * jStat2.sq(value - X[j]) * d[j];
          },
          gauss_quadrature: function gauss_quadrature() {
            throw new Error("gauss_quadrature not yet implemented");
          },
          PCA: function PCA(X) {
            var m = X.length;
            var n = X[0].length;
            var i = 0;
            var j, temp1;
            var u = [];
            var D = [];
            var result = [];
            var temp2 = [];
            var Y = [];
            var Bt = [];
            var B = [];
            var C = [];
            var V = [];
            var Vt = [];
            for (i = 0; i < m; i++) {
              u[i] = jStat2.sum(X[i]) / n;
            }
            for (i = 0; i < n; i++) {
              B[i] = [];
              for (j = 0; j < m; j++) {
                B[i][j] = X[j][i] - u[j];
              }
            }
            B = jStat2.transpose(B);
            for (i = 0; i < m; i++) {
              C[i] = [];
              for (j = 0; j < m; j++) {
                C[i][j] = jStat2.dot([B[i]], [B[j]]) / (n - 1);
              }
            }
            result = jStat2.jacobi(C);
            V = result[0];
            D = result[1];
            Vt = jStat2.transpose(V);
            for (i = 0; i < D.length; i++) {
              for (j = i; j < D.length; j++) {
                if (D[i] < D[j]) {
                  temp1 = D[i];
                  D[i] = D[j];
                  D[j] = temp1;
                  temp2 = Vt[i];
                  Vt[i] = Vt[j];
                  Vt[j] = temp2;
                }
              }
            }
            Bt = jStat2.transpose(B);
            for (i = 0; i < m; i++) {
              Y[i] = [];
              for (j = 0; j < Bt.length; j++) {
                Y[i][j] = jStat2.dot([Vt[i]], [Bt[j]]);
              }
            }
            return [X, D, Vt, Y];
          }
        });
        (function(funcs) {
          for (var i = 0; i < funcs.length; i++) (function(passfunc) {
            jStat2.fn[passfunc] = function(arg, func14) {
              var tmpthis = this;
              if (func14) {
                setTimeout(function() {
                  func14.call(tmpthis, jStat2.fn[passfunc].call(tmpthis, arg));
                }, 15);
                return this;
              }
              if (typeof jStat2[passfunc](this, arg) === "number")
                return jStat2[passfunc](this, arg);
              else
                return jStat2(jStat2[passfunc](this, arg));
            };
          })(funcs[i]);
        })("add divide multiply subtract dot pow exp log abs norm angle".split(" "));
      })(jStat, Math);
      (function(jStat2, Math2) {
        var slice = [].slice;
        var isNumber = jStat2.utils.isNumber;
        var isArray = jStat2.utils.isArray;
        jStat2.extend({
          // 2 different parameter lists:
          // (value, mean, sd)
          // (value, array, flag)
          zscore: function zscore() {
            var args = slice.call(arguments);
            if (isNumber(args[1])) {
              return (args[0] - args[1]) / args[2];
            }
            return (args[0] - jStat2.mean(args[1])) / jStat2.stdev(args[1], args[2]);
          },
          // 3 different paramter lists:
          // (value, mean, sd, sides)
          // (zscore, sides)
          // (value, array, sides, flag)
          ztest: function ztest() {
            var args = slice.call(arguments);
            var z;
            if (isArray(args[1])) {
              z = jStat2.zscore(args[0], args[1], args[3]);
              return args[2] === 1 ? jStat2.normal.cdf(-Math2.abs(z), 0, 1) : jStat2.normal.cdf(-Math2.abs(z), 0, 1) * 2;
            } else {
              if (args.length > 2) {
                z = jStat2.zscore(args[0], args[1], args[2]);
                return args[3] === 1 ? jStat2.normal.cdf(-Math2.abs(z), 0, 1) : jStat2.normal.cdf(-Math2.abs(z), 0, 1) * 2;
              } else {
                z = args[0];
                return args[1] === 1 ? jStat2.normal.cdf(-Math2.abs(z), 0, 1) : jStat2.normal.cdf(-Math2.abs(z), 0, 1) * 2;
              }
            }
          }
        });
        jStat2.extend(jStat2.fn, {
          zscore: function zscore(value, flag) {
            return (value - this.mean()) / this.stdev(flag);
          },
          ztest: function ztest(value, sides, flag) {
            var zscore = Math2.abs(this.zscore(value, flag));
            return sides === 1 ? jStat2.normal.cdf(-zscore, 0, 1) : jStat2.normal.cdf(-zscore, 0, 1) * 2;
          }
        });
        jStat2.extend({
          // 2 parameter lists
          // (value, mean, sd, n)
          // (value, array)
          tscore: function tscore() {
            var args = slice.call(arguments);
            return args.length === 4 ? (args[0] - args[1]) / (args[2] / Math2.sqrt(args[3])) : (args[0] - jStat2.mean(args[1])) / (jStat2.stdev(args[1], true) / Math2.sqrt(args[1].length));
          },
          // 3 different paramter lists:
          // (value, mean, sd, n, sides)
          // (tscore, n, sides)
          // (value, array, sides)
          ttest: function ttest() {
            var args = slice.call(arguments);
            var tscore;
            if (args.length === 5) {
              tscore = Math2.abs(jStat2.tscore(args[0], args[1], args[2], args[3]));
              return args[4] === 1 ? jStat2.studentt.cdf(-tscore, args[3] - 1) : jStat2.studentt.cdf(-tscore, args[3] - 1) * 2;
            }
            if (isNumber(args[1])) {
              tscore = Math2.abs(args[0]);
              return args[2] == 1 ? jStat2.studentt.cdf(-tscore, args[1] - 1) : jStat2.studentt.cdf(-tscore, args[1] - 1) * 2;
            }
            tscore = Math2.abs(jStat2.tscore(args[0], args[1]));
            return args[2] == 1 ? jStat2.studentt.cdf(-tscore, args[1].length - 1) : jStat2.studentt.cdf(-tscore, args[1].length - 1) * 2;
          }
        });
        jStat2.extend(jStat2.fn, {
          tscore: function tscore(value) {
            return (value - this.mean()) / (this.stdev(true) / Math2.sqrt(this.cols()));
          },
          ttest: function ttest(value, sides) {
            return sides === 1 ? 1 - jStat2.studentt.cdf(Math2.abs(this.tscore(value)), this.cols() - 1) : jStat2.studentt.cdf(-Math2.abs(this.tscore(value)), this.cols() - 1) * 2;
          }
        });
        jStat2.extend({
          // Paramter list is as follows:
          // (array1, array2, array3, ...)
          // or it is an array of arrays
          // array of arrays conversion
          anovafscore: function anovafscore() {
            var args = slice.call(arguments), expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
            if (args.length === 1) {
              tmpargs = new Array(args[0].length);
              for (i = 0; i < args[0].length; i++) {
                tmpargs[i] = args[0][i];
              }
              args = tmpargs;
            }
            sample = new Array();
            for (i = 0; i < args.length; i++) {
              sample = sample.concat(args[i]);
            }
            sampMean = jStat2.mean(sample);
            expVar = 0;
            for (i = 0; i < args.length; i++) {
              expVar = expVar + args[i].length * Math2.pow(jStat2.mean(args[i]) - sampMean, 2);
            }
            expVar /= args.length - 1;
            unexpVar = 0;
            for (i = 0; i < args.length; i++) {
              sampSampMean = jStat2.mean(args[i]);
              for (j = 0; j < args[i].length; j++) {
                unexpVar += Math2.pow(args[i][j] - sampSampMean, 2);
              }
            }
            unexpVar /= sample.length - args.length;
            return expVar / unexpVar;
          },
          // 2 different paramter setups
          // (array1, array2, array3, ...)
          // (anovafscore, df1, df2)
          anovaftest: function anovaftest() {
            var args = slice.call(arguments), df1, df2, n, i;
            if (isNumber(args[0])) {
              return 1 - jStat2.centralF.cdf(args[0], args[1], args[2]);
            }
            var anovafscore = jStat2.anovafscore(args);
            df1 = args.length - 1;
            n = 0;
            for (i = 0; i < args.length; i++) {
              n = n + args[i].length;
            }
            df2 = n - df1 - 1;
            return 1 - jStat2.centralF.cdf(anovafscore, df1, df2);
          },
          ftest: function ftest(fscore, df1, df2) {
            return 1 - jStat2.centralF.cdf(fscore, df1, df2);
          }
        });
        jStat2.extend(jStat2.fn, {
          anovafscore: function anovafscore() {
            return jStat2.anovafscore(this.toArray());
          },
          anovaftes: function anovaftes() {
            var n = 0;
            var i;
            for (i = 0; i < this.length; i++) {
              n = n + this[i].length;
            }
            return jStat2.ftest(this.anovafscore(), this.length - 1, n - this.length);
          }
        });
        jStat2.extend({
          // 2 parameter lists
          // (mean1, mean2, n1, n2, sd)
          // (array1, array2, sd)
          qscore: function qscore() {
            var args = slice.call(arguments);
            var mean1, mean2, n1, n2, sd;
            if (isNumber(args[0])) {
              mean1 = args[0];
              mean2 = args[1];
              n1 = args[2];
              n2 = args[3];
              sd = args[4];
            } else {
              mean1 = jStat2.mean(args[0]);
              mean2 = jStat2.mean(args[1]);
              n1 = args[0].length;
              n2 = args[1].length;
              sd = args[2];
            }
            return Math2.abs(mean1 - mean2) / (sd * Math2.sqrt((1 / n1 + 1 / n2) / 2));
          },
          // 3 different parameter lists:
          // (qscore, n, k)
          // (mean1, mean2, n1, n2, sd, n, k)
          // (array1, array2, sd, n, k)
          qtest: function qtest() {
            var args = slice.call(arguments);
            var qscore;
            if (args.length === 3) {
              qscore = args[0];
              args = args.slice(1);
            } else if (args.length === 7) {
              qscore = jStat2.qscore(args[0], args[1], args[2], args[3], args[4]);
              args = args.slice(5);
            } else {
              qscore = jStat2.qscore(args[0], args[1], args[2]);
              args = args.slice(3);
            }
            var n = args[0];
            var k = args[1];
            return 1 - jStat2.tukey.cdf(qscore, k, n - k);
          },
          tukeyhsd: function tukeyhsd(arrays) {
            var sd = jStat2.pooledstdev(arrays);
            var means = arrays.map(function(arr) {
              return jStat2.mean(arr);
            });
            var n = arrays.reduce(function(n2, arr) {
              return n2 + arr.length;
            }, 0);
            var results = [];
            for (var i = 0; i < arrays.length; ++i) {
              for (var j = i + 1; j < arrays.length; ++j) {
                var p = jStat2.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);
                results.push([[i, j], p]);
              }
            }
            return results;
          }
        });
        jStat2.extend({
          // 2 different parameter setups
          // (value, alpha, sd, n)
          // (value, alpha, array)
          normalci: function normalci() {
            var args = slice.call(arguments), ans = new Array(2), change;
            if (args.length === 4) {
              change = Math2.abs(jStat2.normal.inv(args[1] / 2, 0, 1) * args[2] / Math2.sqrt(args[3]));
            } else {
              change = Math2.abs(jStat2.normal.inv(args[1] / 2, 0, 1) * jStat2.stdev(args[2]) / Math2.sqrt(args[2].length));
            }
            ans[0] = args[0] - change;
            ans[1] = args[0] + change;
            return ans;
          },
          // 2 different parameter setups
          // (value, alpha, sd, n)
          // (value, alpha, array)
          tci: function tci() {
            var args = slice.call(arguments), ans = new Array(2), change;
            if (args.length === 4) {
              change = Math2.abs(jStat2.studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math2.sqrt(args[3]));
            } else {
              change = Math2.abs(jStat2.studentt.inv(args[1] / 2, args[2].length - 1) * jStat2.stdev(args[2], true) / Math2.sqrt(args[2].length));
            }
            ans[0] = args[0] - change;
            ans[1] = args[0] + change;
            return ans;
          },
          significant: function significant(pvalue, alpha) {
            return pvalue < alpha;
          }
        });
        jStat2.extend(jStat2.fn, {
          normalci: function normalci(value, alpha) {
            return jStat2.normalci(value, alpha, this.toArray());
          },
          tci: function tci(value, alpha) {
            return jStat2.tci(value, alpha, this.toArray());
          }
        });
        function differenceOfProportions(p1, n1, p2, n2) {
          if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
            throw new Error("Proportions should be greater than 0 and less than 1");
          }
          var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
          var se = Math2.sqrt(pooled * (1 - pooled) * (1 / n1 + 1 / n2));
          return (p1 - p2) / se;
        }
        jStat2.extend(jStat2.fn, {
          oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
            var z = differenceOfProportions(p1, n1, p2, n2);
            return jStat2.ztest(z, 1);
          },
          twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
            var z = differenceOfProportions(p1, n1, p2, n2);
            return jStat2.ztest(z, 2);
          }
        });
      })(jStat, Math);
      jStat.models = /* @__PURE__ */ function() {
        function sub_regress(exog) {
          var var_count = exog[0].length;
          var modelList = jStat.arange(var_count).map(function(endog_index) {
            var exog_index = jStat.arange(var_count).filter(function(i) {
              return i !== endog_index;
            });
            return ols(
              jStat.col(exog, endog_index).map(function(x) {
                return x[0];
              }),
              jStat.col(exog, exog_index)
            );
          });
          return modelList;
        }
        function ols(endog, exog) {
          var nobs = endog.length;
          var df_model = exog[0].length - 1;
          var df_resid = nobs - df_model - 1;
          var coef = jStat.lstsq(exog, endog);
          var predict = jStat.multiply(exog, coef.map(function(x) {
            return [x];
          })).map(function(p) {
            return p[0];
          });
          var resid = jStat.subtract(endog, predict);
          var ybar = jStat.mean(endog);
          var SSE = jStat.sum(predict.map(function(f) {
            return Math.pow(f - ybar, 2);
          }));
          var SSR = jStat.sum(endog.map(function(y, i) {
            return Math.pow(y - predict[i], 2);
          }));
          var SST = SSE + SSR;
          var R2 = SSE / SST;
          return {
            exog,
            endog,
            nobs,
            df_model,
            df_resid,
            coef,
            predict,
            resid,
            ybar,
            SST,
            SSE,
            SSR,
            R2
          };
        }
        function t_test(model) {
          var subModelList = sub_regress(model.exog);
          var sigmaHat = Math.sqrt(model.SSR / model.df_resid);
          var seBetaHat = subModelList.map(function(mod) {
            var SST = mod.SST;
            var R2 = mod.R2;
            return sigmaHat / Math.sqrt(SST * (1 - R2));
          });
          var tStatistic = model.coef.map(function(coef, i) {
            return (coef - 0) / seBetaHat[i];
          });
          var pValue = tStatistic.map(function(t) {
            var leftppf = jStat.studentt.cdf(t, model.df_resid);
            return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;
          });
          var c = jStat.studentt.inv(0.975, model.df_resid);
          var interval95 = model.coef.map(function(coef, i) {
            var d = c * seBetaHat[i];
            return [coef - d, coef + d];
          });
          return {
            se: seBetaHat,
            t: tStatistic,
            p: pValue,
            sigmaHat,
            interval95
          };
        }
        function F_test(model) {
          var F_statistic = model.R2 / model.df_model / ((1 - model.R2) / model.df_resid);
          var fcdf = function(x, n1, n2) {
            return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2);
          };
          var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);
          return { F_statistic, pvalue };
        }
        function ols_wrap(endog, exog) {
          var model = ols(endog, exog);
          var ttest = t_test(model);
          var ftest = F_test(model);
          var adjust_R2 = 1 - (1 - model.R2) * ((model.nobs - 1) / model.df_resid);
          model.t = ttest;
          model.f = ftest;
          model.adjust_R2 = adjust_R2;
          return model;
        }
        return { ols: ols_wrap };
      }();
      jStat.extend({
        buildxmatrix: function buildxmatrix() {
          var matrixRows = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            var array = [1];
            matrixRows[i] = array.concat(arguments[i]);
          }
          return jStat(matrixRows);
        },
        builddxmatrix: function builddxmatrix() {
          var matrixRows = new Array(arguments[0].length);
          for (var i = 0; i < arguments[0].length; i++) {
            var array = [1];
            matrixRows[i] = array.concat(arguments[0][i]);
          }
          return jStat(matrixRows);
        },
        buildjxmatrix: function buildjxmatrix(jMat) {
          var pass = new Array(jMat.length);
          for (var i = 0; i < jMat.length; i++) {
            pass[i] = jMat[i];
          }
          return jStat.builddxmatrix(pass);
        },
        buildymatrix: function buildymatrix(array) {
          return jStat(array).transpose();
        },
        buildjymatrix: function buildjymatrix(jMat) {
          return jMat.transpose();
        },
        matrixmult: function matrixmult(A, B) {
          var i, j, k, result, sum;
          if (A.cols() == B.rows()) {
            if (B.rows() > 1) {
              result = [];
              for (i = 0; i < A.rows(); i++) {
                result[i] = [];
                for (j = 0; j < B.cols(); j++) {
                  sum = 0;
                  for (k = 0; k < A.cols(); k++) {
                    sum += A.toArray()[i][k] * B.toArray()[k][j];
                  }
                  result[i][j] = sum;
                }
              }
              return jStat(result);
            }
            result = [];
            for (i = 0; i < A.rows(); i++) {
              result[i] = [];
              for (j = 0; j < B.cols(); j++) {
                sum = 0;
                for (k = 0; k < A.cols(); k++) {
                  sum += A.toArray()[i][k] * B.toArray()[j];
                }
                result[i][j] = sum;
              }
            }
            return jStat(result);
          }
        },
        //regress and regresst to be fixed
        regress: function regress(jMatX, jMatY) {
          var innerinv = jStat.xtranspxinv(jMatX);
          var xtransp = jMatX.transpose();
          var next = jStat.matrixmult(jStat(innerinv), xtransp);
          return jStat.matrixmult(next, jMatY);
        },
        regresst: function regresst(jMatX, jMatY, sides) {
          var beta = jStat.regress(jMatX, jMatY);
          var compile = {};
          compile.anova = {};
          var jMatYBar = jStat.jMatYBar(jMatX, beta);
          compile.yBar = jMatYBar;
          var yAverage = jMatY.mean();
          compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);
          compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);
          compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);
          compile.anova.sse = jStat.sse(jMatY, jMatYBar);
          compile.anova.mse = compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);
          compile.anova.sst = jStat.sst(jMatY, yAverage);
          compile.anova.mst = compile.anova.sst / (jMatY.length - 1);
          compile.anova.r2 = 1 - compile.anova.sse / compile.anova.sst;
          if (compile.anova.r2 < 0) compile.anova.r2 = 0;
          compile.anova.fratio = compile.anova.msr / compile.anova.mse;
          compile.anova.pvalue = jStat.anovaftest(
            compile.anova.fratio,
            jMatX[0].length - 1,
            jMatY.length - (jMatX[0].length - 1) - 1
          );
          compile.anova.rmse = Math.sqrt(compile.anova.mse);
          compile.anova.r2adj = 1 - compile.anova.mse / compile.anova.mst;
          if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;
          compile.stats = new Array(jMatX[0].length);
          var covar = jStat.xtranspxinv(jMatX);
          var sds, ts, ps;
          for (var i = 0; i < beta.length; i++) {
            sds = Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));
            ts = Math.abs(beta[i] / sds);
            ps = jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);
            compile.stats[i] = [beta[i], sds, ts, ps];
          }
          compile.regress = beta;
          return compile;
        },
        xtranspx: function xtranspx(jMatX) {
          return jStat.matrixmult(jMatX.transpose(), jMatX);
        },
        xtranspxinv: function xtranspxinv(jMatX) {
          var inner = jStat.matrixmult(jMatX.transpose(), jMatX);
          var innerinv = jStat.inv(inner);
          return innerinv;
        },
        jMatYBar: function jMatYBar(jMatX, beta) {
          var yBar = jStat.matrixmult(jMatX, beta);
          return new jStat(yBar);
        },
        residuals: function residuals(jMatY, jMatYBar) {
          return jStat.matrixsubtract(jMatY, jMatYBar);
        },
        ssr: function ssr(jMatYBar, yAverage) {
          var ssr2 = 0;
          for (var i = 0; i < jMatYBar.length; i++) {
            ssr2 += Math.pow(jMatYBar[i] - yAverage, 2);
          }
          return ssr2;
        },
        sse: function sse(jMatY, jMatYBar) {
          var sse2 = 0;
          for (var i = 0; i < jMatY.length; i++) {
            sse2 += Math.pow(jMatY[i] - jMatYBar[i], 2);
          }
          return sse2;
        },
        sst: function sst(jMatY, yAverage) {
          var sst2 = 0;
          for (var i = 0; i < jMatY.length; i++) {
            sst2 += Math.pow(jMatY[i] - yAverage, 2);
          }
          return sst2;
        },
        matrixsubtract: function matrixsubtract(A, B) {
          var ans = new Array(A.length);
          for (var i = 0; i < A.length; i++) {
            ans[i] = new Array(A[i].length);
            for (var j = 0; j < A[i].length; j++) {
              ans[i][j] = A[i][j] - B[i][j];
            }
          }
          return jStat(ans);
        }
      });
      jStat.jStat = jStat;
      return jStat;
    });
  }
});

// ../../node_modules/@handsontable/formulajs/lib/utils/criteria-eval.js
var require_criteria_eval = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/utils/criteria-eval.js"(exports) {
    var defaultOperator = "=";
    var validSymbols = [">", ">=", "<", "<=", "=", "<>"];
    var TOKEN_TYPE_OPERATOR = "operator";
    var TOKEN_TYPE_LITERAL = "literal";
    var SUPPORTED_TOKENS = [TOKEN_TYPE_OPERATOR, TOKEN_TYPE_LITERAL];
    exports.TOKEN_TYPE_OPERATOR = TOKEN_TYPE_OPERATOR;
    exports.TOKEN_TYPE_LITERAL = TOKEN_TYPE_LITERAL;
    function createToken(value, type) {
      if (SUPPORTED_TOKENS.indexOf(type) === -1) {
        throw new Error("Unsupported token type: " + type);
      }
      return {
        value,
        type
      };
    }
    function castValueToCorrectType(value) {
      if (typeof value !== "string") {
        return value;
      }
      if (/^\d+(\.\d+)?$/.test(value)) {
        value = value.indexOf(".") === -1 ? parseInt(value, 10) : parseFloat(value);
      }
      return value;
    }
    function tokenizeExpression(expression) {
      var expressionLength = expression.length;
      var tokens = [];
      var cursorIndex = 0;
      var processedValue = "";
      var processedSymbol = "";
      while (cursorIndex < expressionLength) {
        var char = expression.charAt(cursorIndex);
        switch (char) {
          case ">":
          case "<":
          case "=":
            processedSymbol = processedSymbol + char;
            if (processedValue.length > 0) {
              tokens.push(processedValue);
              processedValue = "";
            }
            break;
          default:
            if (processedSymbol.length > 0) {
              tokens.push(processedSymbol);
              processedSymbol = "";
            }
            processedValue = processedValue + char;
            break;
        }
        cursorIndex++;
      }
      if (processedValue.length > 0) {
        tokens.push(processedValue);
      }
      if (processedSymbol.length > 0) {
        tokens.push(processedSymbol);
      }
      return tokens;
    }
    function analyzeTokens(tokens) {
      var literalValue = "";
      var analyzedTokens = [];
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (i === 0 && validSymbols.indexOf(token) >= 0) {
          analyzedTokens.push(createToken(token, TOKEN_TYPE_OPERATOR));
        } else {
          literalValue += token;
        }
      }
      if (literalValue.length > 0) {
        analyzedTokens.push(createToken(castValueToCorrectType(literalValue), TOKEN_TYPE_LITERAL));
      }
      if (analyzedTokens.length > 0 && analyzedTokens[0].type !== TOKEN_TYPE_OPERATOR) {
        analyzedTokens.unshift(createToken(defaultOperator, TOKEN_TYPE_OPERATOR));
      }
      return analyzedTokens;
    }
    function computeExpression(tokens) {
      var values = [];
      var operator;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        switch (token.type) {
          case TOKEN_TYPE_OPERATOR:
            operator = token.value;
            break;
          case TOKEN_TYPE_LITERAL:
            values.push(token.value);
            break;
        }
      }
      return evaluate(values, operator);
    }
    function evaluate(values, operator) {
      var result = false;
      switch (operator) {
        case ">":
          result = values[0] > values[1];
          break;
        case ">=":
          result = values[0] >= values[1];
          break;
        case "<":
          result = values[0] < values[1];
          break;
        case "<=":
          result = values[0] <= values[1];
          break;
        case "=":
          result = values[0] == values[1];
          break;
        case "<>":
          result = values[0] != values[1];
          break;
      }
      return result;
    }
    exports.parse = function(expression) {
      return analyzeTokens(tokenizeExpression(expression));
    };
    exports.createToken = createToken;
    exports.compute = computeExpression;
  }
});

// ../../node_modules/@handsontable/formulajs/lib/miscellaneous.js
var require_miscellaneous = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/miscellaneous.js"(exports) {
    var utils = require_common();
    var error2 = require_error();
    exports.UNIQUE = function() {
      var result = [];
      for (var i = 0; i < arguments.length; ++i) {
        var hasElement = false;
        var element = arguments[i];
        for (var j = 0; j < result.length; ++j) {
          hasElement = result[j] === element;
          if (hasElement) {
            break;
          }
        }
        if (!hasElement) {
          result.push(element);
        }
      }
      return result;
    };
    exports.FLATTEN = utils.flatten;
    exports.ARGS2ARRAY = function() {
      return Array.prototype.slice.call(arguments, 0);
    };
    exports.REFERENCE = function(context, reference) {
      if (!arguments.length) {
        return error2.error;
      }
      try {
        var path = reference.split(".");
        var result = context;
        for (var i = 0; i < path.length; ++i) {
          var step = path[i];
          if (step[step.length - 1] === "]") {
            var opening = step.indexOf("[");
            var index = step.substring(opening + 1, step.length - 1);
            result = result[step.substring(0, opening)][index];
          } else {
            result = result[step];
          }
        }
        return result;
      } catch (error3) {
      }
    };
    exports.JOIN = function(array, separator) {
      return array.join(separator);
    };
    exports.NUMBERS = function() {
      var possibleNumbers = utils.flatten(arguments);
      return possibleNumbers.filter(function(el) {
        return typeof el === "number";
      });
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/statistical.js
var require_statistical = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/statistical.js"(exports) {
    var mathTrig = require_math_trig();
    var text = require_text();
    var jStat = require_jstat();
    var utils = require_common();
    var evalExpression = require_criteria_eval();
    var error2 = require_error();
    var misc = require_miscellaneous();
    var SQRT2PI = 2.5066282746310002;
    exports.AVEDEV = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      return jStat.sum(jStat(range).subtract(jStat.mean(range)).abs()[0]) / range.length;
    };
    exports.AVERAGE = function() {
      var range = utils.numbers(utils.flatten(arguments));
      var n = range.length;
      var sum = 0;
      var count = 0;
      var result;
      for (var i = 0; i < n; i++) {
        sum += range[i];
        count += 1;
      }
      result = sum / count;
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.AVERAGEA = function() {
      var range = utils.flatten(arguments);
      var n = range.length;
      var sum = 0;
      var count = 0;
      var result;
      for (var i = 0; i < n; i++) {
        var el = range[i];
        if (typeof el === "number") {
          sum += el;
        }
        if (el === true) {
          sum++;
        }
        if (el !== null) {
          count++;
        }
      }
      result = sum / count;
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.AVERAGEIF = function(range, criteria, average_range) {
      if (arguments.length <= 1) {
        return error2.na;
      }
      average_range = average_range || range;
      range = utils.flatten(range);
      average_range = utils.parseNumberArray(utils.flatten(average_range));
      if (average_range instanceof Error) {
        return average_range;
      }
      var average_count = 0;
      var result = 0;
      var isWildcard = criteria === void 0 || criteria === "*";
      var tokenizedCriteria = isWildcard ? null : evalExpression.parse(criteria + "");
      for (var i = 0; i < range.length; i++) {
        var value = range[i];
        if (isWildcard) {
          result += average_range[i];
          average_count++;
        } else {
          var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
          if (evalExpression.compute(tokens)) {
            result += average_range[i];
            average_count++;
          }
        }
      }
      return result / average_count;
    };
    exports.AVERAGEIFS = function() {
      var args = utils.argsToArray(arguments);
      var criteriaLength = (args.length - 1) / 2;
      var range = utils.flatten(args[0]);
      var count = 0;
      var result = 0;
      for (var i = 0; i < range.length; i++) {
        var isMeetCondition = false;
        for (var j = 0; j < criteriaLength; j++) {
          var value = args[2 * j + 1][i];
          var criteria = args[2 * j + 2];
          var isWildcard = criteria === void 0 || criteria === "*";
          var computedResult = false;
          if (isWildcard) {
            computedResult = true;
          } else {
            var tokenizedCriteria = evalExpression.parse(criteria + "");
            var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
            computedResult = evalExpression.compute(tokens);
          }
          if (!computedResult) {
            isMeetCondition = false;
            break;
          }
          isMeetCondition = true;
        }
        if (isMeetCondition) {
          result += range[i];
          count++;
        }
      }
      var average = result / count;
      if (isNaN(average)) {
        return 0;
      } else {
        return average;
      }
    };
    exports.BETA = {};
    exports.BETA.DIST = function(x, alpha, beta, cumulative, A, B) {
      if (arguments.length < 4) {
        return error2.value;
      }
      A = A === void 0 ? 0 : A;
      B = B === void 0 ? 1 : B;
      x = utils.parseNumber(x);
      alpha = utils.parseNumber(alpha);
      beta = utils.parseNumber(beta);
      A = utils.parseNumber(A);
      B = utils.parseNumber(B);
      if (utils.anyIsError(x, alpha, beta, A, B)) {
        return error2.value;
      }
      x = (x - A) / (B - A);
      return cumulative ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta);
    };
    exports.BETA.INV = function(probability, alpha, beta, A, B) {
      A = A === void 0 ? 0 : A;
      B = B === void 0 ? 1 : B;
      probability = utils.parseNumber(probability);
      alpha = utils.parseNumber(alpha);
      beta = utils.parseNumber(beta);
      A = utils.parseNumber(A);
      B = utils.parseNumber(B);
      if (utils.anyIsError(probability, alpha, beta, A, B)) {
        return error2.value;
      }
      return jStat.beta.inv(probability, alpha, beta) * (B - A) + A;
    };
    exports.BINOM = {};
    exports.BINOM.DIST = function(successes, trials, probability, cumulative) {
      successes = utils.parseNumber(successes);
      trials = utils.parseNumber(trials);
      probability = utils.parseNumber(probability);
      cumulative = utils.parseNumber(cumulative);
      if (utils.anyIsError(successes, trials, probability, cumulative)) {
        return error2.value;
      }
      return cumulative ? jStat.binomial.cdf(successes, trials, probability) : jStat.binomial.pdf(successes, trials, probability);
    };
    exports.BINOM.DIST.RANGE = function(trials, probability, successes, successes2) {
      successes2 = successes2 === void 0 ? successes : successes2;
      trials = utils.parseNumber(trials);
      probability = utils.parseNumber(probability);
      successes = utils.parseNumber(successes);
      successes2 = utils.parseNumber(successes2);
      if (utils.anyIsError(trials, probability, successes, successes2)) {
        return error2.value;
      }
      var result = 0;
      for (var i = successes; i <= successes2; i++) {
        result += mathTrig.COMBIN(trials, i) * Math.pow(probability, i) * Math.pow(1 - probability, trials - i);
      }
      return result;
    };
    exports.BINOM.INV = function(trials, probability, alpha) {
      trials = utils.parseNumber(trials);
      probability = utils.parseNumber(probability);
      alpha = utils.parseNumber(alpha);
      if (utils.anyIsError(trials, probability, alpha)) {
        return error2.value;
      }
      var x = 0;
      while (x <= trials) {
        if (jStat.binomial.cdf(x, trials, probability) >= alpha) {
          return x;
        }
        x++;
      }
    };
    exports.CHISQ = {};
    exports.CHISQ.DIST = function(x, k, cumulative) {
      x = utils.parseNumber(x);
      k = utils.parseNumber(k);
      if (utils.anyIsError(x, k)) {
        return error2.value;
      }
      return cumulative ? jStat.chisquare.cdf(x, k) : jStat.chisquare.pdf(x, k);
    };
    exports.CHISQ.DIST.RT = function(x, k) {
      if (!x | !k) {
        return error2.na;
      }
      if (x < 1 || k > Math.pow(10, 10)) {
        return error2.num;
      }
      if (typeof x !== "number" || typeof k !== "number") {
        return error2.value;
      }
      return 1 - jStat.chisquare.cdf(x, k);
    };
    exports.CHISQ.INV = function(probability, k) {
      probability = utils.parseNumber(probability);
      k = utils.parseNumber(k);
      if (utils.anyIsError(probability, k)) {
        return error2.value;
      }
      return jStat.chisquare.inv(probability, k);
    };
    exports.CHISQ.INV.RT = function(p, k) {
      if (!p | !k) {
        return error2.na;
      }
      if (p < 0 || p > 1 || k < 1 || k > Math.pow(10, 10)) {
        return error2.num;
      }
      if (typeof p !== "number" || typeof k !== "number") {
        return error2.value;
      }
      return jStat.chisquare.inv(1 - p, k);
    };
    exports.CHISQ.TEST = function(observed, expected) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      if (!(observed instanceof Array) || !(expected instanceof Array)) {
        return error2.value;
      }
      if (observed.length !== expected.length) {
        return error2.value;
      }
      if (observed[0] && expected[0] && observed[0].length !== expected[0].length) {
        return error2.value;
      }
      var row = observed.length;
      var tmp, i, j;
      for (i = 0; i < row; i++) {
        if (!(observed[i] instanceof Array)) {
          tmp = observed[i];
          observed[i] = [];
          observed[i].push(tmp);
        }
        if (!(expected[i] instanceof Array)) {
          tmp = expected[i];
          expected[i] = [];
          expected[i].push(tmp);
        }
      }
      var col = observed[0].length;
      var dof = col === 1 ? row - 1 : (row - 1) * (col - 1);
      var xsqr = 0;
      var Pi = Math.PI;
      for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
          xsqr += Math.pow(observed[i][j] - expected[i][j], 2) / expected[i][j];
        }
      }
      function ChiSq(xsqr2, dof2) {
        var p = Math.exp(-0.5 * xsqr2);
        if (dof2 % 2 === 1) {
          p = p * Math.sqrt(2 * xsqr2 / Pi);
        }
        var k = dof2;
        while (k >= 2) {
          p = p * xsqr2 / k;
          k = k - 2;
        }
        var t = p;
        var a = dof2;
        while (t > 1e-10 * p) {
          a = a + 2;
          t = t * xsqr2 / a;
          p = p + t;
        }
        return 1 - p;
      }
      return Math.round(ChiSq(xsqr, dof) * 1e6) / 1e6;
    };
    exports.COLUMN = function(matrix, index) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      if (index < 0) {
        return error2.num;
      }
      if (!(matrix instanceof Array) || typeof index !== "number") {
        return error2.value;
      }
      if (matrix.length === 0) {
        return void 0;
      }
      return jStat.col(matrix, index);
    };
    exports.COLUMNS = function(matrix) {
      if (arguments.length !== 1) {
        return error2.na;
      }
      if (!(matrix instanceof Array)) {
        return error2.value;
      }
      if (matrix.length === 0) {
        return 0;
      }
      return jStat.cols(matrix);
    };
    exports.CONFIDENCE = {};
    exports.CONFIDENCE.NORM = function(alpha, sd, n) {
      alpha = utils.parseNumber(alpha);
      sd = utils.parseNumber(sd);
      n = utils.parseNumber(n);
      if (utils.anyIsError(alpha, sd, n)) {
        return error2.value;
      }
      return jStat.normalci(1, alpha, sd, n)[1] - 1;
    };
    exports.CONFIDENCE.T = function(alpha, sd, n) {
      alpha = utils.parseNumber(alpha);
      sd = utils.parseNumber(sd);
      n = utils.parseNumber(n);
      if (utils.anyIsError(alpha, sd, n)) {
        return error2.value;
      }
      return jStat.tci(1, alpha, sd, n)[1] - 1;
    };
    exports.CORREL = function(array1, array2) {
      array1 = utils.parseNumberArray(utils.flatten(array1));
      array2 = utils.parseNumberArray(utils.flatten(array2));
      if (utils.anyIsError(array1, array2)) {
        return error2.value;
      }
      return jStat.corrcoeff(array1, array2);
    };
    exports.COUNT = function() {
      return utils.numbers(utils.flatten(arguments)).length;
    };
    exports.COUNTA = function() {
      var range = utils.flatten(arguments);
      return range.length - exports.COUNTBLANK(range);
    };
    exports.COUNTIN = function(range, value) {
      var result = 0;
      range = utils.flatten(range);
      for (var i = 0; i < range.length; i++) {
        if (range[i] === value) {
          result++;
        }
      }
      return result;
    };
    exports.COUNTBLANK = function() {
      var range = utils.flatten(arguments);
      var blanks = 0;
      var element;
      for (var i = 0; i < range.length; i++) {
        element = range[i];
        if (element === null || element === "") {
          blanks++;
        }
      }
      return blanks;
    };
    exports.COUNTIF = function(range, criteria) {
      range = utils.flatten(range);
      var isWildcard = criteria === void 0 || criteria === "*";
      if (isWildcard) {
        return range.length;
      }
      var matches = 0;
      var tokenizedCriteria = evalExpression.parse(criteria + "");
      for (var i = 0; i < range.length; i++) {
        var value = range[i];
        var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
        if (evalExpression.compute(tokens)) {
          matches++;
        }
      }
      return matches;
    };
    exports.COUNTIFS = function() {
      var args = utils.argsToArray(arguments);
      var results = new Array(utils.flatten(args[0]).length);
      for (var i = 0; i < results.length; i++) {
        results[i] = true;
      }
      for (i = 0; i < args.length; i += 2) {
        var range = utils.flatten(args[i]);
        var criteria = args[i + 1];
        var isWildcard = criteria === void 0 || criteria === "*";
        if (!isWildcard) {
          var tokenizedCriteria = evalExpression.parse(criteria + "");
          for (var j = 0; j < range.length; j++) {
            var value = range[j];
            var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
            results[j] = results[j] && evalExpression.compute(tokens);
          }
        }
      }
      var result = 0;
      for (i = 0; i < results.length; i++) {
        if (results[i]) {
          result++;
        }
      }
      return result;
    };
    exports.COUNTUNIQUE = function() {
      return misc.UNIQUE.apply(null, utils.flatten(arguments)).length;
    };
    exports.COVARIANCE = {};
    exports.COVARIANCE.P = function(array1, array2) {
      array1 = utils.parseNumberArray(utils.flatten(array1));
      array2 = utils.parseNumberArray(utils.flatten(array2));
      if (utils.anyIsError(array1, array2)) {
        return error2.value;
      }
      var mean1 = jStat.mean(array1);
      var mean2 = jStat.mean(array2);
      var result = 0;
      var n = array1.length;
      for (var i = 0; i < n; i++) {
        result += (array1[i] - mean1) * (array2[i] - mean2);
      }
      return result / n;
    };
    exports.COVARIANCE.S = function(array1, array2) {
      array1 = utils.parseNumberArray(utils.flatten(array1));
      array2 = utils.parseNumberArray(utils.flatten(array2));
      if (utils.anyIsError(array1, array2)) {
        return error2.value;
      }
      return jStat.covariance(array1, array2);
    };
    exports.DEVSQ = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      var mean = jStat.mean(range);
      var result = 0;
      for (var i = 0; i < range.length; i++) {
        result += Math.pow(range[i] - mean, 2);
      }
      return result;
    };
    exports.EXPON = {};
    exports.EXPON.DIST = function(x, lambda, cumulative) {
      x = utils.parseNumber(x);
      lambda = utils.parseNumber(lambda);
      if (utils.anyIsError(x, lambda)) {
        return error2.value;
      }
      return cumulative ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);
    };
    exports.F = {};
    exports.F.DIST = function(x, d1, d2, cumulative) {
      x = utils.parseNumber(x);
      d1 = utils.parseNumber(d1);
      d2 = utils.parseNumber(d2);
      if (utils.anyIsError(x, d1, d2)) {
        return error2.value;
      }
      return cumulative ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);
    };
    exports.F.DIST.RT = function(x, d1, d2) {
      if (arguments.length !== 3) {
        return error2.na;
      }
      if (x < 0 || d1 < 1 || d2 < 1) {
        return error2.num;
      }
      if (typeof x !== "number" || typeof d1 !== "number" || typeof d2 !== "number") {
        return error2.value;
      }
      return 1 - jStat.centralF.cdf(x, d1, d2);
    };
    exports.F.INV = function(probability, d1, d2) {
      probability = utils.parseNumber(probability);
      d1 = utils.parseNumber(d1);
      d2 = utils.parseNumber(d2);
      if (utils.anyIsError(probability, d1, d2)) {
        return error2.value;
      }
      if (probability <= 0 || probability > 1) {
        return error2.num;
      }
      return jStat.centralF.inv(probability, d1, d2);
    };
    exports.F.INV.RT = function(p, d1, d2) {
      if (arguments.length !== 3) {
        return error2.na;
      }
      if (p < 0 || p > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {
        return error2.num;
      }
      if (typeof p !== "number" || typeof d1 !== "number" || typeof d2 !== "number") {
        return error2.value;
      }
      return jStat.centralF.inv(1 - p, d1, d2);
    };
    exports.F.TEST = function(array1, array2) {
      if (!array1 || !array2) {
        return error2.na;
      }
      if (!(array1 instanceof Array) || !(array2 instanceof Array)) {
        return error2.na;
      }
      if (array1.length < 2 || array2.length < 2) {
        return error2.div0;
      }
      var sumOfSquares = function(values, x12) {
        var sum = 0;
        for (var i = 0; i < values.length; i++) {
          sum += Math.pow(values[i] - x12, 2);
        }
        return sum;
      };
      var x1 = mathTrig.SUM(array1) / array1.length;
      var x2 = mathTrig.SUM(array2) / array2.length;
      var sum1 = sumOfSquares(array1, x1) / (array1.length - 1);
      var sum2 = sumOfSquares(array2, x2) / (array2.length - 1);
      return sum1 / sum2;
    };
    exports.FISHER = function(x) {
      x = utils.parseNumber(x);
      if (x instanceof Error) {
        return x;
      }
      return Math.log((1 + x) / (1 - x)) / 2;
    };
    exports.FISHERINV = function(y) {
      y = utils.parseNumber(y);
      if (y instanceof Error) {
        return y;
      }
      var e2y = Math.exp(2 * y);
      return (e2y - 1) / (e2y + 1);
    };
    exports.FORECAST = function(x, data_y, data_x) {
      x = utils.parseNumber(x);
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      if (utils.anyIsError(x, data_y, data_x)) {
        return error2.value;
      }
      var xmean = jStat.mean(data_x);
      var ymean = jStat.mean(data_y);
      var n = data_x.length;
      var num = 0;
      var den = 0;
      for (var i = 0; i < n; i++) {
        num += (data_x[i] - xmean) * (data_y[i] - ymean);
        den += Math.pow(data_x[i] - xmean, 2);
      }
      var b = num / den;
      var a = ymean - b * xmean;
      return a + b * x;
    };
    exports.FREQUENCY = function(data, bins) {
      data = utils.parseNumberArray(utils.flatten(data));
      bins = utils.parseNumberArray(utils.flatten(bins));
      if (utils.anyIsError(data, bins)) {
        return error2.value;
      }
      var n = data.length;
      var b = bins.length;
      var r = [];
      for (var i = 0; i <= b; i++) {
        r[i] = 0;
        for (var j = 0; j < n; j++) {
          if (i === 0) {
            if (data[j] <= bins[0]) {
              r[0] += 1;
            }
          } else if (i < b) {
            if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
              r[i] += 1;
            }
          } else if (i === b) {
            if (data[j] > bins[b - 1]) {
              r[b] += 1;
            }
          }
        }
      }
      return r;
    };
    exports.GAMMA = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (number === 0) {
        return error2.num;
      }
      if (parseInt(number, 10) === number && number < 0) {
        return error2.num;
      }
      return jStat.gammafn(number);
    };
    exports.GAMMA.DIST = function(value, alpha, beta, cumulative) {
      if (arguments.length !== 4) {
        return error2.na;
      }
      if (value < 0 || alpha <= 0 || beta <= 0) {
        return error2.value;
      }
      if (typeof value !== "number" || typeof alpha !== "number" || typeof beta !== "number") {
        return error2.value;
      }
      return cumulative ? jStat.gamma.cdf(value, alpha, beta, true) : jStat.gamma.pdf(value, alpha, beta, false);
    };
    exports.GAMMA.INV = function(probability, alpha, beta) {
      if (arguments.length !== 3) {
        return error2.na;
      }
      if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
        return error2.num;
      }
      if (typeof probability !== "number" || typeof alpha !== "number" || typeof beta !== "number") {
        return error2.value;
      }
      return jStat.gamma.inv(probability, alpha, beta);
    };
    exports.GAMMALN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return jStat.gammaln(number);
    };
    exports.GAMMALN.PRECISE = function(x) {
      if (arguments.length !== 1) {
        return error2.na;
      }
      if (x <= 0) {
        return error2.num;
      }
      if (typeof x !== "number") {
        return error2.value;
      }
      return jStat.gammaln(x);
    };
    exports.GAUSS = function(z) {
      z = utils.parseNumber(z);
      if (z instanceof Error) {
        return z;
      }
      return jStat.normal.cdf(z, 0, 1) - 0.5;
    };
    exports.GEOMEAN = function() {
      var args = utils.parseNumberArray(utils.flatten(arguments));
      if (args instanceof Error) {
        return args;
      }
      return jStat.geomean(args);
    };
    exports.GROWTH = function(known_y, known_x, new_x, use_const) {
      known_y = utils.parseNumberArray(known_y);
      if (known_y instanceof Error) {
        return known_y;
      }
      var i;
      if (known_x === void 0) {
        known_x = [];
        for (i = 1; i <= known_y.length; i++) {
          known_x.push(i);
        }
      }
      if (new_x === void 0) {
        new_x = [];
        for (i = 1; i <= known_y.length; i++) {
          new_x.push(i);
        }
      }
      known_x = utils.parseNumberArray(known_x);
      new_x = utils.parseNumberArray(new_x);
      if (utils.anyIsError(known_x, new_x)) {
        return error2.value;
      }
      if (use_const === void 0) {
        use_const = true;
      }
      var n = known_y.length;
      var avg_x = 0;
      var avg_y = 0;
      var avg_xy = 0;
      var avg_xx = 0;
      for (i = 0; i < n; i++) {
        var x = known_x[i];
        var y = Math.log(known_y[i]);
        avg_x += x;
        avg_y += y;
        avg_xy += x * y;
        avg_xx += x * x;
      }
      avg_x /= n;
      avg_y /= n;
      avg_xy /= n;
      avg_xx /= n;
      var beta;
      var alpha;
      if (use_const) {
        beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
        alpha = avg_y - beta * avg_x;
      } else {
        beta = avg_xy / avg_xx;
        alpha = 0;
      }
      var new_y = [];
      for (i = 0; i < new_x.length; i++) {
        new_y.push(Math.exp(alpha + beta * new_x[i]));
      }
      return new_y;
    };
    exports.HARMEAN = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      var n = range.length;
      var den = 0;
      for (var i = 0; i < n; i++) {
        den += 1 / range[i];
      }
      return n / den;
    };
    exports.HYPGEOM = {};
    exports.HYPGEOM.DIST = function(x, n, M, N, cumulative) {
      x = utils.parseNumber(x);
      n = utils.parseNumber(n);
      M = utils.parseNumber(M);
      N = utils.parseNumber(N);
      if (utils.anyIsError(x, n, M, N)) {
        return error2.value;
      }
      function pdf(x2, n2, M2, N2) {
        return mathTrig.COMBIN(M2, x2) * mathTrig.COMBIN(N2 - M2, n2 - x2) / mathTrig.COMBIN(N2, n2);
      }
      function cdf(x2, n2, M2, N2) {
        var result = 0;
        for (var i = 0; i <= x2; i++) {
          result += pdf(i, n2, M2, N2);
        }
        return result;
      }
      return cumulative ? cdf(x, n, M, N) : pdf(x, n, M, N);
    };
    exports.INTERCEPT = function(known_y, known_x) {
      known_y = utils.parseNumberArray(known_y);
      known_x = utils.parseNumberArray(known_x);
      if (utils.anyIsError(known_y, known_x)) {
        return error2.value;
      }
      if (known_y.length !== known_x.length) {
        return error2.na;
      }
      return exports.FORECAST(0, known_y, known_x);
    };
    exports.KURT = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      var mean = jStat.mean(range);
      var n = range.length;
      var sigma = 0;
      for (var i = 0; i < n; i++) {
        sigma += Math.pow(range[i] - mean, 4);
      }
      sigma = sigma / Math.pow(jStat.stdev(range, true), 4);
      return n * (n + 1) / ((n - 1) * (n - 2) * (n - 3)) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));
    };
    exports.LARGE = function(range, k) {
      range = utils.parseNumberArray(utils.flatten(range));
      k = utils.parseNumber(k);
      if (utils.anyIsError(range, k)) {
        return range;
      }
      return range.sort(function(a, b) {
        return b - a;
      })[k - 1];
    };
    exports.LINEST = function(data_y, data_x) {
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      if (utils.anyIsError(data_y, data_x)) {
        return error2.value;
      }
      var ymean = jStat.mean(data_y);
      var xmean = jStat.mean(data_x);
      var n = data_x.length;
      var num = 0;
      var den = 0;
      for (var i = 0; i < n; i++) {
        num += (data_x[i] - xmean) * (data_y[i] - ymean);
        den += Math.pow(data_x[i] - xmean, 2);
      }
      var m = num / den;
      var b = ymean - m * xmean;
      return [m, b];
    };
    exports.LOGEST = function(data_y, data_x) {
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      if (utils.anyIsError(data_y, data_x)) {
        return error2.value;
      }
      for (var i = 0; i < data_y.length; i++) {
        data_y[i] = Math.log(data_y[i]);
      }
      var result = exports.LINEST(data_y, data_x);
      result[0] = Math.round(Math.exp(result[0]) * 1e6) / 1e6;
      result[1] = Math.round(Math.exp(result[1]) * 1e6) / 1e6;
      return result;
    };
    exports.LOGNORM = {};
    exports.LOGNORM.DIST = function(x, mean, sd, cumulative) {
      x = utils.parseNumber(x);
      mean = utils.parseNumber(mean);
      sd = utils.parseNumber(sd);
      if (utils.anyIsError(x, mean, sd)) {
        return error2.value;
      }
      return cumulative ? jStat.lognormal.cdf(x, mean, sd) : jStat.lognormal.pdf(x, mean, sd);
    };
    exports.LOGNORM.INV = function(probability, mean, sd) {
      probability = utils.parseNumber(probability);
      mean = utils.parseNumber(mean);
      sd = utils.parseNumber(sd);
      if (utils.anyIsError(probability, mean, sd)) {
        return error2.value;
      }
      return jStat.lognormal.inv(probability, mean, sd);
    };
    exports.MAX = function() {
      var range = utils.numbers(utils.flatten(arguments));
      return range.length === 0 ? 0 : Math.max.apply(Math, range);
    };
    exports.MAXA = function() {
      var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
      return range.length === 0 ? 0 : Math.max.apply(Math, range);
    };
    exports.MEDIAN = function() {
      var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
      var result = jStat.median(range);
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.MIN = function() {
      var range = utils.numbers(utils.flatten(arguments));
      return range.length === 0 ? 0 : Math.min.apply(Math, range);
    };
    exports.MINA = function() {
      var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
      return range.length === 0 ? 0 : Math.min.apply(Math, range);
    };
    exports.MODE = {};
    exports.MODE.MULT = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      var n = range.length;
      var count = {};
      var maxItems = [];
      var max = 0;
      var currentItem;
      for (var i = 0; i < n; i++) {
        currentItem = range[i];
        count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
        if (count[currentItem] > max) {
          max = count[currentItem];
          maxItems = [];
        }
        if (count[currentItem] === max) {
          maxItems[maxItems.length] = currentItem;
        }
      }
      return maxItems;
    };
    exports.MODE.SNGL = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      return exports.MODE.MULT(range).sort(function(a, b) {
        return a - b;
      })[0];
    };
    exports.NEGBINOM = {};
    exports.NEGBINOM.DIST = function(k, r, p, cumulative) {
      k = utils.parseNumber(k);
      r = utils.parseNumber(r);
      p = utils.parseNumber(p);
      if (utils.anyIsError(k, r, p)) {
        return error2.value;
      }
      return cumulative ? jStat.negbin.cdf(k, r, p) : jStat.negbin.pdf(k, r, p);
    };
    exports.NORM = {};
    exports.NORM.DIST = function(x, mean, sd, cumulative) {
      x = utils.parseNumber(x);
      mean = utils.parseNumber(mean);
      sd = utils.parseNumber(sd);
      if (utils.anyIsError(x, mean, sd)) {
        return error2.value;
      }
      if (sd <= 0) {
        return error2.num;
      }
      return cumulative ? jStat.normal.cdf(x, mean, sd) : jStat.normal.pdf(x, mean, sd);
    };
    exports.NORM.INV = function(probability, mean, sd) {
      probability = utils.parseNumber(probability);
      mean = utils.parseNumber(mean);
      sd = utils.parseNumber(sd);
      if (utils.anyIsError(probability, mean, sd)) {
        return error2.value;
      }
      return jStat.normal.inv(probability, mean, sd);
    };
    exports.NORM.S = {};
    exports.NORM.S.DIST = function(z, cumulative) {
      z = utils.parseNumber(z);
      if (z instanceof Error) {
        return error2.value;
      }
      return cumulative ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);
    };
    exports.NORM.S.INV = function(probability) {
      probability = utils.parseNumber(probability);
      if (probability instanceof Error) {
        return error2.value;
      }
      return jStat.normal.inv(probability, 0, 1);
    };
    exports.PEARSON = function(data_x, data_y) {
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      if (utils.anyIsError(data_y, data_x)) {
        return error2.value;
      }
      var xmean = jStat.mean(data_x);
      var ymean = jStat.mean(data_y);
      var n = data_x.length;
      var num = 0;
      var den1 = 0;
      var den2 = 0;
      for (var i = 0; i < n; i++) {
        num += (data_x[i] - xmean) * (data_y[i] - ymean);
        den1 += Math.pow(data_x[i] - xmean, 2);
        den2 += Math.pow(data_y[i] - ymean, 2);
      }
      return num / Math.sqrt(den1 * den2);
    };
    exports.PERCENTILE = {};
    exports.PERCENTILE.EXC = function(array, k) {
      array = utils.parseNumberArray(utils.flatten(array));
      k = utils.parseNumber(k);
      if (utils.anyIsError(array, k)) {
        return error2.value;
      }
      array = array.sort(function(a, b) {
        {
          return a - b;
        }
      });
      var n = array.length;
      if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
        return error2.num;
      }
      var l = k * (n + 1) - 1;
      var fl = Math.floor(l);
      return utils.cleanFloat(l === fl ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
    };
    exports.PERCENTILE.INC = function(array, k) {
      array = utils.parseNumberArray(utils.flatten(array));
      k = utils.parseNumber(k);
      if (utils.anyIsError(array, k)) {
        return error2.value;
      }
      array = array.sort(function(a, b) {
        return a - b;
      });
      var n = array.length;
      var l = k * (n - 1);
      var fl = Math.floor(l);
      return utils.cleanFloat(l === fl ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
    };
    exports.PERCENTRANK = {};
    exports.PERCENTRANK.EXC = function(array, x, significance) {
      significance = significance === void 0 ? 3 : significance;
      array = utils.parseNumberArray(utils.flatten(array));
      x = utils.parseNumber(x);
      significance = utils.parseNumber(significance);
      if (utils.anyIsError(array, x, significance)) {
        return error2.value;
      }
      array = array.sort(function(a, b) {
        return a - b;
      });
      var uniques = misc.UNIQUE.apply(null, array);
      var n = array.length;
      var m = uniques.length;
      var power = Math.pow(10, significance);
      var result = 0;
      var match = false;
      var i = 0;
      while (!match && i < m) {
        if (x === uniques[i]) {
          result = (array.indexOf(uniques[i]) + 1) / (n + 1);
          match = true;
        } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
          result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
          match = true;
        }
        i++;
      }
      return Math.floor(result * power) / power;
    };
    exports.PERCENTRANK.INC = function(array, x, significance) {
      significance = significance === void 0 ? 3 : significance;
      array = utils.parseNumberArray(utils.flatten(array));
      x = utils.parseNumber(x);
      significance = utils.parseNumber(significance);
      if (utils.anyIsError(array, x, significance)) {
        return error2.value;
      }
      array = array.sort(function(a, b) {
        return a - b;
      });
      var uniques = misc.UNIQUE.apply(null, array);
      var n = array.length;
      var m = uniques.length;
      var power = Math.pow(10, significance);
      var result = 0;
      var match = false;
      var i = 0;
      while (!match && i < m) {
        if (x === uniques[i]) {
          result = array.indexOf(uniques[i]) / (n - 1);
          match = true;
        } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
          result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
          match = true;
        }
        i++;
      }
      return Math.floor(result * power) / power;
    };
    exports.PERMUT = function(number, number_chosen) {
      number = utils.parseNumber(number);
      number_chosen = utils.parseNumber(number_chosen);
      if (utils.anyIsError(number, number_chosen)) {
        return error2.value;
      }
      return mathTrig.FACT(number) / mathTrig.FACT(number - number_chosen);
    };
    exports.PERMUTATIONA = function(number, number_chosen) {
      number = utils.parseNumber(number);
      number_chosen = utils.parseNumber(number_chosen);
      if (utils.anyIsError(number, number_chosen)) {
        return error2.value;
      }
      return Math.pow(number, number_chosen);
    };
    exports.PHI = function(x) {
      x = utils.parseNumber(x);
      if (x instanceof Error) {
        return error2.value;
      }
      return Math.exp(-0.5 * x * x) / SQRT2PI;
    };
    exports.POISSON = {};
    exports.POISSON.DIST = function(x, mean, cumulative) {
      x = utils.parseNumber(x);
      mean = utils.parseNumber(mean);
      if (utils.anyIsError(x, mean)) {
        return error2.value;
      }
      return cumulative ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);
    };
    exports.PROB = function(range, probability, lower, upper) {
      if (lower === void 0) {
        return 0;
      }
      upper = upper === void 0 ? lower : upper;
      range = utils.parseNumberArray(utils.flatten(range));
      probability = utils.parseNumberArray(utils.flatten(probability));
      lower = utils.parseNumber(lower);
      upper = utils.parseNumber(upper);
      if (utils.anyIsError(range, probability, lower, upper)) {
        return error2.value;
      }
      if (lower === upper) {
        return range.indexOf(lower) >= 0 ? probability[range.indexOf(lower)] : 0;
      }
      var sorted = range.sort(function(a, b) {
        return a - b;
      });
      var n = sorted.length;
      var result = 0;
      for (var i = 0; i < n; i++) {
        if (sorted[i] >= lower && sorted[i] <= upper) {
          result += probability[range.indexOf(sorted[i])];
        }
      }
      return result;
    };
    exports.QUARTILE = {};
    exports.QUARTILE.EXC = function(range, quart) {
      range = utils.parseNumberArray(utils.flatten(range));
      quart = utils.parseNumber(quart);
      if (utils.anyIsError(range, quart)) {
        return error2.value;
      }
      switch (quart) {
        case 1:
          return exports.PERCENTILE.EXC(range, 0.25);
        case 2:
          return exports.PERCENTILE.EXC(range, 0.5);
        case 3:
          return exports.PERCENTILE.EXC(range, 0.75);
        default:
          return error2.num;
      }
    };
    exports.QUARTILE.INC = function(range, quart) {
      range = utils.parseNumberArray(utils.flatten(range));
      quart = utils.parseNumber(quart);
      if (utils.anyIsError(range, quart)) {
        return error2.value;
      }
      switch (quart) {
        case 1:
          return exports.PERCENTILE.INC(range, 0.25);
        case 2:
          return exports.PERCENTILE.INC(range, 0.5);
        case 3:
          return exports.PERCENTILE.INC(range, 0.75);
        default:
          return error2.num;
      }
    };
    exports.RANK = {};
    exports.RANK.AVG = function(number, range, order) {
      number = utils.parseNumber(number);
      range = utils.parseNumberArray(utils.flatten(range));
      if (utils.anyIsError(number, range)) {
        return error2.value;
      }
      range = utils.flatten(range);
      order = order || false;
      var sort = order ? function(a, b) {
        return a - b;
      } : function(a, b) {
        return b - a;
      };
      range = range.sort(sort);
      var length = range.length;
      var count = 0;
      for (var i = 0; i < length; i++) {
        if (range[i] === number) {
          count++;
        }
      }
      return count > 1 ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
    };
    exports.RANK.EQ = function(number, range, order) {
      number = utils.parseNumber(number);
      range = utils.parseNumberArray(utils.flatten(range));
      if (utils.anyIsError(number, range)) {
        return error2.value;
      }
      order = order || false;
      var sort = order ? function(a, b) {
        return a - b;
      } : function(a, b) {
        return b - a;
      };
      range = range.sort(sort);
      return range.indexOf(number) + 1;
    };
    exports.ROW = function(matrix, index) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      if (index < 0) {
        return error2.num;
      }
      if (!(matrix instanceof Array) || typeof index !== "number") {
        return error2.value;
      }
      if (matrix.length === 0) {
        return void 0;
      }
      return jStat.row(matrix, index);
    };
    exports.ROWS = function(matrix) {
      if (arguments.length !== 1) {
        return error2.na;
      }
      if (!(matrix instanceof Array)) {
        return error2.value;
      }
      if (matrix.length === 0) {
        return 0;
      }
      return jStat.rows(matrix);
    };
    exports.RSQ = function(data_x, data_y) {
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      if (utils.anyIsError(data_x, data_y)) {
        return error2.value;
      }
      return Math.pow(exports.PEARSON(data_x, data_y), 2);
    };
    exports.SKEW = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      var mean = jStat.mean(range);
      var n = range.length;
      var sigma = 0;
      for (var i = 0; i < n; i++) {
        sigma += Math.pow(range[i] - mean, 3);
      }
      return n * sigma / ((n - 1) * (n - 2) * Math.pow(jStat.stdev(range, true), 3));
    };
    exports.SKEW.P = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      var mean = jStat.mean(range);
      var n = range.length;
      var m2 = 0;
      var m3 = 0;
      for (var i = 0; i < n; i++) {
        m3 += Math.pow(range[i] - mean, 3);
        m2 += Math.pow(range[i] - mean, 2);
      }
      m3 = m3 / n;
      m2 = m2 / n;
      return m3 / Math.pow(m2, 3 / 2);
    };
    exports.SLOPE = function(data_y, data_x) {
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      if (utils.anyIsError(data_y, data_x)) {
        return error2.value;
      }
      var xmean = jStat.mean(data_x);
      var ymean = jStat.mean(data_y);
      var n = data_x.length;
      var num = 0;
      var den = 0;
      for (var i = 0; i < n; i++) {
        num += (data_x[i] - xmean) * (data_y[i] - ymean);
        den += Math.pow(data_x[i] - xmean, 2);
      }
      return num / den;
    };
    exports.SMALL = function(range, k) {
      range = utils.parseNumberArray(utils.flatten(range));
      k = utils.parseNumber(k);
      if (utils.anyIsError(range, k)) {
        return range;
      }
      return range.sort(function(a, b) {
        return a - b;
      })[k - 1];
    };
    exports.STANDARDIZE = function(x, mean, sd) {
      x = utils.parseNumber(x);
      mean = utils.parseNumber(mean);
      sd = utils.parseNumber(sd);
      if (utils.anyIsError(x, mean, sd)) {
        return error2.value;
      }
      return (x - mean) / sd;
    };
    exports.STDEV = {};
    exports.STDEV.P = function() {
      var v = exports.VAR.P.apply(this, arguments);
      var result = Math.sqrt(v);
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.STDEV.S = function() {
      var v = exports.VAR.S.apply(this, arguments);
      var result = Math.sqrt(v);
      return result;
    };
    exports.STDEVA = function() {
      var v = exports.VARA.apply(this, arguments);
      var result = Math.sqrt(v);
      return result;
    };
    exports.STDEVPA = function() {
      var v = exports.VARPA.apply(this, arguments);
      var result = Math.sqrt(v);
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.STEYX = function(data_y, data_x) {
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      if (utils.anyIsError(data_y, data_x)) {
        return error2.value;
      }
      var xmean = jStat.mean(data_x);
      var ymean = jStat.mean(data_y);
      var n = data_x.length;
      var lft = 0;
      var num = 0;
      var den = 0;
      for (var i = 0; i < n; i++) {
        lft += Math.pow(data_y[i] - ymean, 2);
        num += (data_x[i] - xmean) * (data_y[i] - ymean);
        den += Math.pow(data_x[i] - xmean, 2);
      }
      return Math.sqrt((lft - num * num / den) / (n - 2));
    };
    exports.TRANSPOSE = function(matrix) {
      if (!matrix) {
        return error2.na;
      }
      return jStat.transpose(matrix);
    };
    exports.T = text.T;
    exports.T.DIST = function(x, df, cumulative) {
      x = utils.parseNumber(x);
      df = utils.parseNumber(df);
      if (utils.anyIsError(x, df)) {
        return error2.value;
      }
      return cumulative ? jStat.studentt.cdf(x, df) : jStat.studentt.pdf(x, df);
    };
    exports.T.DIST["2T"] = function(x, df) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      if (x < 0 || df < 1) {
        return error2.num;
      }
      if (typeof x !== "number" || typeof df !== "number") {
        return error2.value;
      }
      return (1 - jStat.studentt.cdf(x, df)) * 2;
    };
    exports.T.DIST.RT = function(x, df) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      if (x < 0 || df < 1) {
        return error2.num;
      }
      if (typeof x !== "number" || typeof df !== "number") {
        return error2.value;
      }
      return 1 - jStat.studentt.cdf(x, df);
    };
    exports.T.INV = function(probability, df) {
      probability = utils.parseNumber(probability);
      df = utils.parseNumber(df);
      if (utils.anyIsError(probability, df)) {
        return error2.value;
      }
      return jStat.studentt.inv(probability, df);
    };
    exports.T.INV["2T"] = function(probability, df) {
      probability = utils.parseNumber(probability);
      df = utils.parseNumber(df);
      if (probability <= 0 || probability > 1 || df < 1) {
        return error2.num;
      }
      if (utils.anyIsError(probability, df)) {
        return error2.value;
      }
      return Math.abs(jStat.studentt.inv(probability / 2, df));
    };
    exports.T.TEST = function(data_x, data_y) {
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      if (utils.anyIsError(data_x, data_y)) {
        return error2.value;
      }
      var mean_x = jStat.mean(data_x);
      var mean_y = jStat.mean(data_y);
      var s_x = 0;
      var s_y = 0;
      var i;
      for (i = 0; i < data_x.length; i++) {
        s_x += Math.pow(data_x[i] - mean_x, 2);
      }
      for (i = 0; i < data_y.length; i++) {
        s_y += Math.pow(data_y[i] - mean_y, 2);
      }
      s_x = s_x / (data_x.length - 1);
      s_y = s_y / (data_y.length - 1);
      var t = Math.abs(mean_x - mean_y) / Math.sqrt(s_x / data_x.length + s_y / data_y.length);
      return exports.T.DIST["2T"](t, data_x.length + data_y.length - 2);
    };
    exports.TREND = function(data_y, data_x, new_data_x) {
      data_y = utils.parseNumberArray(utils.flatten(data_y));
      data_x = utils.parseNumberArray(utils.flatten(data_x));
      new_data_x = utils.parseNumberArray(utils.flatten(new_data_x));
      if (utils.anyIsError(data_y, data_x, new_data_x)) {
        return error2.value;
      }
      var linest = exports.LINEST(data_y, data_x);
      var m = linest[0];
      var b = linest[1];
      var result = [];
      new_data_x.forEach(function(x) {
        result.push(m * x + b);
      });
      return result;
    };
    exports.TRIMMEAN = function(range, percent) {
      range = utils.parseNumberArray(utils.flatten(range));
      percent = utils.parseNumber(percent);
      if (utils.anyIsError(range, percent)) {
        return error2.value;
      }
      var trim = mathTrig.FLOOR(range.length * percent, 2) / 2;
      return jStat.mean(utils.initial(utils.rest(range.sort(function(a, b) {
        return a - b;
      }), trim), trim));
    };
    exports.VAR = {};
    exports.VAR.P = function() {
      var range = utils.numbers(utils.flatten(arguments));
      var n = range.length;
      var sigma = 0;
      var mean = exports.AVERAGE(range);
      var result;
      for (var i = 0; i < n; i++) {
        sigma += Math.pow(range[i] - mean, 2);
      }
      result = sigma / n;
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.VAR.S = function() {
      var range = utils.numbers(utils.flatten(arguments));
      var n = range.length;
      var sigma = 0;
      var mean = exports.AVERAGE(range);
      for (var i = 0; i < n; i++) {
        sigma += Math.pow(range[i] - mean, 2);
      }
      return sigma / (n - 1);
    };
    exports.VARA = function() {
      var range = utils.flatten(arguments);
      var n = range.length;
      var sigma = 0;
      var count = 0;
      var mean = exports.AVERAGEA(range);
      for (var i = 0; i < n; i++) {
        var el = range[i];
        if (typeof el === "number") {
          sigma += Math.pow(el - mean, 2);
        } else if (el === true) {
          sigma += Math.pow(1 - mean, 2);
        } else {
          sigma += Math.pow(0 - mean, 2);
        }
        if (el !== null) {
          count++;
        }
      }
      return sigma / (count - 1);
    };
    exports.VARPA = function() {
      var range = utils.flatten(arguments);
      var n = range.length;
      var sigma = 0;
      var count = 0;
      var mean = exports.AVERAGEA(range);
      var result;
      for (var i = 0; i < n; i++) {
        var el = range[i];
        if (typeof el === "number") {
          sigma += Math.pow(el - mean, 2);
        } else if (el === true) {
          sigma += Math.pow(1 - mean, 2);
        } else {
          sigma += Math.pow(0 - mean, 2);
        }
        if (el !== null) {
          count++;
        }
      }
      result = sigma / count;
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.WEIBULL = {};
    exports.WEIBULL.DIST = function(x, alpha, beta, cumulative) {
      x = utils.parseNumber(x);
      alpha = utils.parseNumber(alpha);
      beta = utils.parseNumber(beta);
      if (utils.anyIsError(x, alpha, beta)) {
        return error2.value;
      }
      return cumulative ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
    };
    exports.Z = {};
    exports.Z.TEST = function(range, x, sd) {
      range = utils.parseNumberArray(utils.flatten(range));
      x = utils.parseNumber(x);
      if (utils.anyIsError(range, x)) {
        return error2.value;
      }
      sd = sd || exports.STDEV.S(range);
      var n = range.length;
      return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/information.js
var require_information = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/information.js"(exports) {
    var error2 = require_error();
    exports.CELL = function() {
      throw new Error("CELL is not implemented");
    };
    exports.ERROR = {};
    exports.ERROR.TYPE = function(error_val) {
      switch (error_val) {
        case error2.nil:
          return 1;
        case error2.div0:
          return 2;
        case error2.value:
          return 3;
        case error2.ref:
          return 4;
        case error2.name:
          return 5;
        case error2.num:
          return 6;
        case error2.na:
          return 7;
        case error2.data:
          return 8;
      }
      return error2.na;
    };
    exports.INFO = function() {
      throw new Error("INFO is not implemented");
    };
    exports.ISBLANK = function(value) {
      return value === null;
    };
    exports.ISBINARY = function(number) {
      return /^[01]{1,10}$/.test(number);
    };
    exports.ISERR = function(value) {
      return [error2.value, error2.ref, error2.div0, error2.num, error2.name, error2.nil].indexOf(value) >= 0 || typeof value === "number" && (isNaN(value) || !isFinite(value));
    };
    exports.ISERROR = function(value) {
      return exports.ISERR(value) || value === error2.na;
    };
    exports.ISEVEN = function(number) {
      return Math.floor(Math.abs(number)) & 1 ? false : true;
    };
    exports.ISFORMULA = function() {
      throw new Error("ISFORMULA is not implemented");
    };
    exports.ISLOGICAL = function(value) {
      return value === true || value === false;
    };
    exports.ISNA = function(value) {
      return value === error2.na;
    };
    exports.ISNONTEXT = function(value) {
      return typeof value !== "string";
    };
    exports.ISNUMBER = function(value) {
      return typeof value === "number" && !isNaN(value) && isFinite(value);
    };
    exports.ISODD = function(number) {
      return Math.floor(Math.abs(number)) & 1 ? true : false;
    };
    exports.ISREF = function() {
      throw new Error("ISREF is not implemented");
    };
    exports.ISTEXT = function(value) {
      return typeof value === "string";
    };
    exports.N = function(value) {
      if (this.ISNUMBER(value)) {
        return value;
      }
      if (value instanceof Date) {
        return value.getTime();
      }
      if (value === true) {
        return 1;
      }
      if (value === false) {
        return 0;
      }
      if (this.ISERROR(value)) {
        return value;
      }
      return 0;
    };
    exports.NA = function() {
      return error2.na;
    };
    exports.SHEET = function() {
      throw new Error("SHEET is not implemented");
    };
    exports.SHEETS = function() {
      throw new Error("SHEETS is not implemented");
    };
    exports.TYPE = function(value) {
      if (this.ISNUMBER(value)) {
        return 1;
      }
      if (this.ISTEXT(value)) {
        return 2;
      }
      if (this.ISLOGICAL(value)) {
        return 4;
      }
      if (this.ISERROR(value)) {
        return 16;
      }
      if (Array.isArray(value)) {
        return 64;
      }
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/math-trig.js
var require_math_trig = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/math-trig.js"(exports) {
    var utils = require_common();
    var error2 = require_error();
    var statistical = require_statistical();
    var information = require_information();
    var evalExpression = require_criteria_eval();
    exports.ABS = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var result = Math.abs(number);
      return result;
    };
    exports.ACOS = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var result = Math.acos(number);
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.ACOSH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var result = Math.log(number + Math.sqrt(number * number - 1));
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.ACOT = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var result = Math.atan(1 / number);
      return result;
    };
    exports.ACOTH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var result = 0.5 * Math.log((number + 1) / (number - 1));
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.AGGREGATE = function(function_num, options, ref1, ref2) {
      function_num = utils.parseNumber(function_num);
      options = utils.parseNumber(function_num);
      if (utils.anyIsError(function_num, options)) {
        return error2.value;
      }
      switch (function_num) {
        case 1:
          return statistical.AVERAGE(ref1);
        case 2:
          return statistical.COUNT(ref1);
        case 3:
          return statistical.COUNTA(ref1);
        case 4:
          return statistical.MAX(ref1);
        case 5:
          return statistical.MIN(ref1);
        case 6:
          return exports.PRODUCT(ref1);
        case 7:
          return statistical.STDEV.S(ref1);
        case 8:
          return statistical.STDEV.P(ref1);
        case 9:
          return exports.SUM(ref1);
        case 10:
          return statistical.VAR.S(ref1);
        case 11:
          return statistical.VAR.P(ref1);
        case 12:
          return statistical.MEDIAN(ref1);
        case 13:
          return statistical.MODE.SNGL(ref1);
        case 14:
          return statistical.LARGE(ref1, ref2);
        case 15:
          return statistical.SMALL(ref1, ref2);
        case 16:
          return statistical.PERCENTILE.INC(ref1, ref2);
        case 17:
          return statistical.QUARTILE.INC(ref1, ref2);
        case 18:
          return statistical.PERCENTILE.EXC(ref1, ref2);
        case 19:
          return statistical.QUARTILE.EXC(ref1, ref2);
      }
    };
    exports.ARABIC = function(text) {
      if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
        return error2.value;
      }
      var r = 0;
      text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {
        r += {
          M: 1e3,
          CM: 900,
          D: 500,
          CD: 400,
          C: 100,
          XC: 90,
          L: 50,
          XL: 40,
          X: 10,
          IX: 9,
          V: 5,
          IV: 4,
          I: 1
        }[i];
      });
      return r;
    };
    exports.ASIN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var result = Math.asin(number);
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.ASINH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.log(number + Math.sqrt(number * number + 1));
    };
    exports.ATAN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.atan(number);
    };
    exports.ATAN2 = function(number_x, number_y) {
      number_x = utils.parseNumber(number_x);
      number_y = utils.parseNumber(number_y);
      if (utils.anyIsError(number_x, number_y)) {
        return error2.value;
      }
      return Math.atan2(number_x, number_y);
    };
    exports.ATANH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var result = Math.log((1 + number) / (1 - number)) / 2;
      if (isNaN(result)) {
        result = error2.num;
      }
      return result;
    };
    exports.BASE = function(number, radix, min_length) {
      min_length = min_length || 0;
      number = utils.parseNumber(number);
      radix = utils.parseNumber(radix);
      min_length = utils.parseNumber(min_length);
      if (utils.anyIsError(number, radix, min_length)) {
        return error2.value;
      }
      min_length = min_length === void 0 ? 0 : min_length;
      var result = number.toString(radix);
      return new Array(Math.max(min_length + 1 - result.length, 0)).join("0") + result;
    };
    exports.CEILING = function(number, significance, mode) {
      significance = significance === void 0 ? 1 : Math.abs(significance);
      mode = mode || 0;
      number = utils.parseNumber(number);
      significance = utils.parseNumber(significance);
      mode = utils.parseNumber(mode);
      if (utils.anyIsError(number, significance, mode)) {
        return error2.value;
      }
      if (significance === 0) {
        return 0;
      }
      var precision = -Math.floor(Math.log(significance) / Math.log(10));
      if (number >= 0) {
        return exports.ROUND(Math.ceil(number / significance) * significance, precision);
      } else {
        if (mode === 0) {
          return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
        } else {
          return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
        }
      }
    };
    exports.CEILING.MATH = exports.CEILING;
    exports.CEILING.PRECISE = exports.CEILING;
    exports.COMBIN = function(number, number_chosen) {
      number = utils.parseNumber(number);
      number_chosen = utils.parseNumber(number_chosen);
      if (utils.anyIsError(number, number_chosen)) {
        return error2.value;
      }
      return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));
    };
    exports.COMBINA = function(number, number_chosen) {
      number = utils.parseNumber(number);
      number_chosen = utils.parseNumber(number_chosen);
      if (utils.anyIsError(number, number_chosen)) {
        return error2.value;
      }
      return number === 0 && number_chosen === 0 ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);
    };
    exports.COS = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.cos(number);
    };
    exports.COSH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return (Math.exp(number) + Math.exp(-number)) / 2;
    };
    exports.COT = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return 1 / Math.tan(number);
    };
    exports.COTH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var e2 = Math.exp(2 * number);
      return (e2 + 1) / (e2 - 1);
    };
    exports.CSC = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return 1 / Math.sin(number);
    };
    exports.CSCH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return 2 / (Math.exp(number) - Math.exp(-number));
    };
    exports.DECIMAL = function(number, radix) {
      if (arguments.length < 1) {
        return error2.value;
      }
      return parseInt(number, radix);
    };
    exports.DEGREES = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return number * 180 / Math.PI;
    };
    exports.EVEN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return exports.CEILING(number, -2, -1);
    };
    exports.EXP = function(number) {
      if (arguments.length < 1) {
        return error2.na;
      }
      if (typeof number !== "number" || arguments.length > 1) {
        return error2.error;
      }
      number = Math.exp(number);
      return number;
    };
    var MEMOIZED_FACT = [];
    exports.FACT = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var n = Math.floor(number);
      if (n === 0 || n === 1) {
        return 1;
      } else if (MEMOIZED_FACT[n] > 0) {
        return MEMOIZED_FACT[n];
      } else {
        MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;
        return MEMOIZED_FACT[n];
      }
    };
    exports.FACTDOUBLE = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var n = Math.floor(number);
      if (n <= 0) {
        return 1;
      } else {
        return n * exports.FACTDOUBLE(n - 2);
      }
    };
    exports.FLOOR = function(number, significance) {
      number = utils.parseNumber(number);
      significance = utils.parseNumber(significance);
      if (utils.anyIsError(number, significance)) {
        return error2.value;
      }
      if (significance === 0) {
        return 0;
      }
      if (!(number > 0 && significance > 0) && !(number < 0 && significance < 0)) {
        return error2.num;
      }
      significance = Math.abs(significance);
      var precision = -Math.floor(Math.log(significance) / Math.log(10));
      if (number >= 0) {
        return exports.ROUND(Math.floor(number / significance) * significance, precision);
      } else {
        return -exports.ROUND(Math.ceil(Math.abs(number) / significance), precision);
      }
    };
    exports.FLOOR.MATH = function(number, significance, mode) {
      significance = significance === void 0 ? 1 : significance;
      mode = mode === void 0 ? 0 : mode;
      number = utils.parseNumber(number);
      significance = utils.parseNumber(significance);
      mode = utils.parseNumber(mode);
      if (utils.anyIsError(number, significance, mode)) {
        return error2.value;
      }
      if (significance === 0) {
        return 0;
      }
      significance = significance ? Math.abs(significance) : 1;
      var precision = -Math.floor(Math.log(significance) / Math.log(10));
      if (number >= 0) {
        return exports.ROUND(Math.floor(number / significance) * significance, precision);
      } else if (mode === 0 || mode === void 0) {
        return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
      }
      return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
    };
    exports.FLOOR.PRECISE = exports.FLOOR.MATH;
    exports.GCD = function() {
      var range = utils.parseNumberArray(utils.flatten(arguments));
      if (range instanceof Error) {
        return range;
      }
      var n = range.length;
      var r0 = range[0];
      var x = r0 < 0 ? -r0 : r0;
      for (var i = 1; i < n; i++) {
        var ri = range[i];
        var y = ri < 0 ? -ri : ri;
        while (x && y) {
          if (x > y) {
            x %= y;
          } else {
            y %= x;
          }
        }
        x += y;
      }
      return x;
    };
    exports.INT = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.floor(number);
    };
    exports.ISO = {
      CEILING: exports.CEILING
    };
    exports.LCM = function() {
      var o3 = utils.parseNumberArray(utils.flatten(arguments));
      if (o3 instanceof Error) {
        return o3;
      }
      for (var i, j, n, d, r = 1; (n = o3.pop()) !== void 0; ) {
        while (n > 1) {
          if (n % 2) {
            for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
            }
            d = i <= j ? i : n;
          } else {
            d = 2;
          }
          for (n /= d, r *= d, i = o3.length; i; o3[--i] % d === 0 && (o3[i] /= d) === 1 && o3.splice(i, 1)) {
          }
        }
      }
      return r;
    };
    exports.LN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.log(number);
    };
    exports.LN10 = function() {
      return Math.log(10);
    };
    exports.LN2 = function() {
      return Math.log(2);
    };
    exports.LOG10E = function() {
      return Math.LOG10E;
    };
    exports.LOG2E = function() {
      return Math.LOG2E;
    };
    exports.LOG = function(number, base) {
      number = utils.parseNumber(number);
      base = utils.parseNumber(base);
      if (utils.anyIsError(number, base)) {
        return error2.value;
      }
      base = base === void 0 ? 10 : base;
      return Math.log(number) / Math.log(base);
    };
    exports.LOG10 = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.log(number) / Math.log(10);
    };
    exports.MOD = function(dividend, divisor) {
      dividend = utils.parseNumber(dividend);
      divisor = utils.parseNumber(divisor);
      if (utils.anyIsError(dividend, divisor)) {
        return error2.value;
      }
      if (divisor === 0) {
        return error2.div0;
      }
      var modulus = Math.abs(dividend % divisor);
      return divisor > 0 ? modulus : -modulus;
    };
    exports.MROUND = function(number, multiple) {
      number = utils.parseNumber(number);
      multiple = utils.parseNumber(multiple);
      if (utils.anyIsError(number, multiple)) {
        return error2.value;
      }
      if (number * multiple < 0) {
        return error2.num;
      }
      return Math.round(number / multiple) * multiple;
    };
    exports.MULTINOMIAL = function() {
      var args = utils.parseNumberArray(utils.flatten(arguments));
      if (args instanceof Error) {
        return args;
      }
      var sum = 0;
      var divisor = 1;
      for (var i = 0; i < args.length; i++) {
        sum += args[i];
        divisor *= exports.FACT(args[i]);
      }
      return exports.FACT(sum) / divisor;
    };
    exports.ODD = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var temp = Math.ceil(Math.abs(number));
      temp = temp & 1 ? temp : temp + 1;
      return number > 0 ? temp : -temp;
    };
    exports.PI = function() {
      return Math.PI;
    };
    exports.E = function() {
      return Math.E;
    };
    exports.POWER = function(number, power) {
      number = utils.parseNumber(number);
      power = utils.parseNumber(power);
      if (utils.anyIsError(number, power)) {
        return error2.value;
      }
      var result = Math.pow(number, power);
      if (isNaN(result)) {
        return error2.num;
      }
      return result;
    };
    exports.PRODUCT = function() {
      var args = utils.parseNumberArray(utils.flatten(arguments));
      if (args instanceof Error) {
        return args;
      }
      var result = 1;
      for (var i = 0; i < args.length; i++) {
        result *= args[i];
      }
      return result;
    };
    exports.QUOTIENT = function(numerator, denominator) {
      numerator = utils.parseNumber(numerator);
      denominator = utils.parseNumber(denominator);
      if (utils.anyIsError(numerator, denominator)) {
        return error2.value;
      }
      return parseInt(numerator / denominator, 10);
    };
    exports.RADIANS = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return number * Math.PI / 180;
    };
    exports.RAND = function() {
      return Math.random();
    };
    exports.RANDBETWEEN = function(bottom, top) {
      bottom = utils.parseNumber(bottom);
      top = utils.parseNumber(top);
      if (utils.anyIsError(bottom, top)) {
        return error2.value;
      }
      return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
    };
    exports.ROMAN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var digits = String(number).split("");
      var key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
      var roman = "";
      var i = 3;
      while (i--) {
        roman = (key[+digits.pop() + i * 10] || "") + roman;
      }
      return new Array(+digits.join("") + 1).join("M") + roman;
    };
    exports.ROUND = function(number, digits) {
      number = utils.parseNumber(number);
      digits = utils.parseNumber(digits);
      if (utils.anyIsError(number, digits)) {
        return error2.value;
      }
      return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
    };
    exports.ROUNDDOWN = function(number, digits) {
      number = utils.parseNumber(number);
      digits = utils.parseNumber(digits);
      if (utils.anyIsError(number, digits)) {
        return error2.value;
      }
      var sign = number > 0 ? 1 : -1;
      return sign * Math.floor(Math.abs(number) * Math.pow(10, digits)) / Math.pow(10, digits);
    };
    exports.ROUNDUP = function(number, digits) {
      number = utils.parseNumber(number);
      digits = utils.parseNumber(digits);
      if (utils.anyIsError(number, digits)) {
        return error2.value;
      }
      var sign = number > 0 ? 1 : -1;
      return sign * Math.ceil(Math.abs(number) * Math.pow(10, digits)) / Math.pow(10, digits);
    };
    exports.SEC = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return 1 / Math.cos(number);
    };
    exports.SECH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return 2 / (Math.exp(number) + Math.exp(-number));
    };
    exports.SERIESSUM = function(x, n, m, coefficients) {
      x = utils.parseNumber(x);
      n = utils.parseNumber(n);
      m = utils.parseNumber(m);
      coefficients = utils.parseNumberArray(coefficients);
      if (utils.anyIsError(x, n, m, coefficients)) {
        return error2.value;
      }
      var result = coefficients[0] * Math.pow(x, n);
      for (var i = 1; i < coefficients.length; i++) {
        result += coefficients[i] * Math.pow(x, n + i * m);
      }
      return result;
    };
    exports.SIGN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (number < 0) {
        return -1;
      } else if (number === 0) {
        return 0;
      } else {
        return 1;
      }
    };
    exports.SIN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.sin(number);
    };
    exports.SINH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return (Math.exp(number) - Math.exp(-number)) / 2;
    };
    exports.SQRT = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (number < 0) {
        return error2.num;
      }
      return Math.sqrt(number);
    };
    exports.SQRTPI = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.sqrt(number * Math.PI);
    };
    exports.SQRT1_2 = function() {
      return 1 / Math.sqrt(2);
    };
    exports.SQRT2 = function() {
      return Math.sqrt(2);
    };
    exports.SUBTOTAL = function(function_code, ref1) {
      function_code = utils.parseNumber(function_code);
      if (function_code instanceof Error) {
        return function_code;
      }
      switch (function_code) {
        case 1:
          return statistical.AVERAGE(ref1);
        case 2:
          return statistical.COUNT(ref1);
        case 3:
          return statistical.COUNTA(ref1);
        case 4:
          return statistical.MAX(ref1);
        case 5:
          return statistical.MIN(ref1);
        case 6:
          return exports.PRODUCT(ref1);
        case 7:
          return statistical.STDEV.S(ref1);
        case 8:
          return statistical.STDEV.P(ref1);
        case 9:
          return exports.SUM(ref1);
        case 10:
          return statistical.VAR.S(ref1);
        case 11:
          return statistical.VAR.P(ref1);
        case 101:
          return statistical.AVERAGE(ref1);
        case 102:
          return statistical.COUNT(ref1);
        case 103:
          return statistical.COUNTA(ref1);
        case 104:
          return statistical.MAX(ref1);
        case 105:
          return statistical.MIN(ref1);
        case 106:
          return exports.PRODUCT(ref1);
        case 107:
          return statistical.STDEV.S(ref1);
        case 108:
          return statistical.STDEV.P(ref1);
        case 109:
          return exports.SUM(ref1);
        case 110:
          return statistical.VAR.S(ref1);
        case 111:
          return statistical.VAR.P(ref1);
      }
    };
    exports.ADD = function(num1, num2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      num1 = utils.parseNumber(num1);
      num2 = utils.parseNumber(num2);
      if (utils.anyIsError(num1, num2)) {
        return error2.value;
      }
      return num1 + num2;
    };
    exports.MINUS = function(num1, num2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      num1 = utils.parseNumber(num1);
      num2 = utils.parseNumber(num2);
      if (utils.anyIsError(num1, num2)) {
        return error2.value;
      }
      return num1 - num2;
    };
    exports.DIVIDE = function(dividend, divisor) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      dividend = utils.parseNumber(dividend);
      divisor = utils.parseNumber(divisor);
      if (utils.anyIsError(dividend, divisor)) {
        return error2.value;
      }
      if (divisor === 0) {
        return error2.div0;
      }
      return dividend / divisor;
    };
    exports.MULTIPLY = function(factor1, factor2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      factor1 = utils.parseNumber(factor1);
      factor2 = utils.parseNumber(factor2);
      if (utils.anyIsError(factor1, factor2)) {
        return error2.value;
      }
      return factor1 * factor2;
    };
    exports.GTE = function(num1, num2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      num1 = utils.parseNumber(num1);
      num2 = utils.parseNumber(num2);
      if (utils.anyIsError(num1, num2)) {
        return error2.error;
      }
      return num1 >= num2;
    };
    exports.LT = function(num1, num2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      num1 = utils.parseNumber(num1);
      num2 = utils.parseNumber(num2);
      if (utils.anyIsError(num1, num2)) {
        return error2.error;
      }
      return num1 < num2;
    };
    exports.LTE = function(num1, num2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      num1 = utils.parseNumber(num1);
      num2 = utils.parseNumber(num2);
      if (utils.anyIsError(num1, num2)) {
        return error2.error;
      }
      return num1 <= num2;
    };
    exports.EQ = function(value1, value2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      return value1 === value2;
    };
    exports.NE = function(value1, value2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      return value1 !== value2;
    };
    exports.POW = function(base, exponent) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      base = utils.parseNumber(base);
      exponent = utils.parseNumber(exponent);
      if (utils.anyIsError(base, exponent)) {
        return error2.error;
      }
      return exports.POWER(base, exponent);
    };
    exports.SUM = function() {
      var result = 0;
      utils.arrayEach(utils.argsToArray(arguments), function(value) {
        if (typeof value === "number") {
          result += value;
        } else if (typeof value === "string") {
          var parsed = parseFloat(value);
          !isNaN(parsed) && (result += parsed);
        } else if (Array.isArray(value)) {
          result += exports.SUM.apply(null, value);
        }
      });
      return result;
    };
    exports.SUMIF = function(range, criteria) {
      range = utils.parseNumberArray(utils.flatten(range));
      if (range instanceof Error) {
        return range;
      }
      var result = 0;
      var isWildcard = criteria === void 0 || criteria === "*";
      var tokenizedCriteria = isWildcard ? null : evalExpression.parse(criteria + "");
      for (var i = 0; i < range.length; i++) {
        var value = range[i];
        if (isWildcard) {
          result += value;
        } else {
          var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
          result += evalExpression.compute(tokens) ? value : 0;
        }
      }
      return result;
    };
    exports.SUMIFS = function() {
      var args = utils.argsToArray(arguments);
      var range = utils.parseNumberArray(utils.flatten(args.shift()));
      if (range instanceof Error) {
        return range;
      }
      var criterias = args;
      var n_range_elements = range.length;
      var criteriaLength = criterias.length;
      var result = 0;
      for (var i = 0; i < n_range_elements; i++) {
        var value = range[i];
        var isMeetCondition = false;
        for (var j = 0; j < criteriaLength; j++) {
          var criteria = criterias[j];
          var isWildcard = criteria === void 0 || criteria === "*";
          var computedResult = false;
          if (isWildcard) {
            computedResult = true;
          } else {
            var tokenizedCriteria = evalExpression.parse(criteria + "");
            var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
            computedResult = evalExpression.compute(tokens);
          }
          if (!computedResult) {
            isMeetCondition = false;
            break;
          }
          isMeetCondition = true;
        }
        if (isMeetCondition) {
          result += value;
        }
      }
      return result;
    };
    exports.SUMPRODUCT = function() {
      if (!arguments || arguments.length === 0) {
        return error2.value;
      }
      var arrays = arguments.length + 1;
      var result = 0;
      var product;
      var k;
      var _i;
      var _ij;
      for (var i = 0; i < arguments[0].length; i++) {
        if (!(arguments[0][i] instanceof Array)) {
          product = 1;
          for (k = 1; k < arrays; k++) {
            _i = utils.parseNumber(arguments[k - 1][i]);
            if (_i instanceof Error) {
              return _i;
            }
            product *= _i;
          }
          result += product;
        } else {
          for (var j = 0; j < arguments[0][i].length; j++) {
            product = 1;
            for (k = 1; k < arrays; k++) {
              _ij = utils.parseNumber(arguments[k - 1][i][j]);
              if (_ij instanceof Error) {
                return _ij;
              }
              product *= _ij;
            }
            result += product;
          }
        }
      }
      return result;
    };
    exports.SUMSQ = function() {
      var numbers = utils.parseNumberArray(utils.flatten(arguments));
      if (numbers instanceof Error) {
        return numbers;
      }
      var result = 0;
      var length = numbers.length;
      for (var i = 0; i < length; i++) {
        result += information.ISNUMBER(numbers[i]) ? numbers[i] * numbers[i] : 0;
      }
      return result;
    };
    exports.SUMX2MY2 = function(array_x, array_y) {
      array_x = utils.parseNumberArray(utils.flatten(array_x));
      array_y = utils.parseNumberArray(utils.flatten(array_y));
      if (utils.anyIsError(array_x, array_y)) {
        return error2.value;
      }
      var result = 0;
      for (var i = 0; i < array_x.length; i++) {
        result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
      }
      return result;
    };
    exports.SUMX2PY2 = function(array_x, array_y) {
      array_x = utils.parseNumberArray(utils.flatten(array_x));
      array_y = utils.parseNumberArray(utils.flatten(array_y));
      if (utils.anyIsError(array_x, array_y)) {
        return error2.value;
      }
      var result = 0;
      array_x = utils.parseNumberArray(utils.flatten(array_x));
      array_y = utils.parseNumberArray(utils.flatten(array_y));
      for (var i = 0; i < array_x.length; i++) {
        result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
      }
      return result;
    };
    exports.SUMXMY2 = function(array_x, array_y) {
      array_x = utils.parseNumberArray(utils.flatten(array_x));
      array_y = utils.parseNumberArray(utils.flatten(array_y));
      if (utils.anyIsError(array_x, array_y)) {
        return error2.value;
      }
      var result = 0;
      array_x = utils.flatten(array_x);
      array_y = utils.flatten(array_y);
      for (var i = 0; i < array_x.length; i++) {
        result += Math.pow(array_x[i] - array_y[i], 2);
      }
      return result;
    };
    exports.TAN = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return Math.tan(number);
    };
    exports.TANH = function(number) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var e2 = Math.exp(2 * number);
      return (e2 - 1) / (e2 + 1);
    };
    exports.TRUNC = function(number, digits) {
      digits = digits === void 0 ? 0 : digits;
      number = utils.parseNumber(number);
      digits = utils.parseNumber(digits);
      if (utils.anyIsError(number, digits)) {
        return error2.value;
      }
      var sign = number > 0 ? 1 : -1;
      return sign * Math.floor(Math.abs(number) * Math.pow(10, digits)) / Math.pow(10, digits);
    };
  }
});

// ../../node_modules/bessel/bessel.js
var require_bessel = __commonJS({
  "../../node_modules/bessel/bessel.js"(exports) {
    var BESSEL;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_BESSEL === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(BESSEL = {});
        }
      } else {
        factory(BESSEL = {});
      }
    })(function(BESSEL2) {
      BESSEL2.version = "1.0.2";
      var M = Math;
      function _horner(arr, v) {
        for (var i = 0, z = 0; i < arr.length; ++i) z = v * z + arr[i];
        return z;
      }
      function _bessel_iter(x, n, f0, f1, sign) {
        if (n === 0) return f0;
        if (n === 1) return f1;
        var tdx = 2 / x, f2 = f1;
        for (var o3 = 1; o3 < n; ++o3) {
          f2 = f1 * o3 * tdx + sign * f0;
          f0 = f1;
          f1 = f2;
        }
        return f2;
      }
      function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
        return function bessel(x, n) {
          if (nonzero) {
            if (x === 0) return nonzero == 1 ? -Infinity : Infinity;
            else if (x < 0) return NaN;
          }
          if (n === 0) return bessel0(x);
          if (n === 1) return bessel1(x);
          if (n < 0) return NaN;
          n |= 0;
          var b0 = bessel0(x), b1 = bessel1(x);
          return _bessel_iter(x, n, b0, b1, sign);
        };
      }
      var besselj = function() {
        var W = 0.636619772;
        var b0_a1a = [57568490574, -13362590354, 6516196407e-1, -1121442418e-2, 77392.33017, -184.9052456].reverse();
        var b0_a2a = [57568490411, 1029532985, 9494680718e-3, 59272.64853, 267.8532712, 1].reverse();
        var b0_a1b = [1, -0.001098628627, 2734510407e-14, -2073370639e-15, 2093887211e-16].reverse();
        var b0_a2b = [-0.01562499995, 1430488765e-13, -6911147651e-15, 7621095161e-16, -934935152e-16].reverse();
        function bessel0(x) {
          var a = 0, a1 = 0, a2 = 0, y = x * x;
          if (x < 8) {
            a1 = _horner(b0_a1a, y);
            a2 = _horner(b0_a2a, y);
            a = a1 / a2;
          } else {
            var xx = x - 0.785398164;
            y = 64 / y;
            a1 = _horner(b0_a1b, y);
            a2 = _horner(b0_a2b, y);
            a = M.sqrt(W / x) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / x);
          }
          return a;
        }
        var b1_a1a = [72362614232, -7895059235, 2423968531e-1, -2972611439e-3, 15704.4826, -30.16036606].reverse();
        var b1_a2a = [144725228442, 2300535178, 1858330474e-2, 99447.43394, 376.9991397, 1].reverse();
        var b1_a1b = [1, 183105e-8, -3516396496e-14, 2457520174e-15, -240337019e-15].reverse();
        var b1_a2b = [0.04687499995, -2002690873e-13, 8449199096e-15, -88228987e-14, 105787412e-15].reverse();
        function bessel1(x) {
          var a = 0, a1 = 0, a2 = 0, y = x * x, xx = M.abs(x) - 2.356194491;
          if (Math.abs(x) < 8) {
            a1 = x * _horner(b1_a1a, y);
            a2 = _horner(b1_a2a, y);
            a = a1 / a2;
          } else {
            y = 64 / y;
            a1 = _horner(b1_a1b, y);
            a2 = _horner(b1_a2b, y);
            a = M.sqrt(W / M.abs(x)) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / M.abs(x));
            if (x < 0) a = -a;
          }
          return a;
        }
        return function besselj2(x, n) {
          n = Math.round(n);
          if (!isFinite(x)) return isNaN(x) ? x : 0;
          if (n < 0) return (n % 2 ? -1 : 1) * besselj2(x, -n);
          if (x < 0) return (n % 2 ? -1 : 1) * besselj2(-x, n);
          if (n === 0) return bessel0(x);
          if (n === 1) return bessel1(x);
          if (x === 0) return 0;
          var ret = 0;
          if (x > n) {
            ret = _bessel_iter(x, n, bessel0(x), bessel1(x), -1);
          } else {
            var m = 2 * M.floor((n + M.floor(M.sqrt(40 * n))) / 2);
            var jsum = false;
            var bjp = 0, sum = 0;
            var bj = 1, bjm = 0;
            var tox = 2 / x;
            for (var j = m; j > 0; j--) {
              bjm = j * tox * bj - bjp;
              bjp = bj;
              bj = bjm;
              if (M.abs(bj) > 1e10) {
                bj *= 1e-10;
                bjp *= 1e-10;
                ret *= 1e-10;
                sum *= 1e-10;
              }
              if (jsum) sum += bj;
              jsum = !jsum;
              if (j == n) ret = bjp;
            }
            sum = 2 * sum - bj;
            ret /= sum;
          }
          return ret;
        };
      }();
      var bessely = function() {
        var W = 0.636619772;
        var b0_a1a = [-2957821389, 7062834065, -5123598036e-1, 1087988129e-2, -86327.92757, 228.4622733].reverse();
        var b0_a2a = [40076544269, 7452499648e-1, 7189466438e-3, 47447.2647, 226.1030244, 1].reverse();
        var b0_a1b = [1, -0.001098628627, 2734510407e-14, -2073370639e-15, 2093887211e-16].reverse();
        var b0_a2b = [-0.01562499995, 1430488765e-13, -6911147651e-15, 7621095161e-16, -934945152e-16].reverse();
        function bessel0(x) {
          var a = 0, a1 = 0, a2 = 0, y = x * x, xx = x - 0.785398164;
          if (x < 8) {
            a1 = _horner(b0_a1a, y);
            a2 = _horner(b0_a2a, y);
            a = a1 / a2 + W * besselj(x, 0) * M.log(x);
          } else {
            y = 64 / y;
            a1 = _horner(b0_a1b, y);
            a2 = _horner(b0_a2b, y);
            a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
          }
          return a;
        }
        var b1_a1a = [-4900604943e3, 127527439e4, -51534381390, 7349264551e-1, -4237922726e-3, 8511.937935].reverse();
        var b1_a2a = [249958057e5, 424441966400, 3733650367, 2245904002e-2, 102042.605, 354.9632885, 1].reverse();
        var b1_a1b = [1, 183105e-8, -3516396496e-14, 2457520174e-15, -240337019e-15].reverse();
        var b1_a2b = [0.04687499995, -2002690873e-13, 8449199096e-15, -88228987e-14, 105787412e-15].reverse();
        function bessel1(x) {
          var a = 0, a1 = 0, a2 = 0, y = x * x, xx = x - 2.356194491;
          if (x < 8) {
            a1 = x * _horner(b1_a1a, y);
            a2 = _horner(b1_a2a, y);
            a = a1 / a2 + W * (besselj(x, 1) * M.log(x) - 1 / x);
          } else {
            y = 64 / y;
            a1 = _horner(b1_a1b, y);
            a2 = _horner(b1_a2b, y);
            a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
          }
          return a;
        }
        return _bessel_wrap(bessel0, bessel1, "BESSELY", 1, -1);
      }();
      var besseli = function() {
        var b0_a = [1, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.0360768, 45813e-7].reverse();
        var b0_b = [0.39894228, 0.01328592, 225319e-8, -157565e-8, 916281e-8, -0.02057706, 0.02635537, -0.01647633, 392377e-8].reverse();
        function bessel0(x) {
          if (x <= 3.75) return _horner(b0_a, x * x / (3.75 * 3.75));
          return M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b0_b, 3.75 / M.abs(x));
        }
        var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.02658733, 301532e-8, 32411e-8].reverse();
        var b1_b = [0.39894228, -0.03988024, -362018e-8, 163801e-8, -0.01031555, 0.02282967, -0.02895312, 0.01787654, -420059e-8].reverse();
        function bessel1(x) {
          if (x < 3.75) return x * _horner(b1_a, x * x / (3.75 * 3.75));
          return (x < 0 ? -1 : 1) * M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b1_b, 3.75 / M.abs(x));
        }
        return function besseli2(x, n) {
          n = Math.round(n);
          if (n === 0) return bessel0(x);
          if (n === 1) return bessel1(x);
          if (n < 0) return NaN;
          if (M.abs(x) === 0) return 0;
          if (x == Infinity) return Infinity;
          var ret = 0, j, tox = 2 / M.abs(x), bip = 0, bi = 1, bim = 0;
          var m = 2 * M.round((n + M.round(M.sqrt(40 * n))) / 2);
          for (j = m; j > 0; j--) {
            bim = j * tox * bi + bip;
            bip = bi;
            bi = bim;
            if (M.abs(bi) > 1e10) {
              bi *= 1e-10;
              bip *= 1e-10;
              ret *= 1e-10;
            }
            if (j == n) ret = bip;
          }
          ret *= besseli2(x, 0) / bi;
          return x < 0 && n % 2 ? -ret : ret;
        };
      }();
      var besselk = function() {
        var b0_a = [-0.57721566, 0.4227842, 0.23069756, 0.0348859, 262698e-8, 1075e-7, 74e-7].reverse();
        var b0_b = [1.25331414, -0.07832358, 0.02189568, -0.01062446, 587872e-8, -25154e-7, 53208e-8].reverse();
        function bessel0(x) {
          if (x <= 2) return -M.log(x / 2) * besseli(x, 0) + _horner(b0_a, x * x / 4);
          return M.exp(-x) / M.sqrt(x) * _horner(b0_b, 2 / x);
        }
        var b1_a = [1, 0.15443144, -0.67278579, -0.18156897, -0.01919402, -110404e-8, -4686e-8].reverse();
        var b1_b = [1.25331414, 0.23498619, -0.0365562, 0.01504268, -780353e-8, 325614e-8, -68245e-8].reverse();
        function bessel1(x) {
          if (x <= 2) return M.log(x / 2) * besseli(x, 1) + 1 / x * _horner(b1_a, x * x / 4);
          return M.exp(-x) / M.sqrt(x) * _horner(b1_b, 2 / x);
        }
        return _bessel_wrap(bessel0, bessel1, "BESSELK", 2, 1);
      }();
      BESSEL2.besselj = besselj;
      BESSEL2.bessely = bessely;
      BESSEL2.besseli = besseli;
      BESSEL2.besselk = besselk;
    });
  }
});

// ../../node_modules/@handsontable/formulajs/lib/engineering.js
var require_engineering = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/engineering.js"(exports) {
    var error2 = require_error();
    var jStat = require_jstat();
    var text = require_text();
    var utils = require_common();
    var bessel = require_bessel();
    function isValidBinaryNumber(number) {
      return /^[01]{1,10}$/.test(number);
    }
    exports.BESSELI = function(x, n) {
      x = utils.parseNumber(x);
      n = utils.parseNumber(n);
      if (utils.anyIsError(x, n)) {
        return error2.value;
      }
      return bessel.besseli(x, n);
    };
    exports.BESSELJ = function(x, n) {
      x = utils.parseNumber(x);
      n = utils.parseNumber(n);
      if (utils.anyIsError(x, n)) {
        return error2.value;
      }
      return bessel.besselj(x, n);
    };
    exports.BESSELK = function(x, n) {
      x = utils.parseNumber(x);
      n = utils.parseNumber(n);
      if (utils.anyIsError(x, n)) {
        return error2.value;
      }
      return bessel.besselk(x, n);
    };
    exports.BESSELY = function(x, n) {
      x = utils.parseNumber(x);
      n = utils.parseNumber(n);
      if (utils.anyIsError(x, n)) {
        return error2.value;
      }
      return bessel.bessely(x, n);
    };
    exports.BIN2DEC = function(number) {
      if (!isValidBinaryNumber(number)) {
        return error2.num;
      }
      var result = parseInt(number, 2);
      var stringified = number.toString();
      if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
        return parseInt(stringified.substring(1), 2) - 512;
      } else {
        return result;
      }
    };
    exports.BIN2HEX = function(number, places) {
      if (!isValidBinaryNumber(number)) {
        return error2.num;
      }
      var stringified = number.toString();
      if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
        return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
      }
      var result = parseInt(number, 2).toString(16);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.BIN2OCT = function(number, places) {
      if (!isValidBinaryNumber(number)) {
        return error2.num;
      }
      var stringified = number.toString();
      if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
        return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
      }
      var result = parseInt(number, 2).toString(8);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.BITAND = function(number1, number2) {
      number1 = utils.parseNumber(number1);
      number2 = utils.parseNumber(number2);
      if (utils.anyIsError(number1, number2)) {
        return error2.value;
      }
      if (number1 < 0 || number2 < 0) {
        return error2.num;
      }
      if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
        return error2.num;
      }
      if (number1 > 281474976710655 || number2 > 281474976710655) {
        return error2.num;
      }
      return number1 & number2;
    };
    exports.BITLSHIFT = function(number, shift) {
      number = utils.parseNumber(number);
      shift = utils.parseNumber(shift);
      if (utils.anyIsError(number, shift)) {
        return error2.value;
      }
      if (number < 0) {
        return error2.num;
      }
      if (Math.floor(number) !== number) {
        return error2.num;
      }
      if (number > 281474976710655) {
        return error2.num;
      }
      if (Math.abs(shift) > 53) {
        return error2.num;
      }
      return shift >= 0 ? number << shift : number >> -shift;
    };
    exports.BITOR = function(number1, number2) {
      number1 = utils.parseNumber(number1);
      number2 = utils.parseNumber(number2);
      if (utils.anyIsError(number1, number2)) {
        return error2.value;
      }
      if (number1 < 0 || number2 < 0) {
        return error2.num;
      }
      if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
        return error2.num;
      }
      if (number1 > 281474976710655 || number2 > 281474976710655) {
        return error2.num;
      }
      return number1 | number2;
    };
    exports.BITRSHIFT = function(number, shift) {
      number = utils.parseNumber(number);
      shift = utils.parseNumber(shift);
      if (utils.anyIsError(number, shift)) {
        return error2.value;
      }
      if (number < 0) {
        return error2.num;
      }
      if (Math.floor(number) !== number) {
        return error2.num;
      }
      if (number > 281474976710655) {
        return error2.num;
      }
      if (Math.abs(shift) > 53) {
        return error2.num;
      }
      return shift >= 0 ? number >> shift : number << -shift;
    };
    exports.BITXOR = function(number1, number2) {
      number1 = utils.parseNumber(number1);
      number2 = utils.parseNumber(number2);
      if (utils.anyIsError(number1, number2)) {
        return error2.value;
      }
      if (number1 < 0 || number2 < 0) {
        return error2.num;
      }
      if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
        return error2.num;
      }
      if (number1 > 281474976710655 || number2 > 281474976710655) {
        return error2.num;
      }
      return number1 ^ number2;
    };
    exports.COMPLEX = function(real, imaginary, suffix) {
      real = utils.parseNumber(real);
      imaginary = utils.parseNumber(imaginary);
      if (utils.anyIsError(real, imaginary)) {
        return real;
      }
      suffix = suffix === void 0 ? "i" : suffix;
      if (suffix !== "i" && suffix !== "j") {
        return error2.value;
      }
      if (real === 0 && imaginary === 0) {
        return 0;
      } else if (real === 0) {
        return imaginary === 1 ? suffix : imaginary.toString() + suffix;
      } else if (imaginary === 0) {
        return real.toString();
      } else {
        var sign = imaginary > 0 ? "+" : "";
        return real.toString() + sign + (imaginary === 1 ? suffix : imaginary.toString() + suffix);
      }
    };
    exports.CONVERT = function(number, from_unit, to_unit) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var units = [
        ["a.u. of action", "?", null, "action", false, false, 105457168181818e-48],
        ["a.u. of charge", "e", null, "electric_charge", false, false, 160217653141414e-33],
        ["a.u. of energy", "Eh", null, "energy", false, false, 435974417757576e-32],
        ["a.u. of length", "a?", null, "length", false, false, 529177210818182e-25],
        ["a.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
        ["a.u. of time", "?/Eh", null, "time", false, false, 241888432650516e-31],
        ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
        ["ampere", "A", null, "electric_current", true, false, 1],
        ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
        ["ngstrm", "", ["ang"], "length", false, true, 1e-10],
        ["are", "ar", null, "area", false, true, 100],
        ["astronomical unit", "ua", null, "length", false, false, 149597870691667e-25],
        ["bar", "bar", null, "pressure", false, false, 1e5],
        ["barn", "b", null, "area", false, false, 1e-28],
        ["becquerel", "Bq", null, "radioactivity", true, false, 1],
        ["bit", "bit", ["b"], "information", false, true, 1],
        ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
        ["byte", "byte", null, "information", false, true, 8],
        ["candela", "cd", null, "luminous_intensity", true, false, 1],
        ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
        ["coulomb", "C", null, "electric_charge", true, false, 1],
        ["cubic ngstrm", "ang3", ["ang^3"], "volume", false, true, 1e-30],
        ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
        ["cubic inch", "in3", ["in^3"], "volume", false, true, 16387064e-12],
        ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 846786664623715e-61],
        ["cubic metre", "m?", null, "volume", true, true, 1],
        ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 416818182544058e-5],
        ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
        ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 758660370370369e-22],
        ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
        ["cup", "cup", null, "volume", false, true, 2365882365e-13],
        ["dalton", "Da", ["u"], "mass", false, false, 166053886282828e-41],
        ["day", "d", ["day"], "time", false, true, 86400],
        ["degree", "", null, "angle", false, false, 0.0174532925199433],
        ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
        ["dyne", "dyn", ["dy"], "force", false, true, 1e-5],
        ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
        ["ell", "ell", null, "length", false, true, 1.143],
        ["erg", "erg", ["e"], "energy", false, true, 1e-7],
        ["farad", "F", null, "electric_capacitance", true, false, 1],
        ["fluid ounce", "oz", null, "volume", false, true, 295735295625e-16],
        ["foot", "ft", null, "length", false, true, 0.3048],
        ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
        ["gal", "Gal", null, "acceleration", false, false, 0.01],
        ["gallon", "gal", null, "volume", false, true, 0.003785411784],
        ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
        ["grain", "grain", null, "mass", false, true, 647989e-10],
        ["gram", "g", null, "mass", false, true, 1e-3],
        ["gray", "Gy", null, "absorbed_dose", true, false, 1],
        ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
        ["hectare", "ha", null, "area", false, true, 1e4],
        ["henry", "H", null, "inductance", true, false, 1],
        ["hertz", "Hz", null, "frequency", true, false, 1],
        ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
        ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519538e-3],
        ["hour", "h", ["hr"], "time", false, true, 3600],
        ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 454609e-8],
        ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
        ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
        ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
        ["inch", "in", null, "length", false, true, 0.0254],
        ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
        ["IT calorie", "cal", null, "energy", false, true, 4.1868],
        ["joule", "J", null, "energy", true, true, 1],
        ["katal", "kat", null, "catalytic_activity", true, false, 1],
        ["kelvin", "K", ["kel"], "temperature", true, true, 1],
        ["kilogram", "kg", null, "mass", true, true, 1],
        ["knot", "kn", null, "speed", false, true, 0.514444444444444],
        ["light-year", "ly", null, "length", false, true, 9460730472580800],
        ["litre", "L", ["l", "lt"], "volume", false, true, 1e-3],
        ["lumen", "lm", null, "luminous_flux", true, false, 1],
        ["lux", "lx", null, "illuminance", true, false, 1],
        ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
        ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
        ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 27777777777778e-17],
        ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
        ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
        ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
        ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
        ["metre", "m", null, "length", true, true, 1],
        ["miles per hour", "mph", null, "speed", false, true, 0.44704],
        ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
        ["minute", "?", null, "angle", false, false, 290888208665722e-18],
        ["minute", "min", ["mn"], "time", false, true, 60],
        ["modern teaspoon", "tspm", null, "volume", false, true, 5e-6],
        ["mole", "mol", null, "amount_of_substance", true, false, 1],
        ["morgen", "Morgen", null, "area", false, true, 2500],
        ["n.u. of action", "?", null, "action", false, false, 105457168181818e-48],
        ["n.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
        ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
        ["n.u. of time", "?/(me?c??)", null, "time", false, false, 128808866778687e-35],
        ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
        ["newton", "N", null, "force", true, true, 1],
        ["rsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
        ["ohm", "", null, "electric_resistance", true, false, 1],
        ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
        ["pascal", "Pa", null, "pressure", true, false, 1],
        ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
        ["pferdestrke", "PS", null, "power", false, true, 735.49875],
        ["phot", "ph", null, "illuminance", false, false, 1e-4],
        ["pica (1/6 inch)", "pica", null, "length", false, true, 35277777777778e-17],
        ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
        ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
        ["pond", "pond", null, "force", false, true, 980665e-8],
        ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
        ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
        ["quart", "qt", null, "volume", false, true, 946352946e-12],
        ["radian", "rad", null, "angle", true, false, 1],
        ["second", "?", null, "angle", false, false, 484813681109536e-20],
        ["second", "s", ["sec"], "time", true, true, 1],
        ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
        ["siemens", "S", null, "electrical_conductance", true, false, 1],
        ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
        ["slug", "sg", null, "mass", false, true, 14.59390294],
        ["square ngstrm", "ang2", ["ang^2"], "area", false, true, 1e-20],
        ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
        ["square inch", "in2", ["in^2"], "area", false, true, 64516e-8],
        ["square light-year", "ly2", ["ly^2"], "area", false, true, 895054210748189e17],
        ["square meter", "m?", null, "area", true, true, 1],
        ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988110336e-6],
        ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
        ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 1792111111111e-17],
        ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
        ["statute mile", "mi", null, "length", false, true, 1609.344],
        ["steradian", "sr", null, "solid_angle", true, false, 1],
        ["stilb", "sb", null, "luminance", false, false, 1e-4],
        ["stokes", "St", null, "kinematic_viscosity", false, false, 1e-4],
        ["stone", "stone", null, "mass", false, true, 6.35029318],
        ["tablespoon", "tbs", null, "volume", false, true, 147868e-10],
        ["teaspoon", "tsp", null, "volume", false, true, 492892e-11],
        ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
        ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
        ["ton", "ton", null, "mass", false, true, 907.18474],
        ["tonne", "t", null, "mass", false, false, 1e3],
        ["U.K. pint", "uk_pt", null, "volume", false, true, 56826125e-11],
        ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
        ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
        ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 473176473e-12],
        ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
        ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
        ["volt", "V", null, "voltage", true, false, 1],
        ["watt", "W", null, "power", true, true, 1],
        ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
        ["weber", "Wb", null, "magnetic_flux", true, false, 1],
        ["yard", "yd", null, "length", false, true, 0.9144],
        ["year", "yr", null, "time", false, true, 31557600]
      ];
      var binary_prefixes = {
        Yi: ["yobi", 80, 12089258196146292e8, "Yi", "yotta"],
        Zi: ["zebi", 70, 11805916207174113e5, "Zi", "zetta"],
        Ei: ["exbi", 60, 1152921504606847e3, "Ei", "exa"],
        Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
        Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
        Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
        Mi: ["mebi", 20, 1048576, "Mi", "mega"],
        ki: ["kibi", 10, 1024, "ki", "kilo"]
      };
      var unit_prefixes = {
        Y: ["yotta", 1e24, "Y"],
        Z: ["zetta", 1e21, "Z"],
        E: ["exa", 1e18, "E"],
        P: ["peta", 1e15, "P"],
        T: ["tera", 1e12, "T"],
        G: ["giga", 1e9, "G"],
        M: ["mega", 1e6, "M"],
        k: ["kilo", 1e3, "k"],
        h: ["hecto", 100, "h"],
        e: ["dekao", 10, "e"],
        d: ["deci", 0.1, "d"],
        c: ["centi", 0.01, "c"],
        m: ["milli", 1e-3, "m"],
        u: ["micro", 1e-6, "u"],
        n: ["nano", 1e-9, "n"],
        p: ["pico", 1e-12, "p"],
        f: ["femto", 1e-15, "f"],
        a: ["atto", 1e-18, "a"],
        z: ["zepto", 1e-21, "z"],
        y: ["yocto", 1e-24, "y"]
      };
      var from = null;
      var to = null;
      var base_from_unit = from_unit;
      var base_to_unit = to_unit;
      var from_multiplier = 1;
      var to_multiplier = 1;
      var alt;
      for (var i = 0; i < units.length; i++) {
        alt = units[i][2] === null ? [] : units[i][2];
        if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
          from = units[i];
        }
        if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
          to = units[i];
        }
      }
      if (from === null) {
        var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
        var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];
        if (from_unit.substring(0, 2) === "da") {
          from_unit_prefix = ["dekao", 10, "da"];
        }
        if (from_binary_prefix) {
          from_multiplier = from_binary_prefix[2];
          base_from_unit = from_unit.substring(2);
        } else if (from_unit_prefix) {
          from_multiplier = from_unit_prefix[1];
          base_from_unit = from_unit.substring(from_unit_prefix[2].length);
        }
        for (var j = 0; j < units.length; j++) {
          alt = units[j][2] === null ? [] : units[j][2];
          if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
            from = units[j];
          }
        }
      }
      if (to === null) {
        var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
        var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];
        if (to_unit.substring(0, 2) === "da") {
          to_unit_prefix = ["dekao", 10, "da"];
        }
        if (to_binary_prefix) {
          to_multiplier = to_binary_prefix[2];
          base_to_unit = to_unit.substring(2);
        } else if (to_unit_prefix) {
          to_multiplier = to_unit_prefix[1];
          base_to_unit = to_unit.substring(to_unit_prefix[2].length);
        }
        for (var k = 0; k < units.length; k++) {
          alt = units[k][2] === null ? [] : units[k][2];
          if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
            to = units[k];
          }
        }
      }
      if (from === null || to === null) {
        return error2.na;
      }
      if (from[3] !== to[3]) {
        return error2.na;
      }
      return number * from[6] * from_multiplier / (to[6] * to_multiplier);
    };
    exports.DEC2BIN = function(number, places) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
        return error2.num;
      }
      if (number < 0) {
        return "1" + text.REPT("0", 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
      }
      var result = parseInt(number, 10).toString(2);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.DEC2HEX = function(number, places) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
        return error2.num;
      }
      if (number < 0) {
        return (1099511627776 + number).toString(16);
      }
      var result = parseInt(number, 10).toString(16);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.DEC2OCT = function(number, places) {
      number = utils.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
        return error2.num;
      }
      if (number < 0) {
        return (1073741824 + number).toString(8);
      }
      var result = parseInt(number, 10).toString(8);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.DELTA = function(number1, number2) {
      number2 = number2 === void 0 ? 0 : number2;
      number1 = utils.parseNumber(number1);
      number2 = utils.parseNumber(number2);
      if (utils.anyIsError(number1, number2)) {
        return error2.value;
      }
      return number1 === number2 ? 1 : 0;
    };
    exports.ERF = function(lower_bound, upper_bound) {
      upper_bound = upper_bound === void 0 ? 0 : upper_bound;
      lower_bound = utils.parseNumber(lower_bound);
      upper_bound = utils.parseNumber(upper_bound);
      if (utils.anyIsError(lower_bound, upper_bound)) {
        return error2.value;
      }
      return jStat.erf(lower_bound);
    };
    exports.ERF.PRECISE = function() {
      throw new Error("ERF.PRECISE is not implemented");
    };
    exports.ERFC = function(x) {
      if (isNaN(x)) {
        return error2.value;
      }
      return jStat.erfc(x);
    };
    exports.ERFC.PRECISE = function() {
      throw new Error("ERFC.PRECISE is not implemented");
    };
    exports.GESTEP = function(number, step) {
      step = step || 0;
      number = utils.parseNumber(number);
      if (utils.anyIsError(step, number)) {
        return number;
      }
      return number >= step ? 1 : 0;
    };
    exports.HEX2BIN = function(number, places) {
      if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
        return error2.num;
      }
      var negative = number.length === 10 && number.substring(0, 1).toLowerCase() === "f" ? true : false;
      var decimal = negative ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);
      if (decimal < -512 || decimal > 511) {
        return error2.num;
      }
      if (negative) {
        return "1" + text.REPT("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
      }
      var result = decimal.toString(2);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.HEX2DEC = function(number) {
      if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 16);
      return decimal >= 549755813888 ? decimal - 1099511627776 : decimal;
    };
    exports.HEX2OCT = function(number, places) {
      if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 16);
      if (decimal > 536870911 && decimal < 1098974756864) {
        return error2.num;
      }
      if (decimal >= 1098974756864) {
        return (decimal - 1098437885952).toString(8);
      }
      var result = decimal.toString(8);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.IMABS = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };
    exports.IMAGINARY = function(inumber) {
      if (inumber === void 0 || inumber === true || inumber === false) {
        return error2.value;
      }
      if (inumber === 0 || inumber === "0") {
        return 0;
      }
      if (["i", "j"].indexOf(inumber) >= 0) {
        return 1;
      }
      inumber = inumber.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
      var plus = inumber.indexOf("+");
      var minus = inumber.indexOf("-");
      if (plus === 0) {
        plus = inumber.indexOf("+", 1);
      }
      if (minus === 0) {
        minus = inumber.indexOf("-", 1);
      }
      var last = inumber.substring(inumber.length - 1, inumber.length);
      var unit = last === "i" || last === "j";
      if (plus >= 0 || minus >= 0) {
        if (!unit) {
          return error2.num;
        }
        if (plus >= 0) {
          return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? error2.num : Number(inumber.substring(plus + 1, inumber.length - 1));
        } else {
          return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? error2.num : -Number(inumber.substring(minus + 1, inumber.length - 1));
        }
      } else {
        if (unit) {
          return isNaN(inumber.substring(0, inumber.length - 1)) ? error2.num : inumber.substring(0, inumber.length - 1);
        } else {
          return isNaN(inumber) ? error2.num : 0;
        }
      }
    };
    exports.IMARGUMENT = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      if (x === 0 && y === 0) {
        return error2.div0;
      }
      if (x === 0 && y > 0) {
        return Math.PI / 2;
      }
      if (x === 0 && y < 0) {
        return -Math.PI / 2;
      }
      if (y === 0 && x > 0) {
        return 0;
      }
      if (y === 0 && x < 0) {
        return -Math.PI;
      }
      if (x > 0) {
        return Math.atan(y / x);
      } else if (x < 0 && y >= 0) {
        return Math.atan(y / x) + Math.PI;
      } else {
        return Math.atan(y / x) - Math.PI;
      }
    };
    exports.IMCONJUGATE = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return y !== 0 ? exports.COMPLEX(x, -y, unit) : inumber;
    };
    exports.IMCOS = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
    };
    exports.IMCOSH = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
    };
    exports.IMCOT = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));
    };
    exports.IMDIV = function(inumber1, inumber2) {
      var a = exports.IMREAL(inumber1);
      var b = exports.IMAGINARY(inumber1);
      var c = exports.IMREAL(inumber2);
      var d = exports.IMAGINARY(inumber2);
      if (utils.anyIsError(a, b, c, d)) {
        return error2.value;
      }
      var unit1 = inumber1.substring(inumber1.length - 1);
      var unit2 = inumber2.substring(inumber2.length - 1);
      var unit = "i";
      if (unit1 === "j") {
        unit = "j";
      } else if (unit2 === "j") {
        unit = "j";
      }
      if (c === 0 && d === 0) {
        return error2.num;
      }
      var den = c * c + d * d;
      return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
    };
    exports.IMEXP = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      var e = Math.exp(x);
      return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
    };
    exports.IMLN = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
    };
    exports.IMLOG10 = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
    };
    exports.IMLOG2 = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
    };
    exports.IMPOWER = function(inumber, number) {
      number = utils.parseNumber(number);
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(number, x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      var p = Math.pow(exports.IMABS(inumber), number);
      var t = exports.IMARGUMENT(inumber);
      return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);
    };
    exports.IMPRODUCT = function() {
      var result = arguments[0];
      if (!arguments.length) {
        return error2.value;
      }
      for (var i = 1; i < arguments.length; i++) {
        var a = exports.IMREAL(result);
        var b = exports.IMAGINARY(result);
        var c = exports.IMREAL(arguments[i]);
        var d = exports.IMAGINARY(arguments[i]);
        if (utils.anyIsError(a, b, c, d)) {
          return error2.value;
        }
        result = exports.COMPLEX(a * c - b * d, a * d + b * c);
      }
      return result;
    };
    exports.IMREAL = function(inumber) {
      if (inumber === void 0 || inumber === true || inumber === false) {
        return error2.value;
      }
      if (inumber === 0 || inumber === "0") {
        return 0;
      }
      if (["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(inumber) >= 0) {
        return 0;
      }
      var plus = inumber.indexOf("+");
      var minus = inumber.indexOf("-");
      if (plus === 0) {
        plus = inumber.indexOf("+", 1);
      }
      if (minus === 0) {
        minus = inumber.indexOf("-", 1);
      }
      var last = inumber.substring(inumber.length - 1, inumber.length);
      var unit = last === "i" || last === "j";
      if (plus >= 0 || minus >= 0) {
        if (!unit) {
          return error2.num;
        }
        if (plus >= 0) {
          return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? error2.num : Number(inumber.substring(0, plus));
        } else {
          return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? error2.num : Number(inumber.substring(0, minus));
        }
      } else {
        if (unit) {
          return isNaN(inumber.substring(0, inumber.length - 1)) ? error2.num : 0;
        } else {
          return isNaN(inumber) ? error2.num : inumber;
        }
      }
    };
    exports.IMSEC = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      return exports.IMDIV("1", exports.IMCOS(inumber));
    };
    exports.IMSECH = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      return exports.IMDIV("1", exports.IMCOSH(inumber));
    };
    exports.IMSIN = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
    };
    exports.IMSINH = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
    };
    exports.IMSQRT = function(inumber) {
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      var s = Math.sqrt(exports.IMABS(inumber));
      var t = exports.IMARGUMENT(inumber);
      return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
    };
    exports.IMCSC = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.num;
      }
      return exports.IMDIV("1", exports.IMSIN(inumber));
    };
    exports.IMCSCH = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.num;
      }
      return exports.IMDIV("1", exports.IMSINH(inumber));
    };
    exports.IMSUB = function(inumber1, inumber2) {
      var a = this.IMREAL(inumber1);
      var b = this.IMAGINARY(inumber1);
      var c = this.IMREAL(inumber2);
      var d = this.IMAGINARY(inumber2);
      if (utils.anyIsError(a, b, c, d)) {
        return error2.value;
      }
      var unit1 = inumber1.substring(inumber1.length - 1);
      var unit2 = inumber2.substring(inumber2.length - 1);
      var unit = "i";
      if (unit1 === "j") {
        unit = "j";
      } else if (unit2 === "j") {
        unit = "j";
      }
      return this.COMPLEX(a - c, b - d, unit);
    };
    exports.IMSUM = function() {
      if (!arguments.length) {
        return error2.value;
      }
      var args = utils.flatten(arguments);
      var result = args[0];
      for (var i = 1; i < args.length; i++) {
        var a = this.IMREAL(result);
        var b = this.IMAGINARY(result);
        var c = this.IMREAL(args[i]);
        var d = this.IMAGINARY(args[i]);
        if (utils.anyIsError(a, b, c, d)) {
          return error2.value;
        }
        result = this.COMPLEX(a + c, b + d);
      }
      return result;
    };
    exports.IMTAN = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x = exports.IMREAL(inumber);
      var y = exports.IMAGINARY(inumber);
      if (utils.anyIsError(x, y)) {
        return error2.value;
      }
      return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
    };
    exports.OCT2BIN = function(number, places) {
      if (!/^[0-7]{1,10}$/.test(number)) {
        return error2.num;
      }
      var negative = number.length === 10 && number.substring(0, 1) === "7" ? true : false;
      var decimal = negative ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);
      if (decimal < -512 || decimal > 511) {
        return error2.num;
      }
      if (negative) {
        return "1" + text.REPT("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
      }
      var result = decimal.toString(2);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports.OCT2DEC = function(number) {
      if (!/^[0-7]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 8);
      return decimal >= 536870912 ? decimal - 1073741824 : decimal;
    };
    exports.OCT2HEX = function(number, places) {
      if (!/^[0-7]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 8);
      if (decimal >= 536870912) {
        return "ff" + (decimal + 3221225472).toString(16);
      }
      var result = decimal.toString(16);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text.REPT("0", places - result.length) + result : error2.num;
      }
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/date-time.js
var require_date_time = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/date-time.js"(exports) {
    var error2 = require_error();
    var utils = require_common();
    var d1900 = new Date(Date.UTC(1900, 0, 1));
    var WEEK_STARTS = [
      void 0,
      0,
      1,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      1,
      2,
      3,
      4,
      5,
      6,
      0
    ];
    var WEEK_TYPES = [
      [],
      [1, 2, 3, 4, 5, 6, 7],
      [7, 1, 2, 3, 4, 5, 6],
      [6, 0, 1, 2, 3, 4, 5],
      [],
      [],
      [],
      [],
      [],
      [],
      [],
      [7, 1, 2, 3, 4, 5, 6],
      [6, 7, 1, 2, 3, 4, 5],
      [5, 6, 7, 1, 2, 3, 4],
      [4, 5, 6, 7, 1, 2, 3],
      [3, 4, 5, 6, 7, 1, 2],
      [2, 3, 4, 5, 6, 7, 1],
      [1, 2, 3, 4, 5, 6, 7]
    ];
    var WEEKEND_TYPES = [
      [],
      [6, 0],
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 4],
      [4, 5],
      [5, 6],
      void 0,
      void 0,
      void 0,
      [0, 0],
      [1, 1],
      [2, 2],
      [3, 3],
      [4, 4],
      [5, 5],
      [6, 6]
    ];
    exports.DATE = function(year, month, day) {
      var result;
      year = utils.parseNumber(year);
      month = utils.parseNumber(month);
      day = utils.parseNumber(day);
      if (utils.anyIsError(year, month, day)) {
        result = error2.value;
      } else if (year < 0 || month < 0 || day < 0) {
        result = error2.num;
      } else {
        result = new Date(year, month - 1, day);
      }
      return result;
    };
    exports.DATEVALUE = function(date_text) {
      var modifier = 2;
      var date;
      if (typeof date_text !== "string") {
        return error2.value;
      }
      date = Date.parse(date_text);
      if (isNaN(date)) {
        return error2.value;
      }
      if (date <= -22038912e5) {
        modifier = 1;
      }
      return Math.ceil((date - d1900) / 864e5) + modifier;
    };
    exports.DAY = function(serial_number) {
      var date = utils.parseDate(serial_number);
      if (date instanceof Error) {
        return date;
      }
      return date.getDate();
    };
    exports.DAYS = function(end_date, start_date) {
      end_date = utils.parseDate(end_date);
      start_date = utils.parseDate(start_date);
      if (end_date instanceof Error) {
        return end_date;
      }
      if (start_date instanceof Error) {
        return start_date;
      }
      return serial(end_date) - serial(start_date);
    };
    exports.DAYS360 = function(start_date, end_date, method) {
      method = utils.parseBool(method);
      start_date = utils.parseDate(start_date);
      end_date = utils.parseDate(end_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      if (end_date instanceof Error) {
        return end_date;
      }
      if (method instanceof Error) {
        return method;
      }
      var sm = start_date.getMonth();
      var em = end_date.getMonth();
      var sd, ed;
      if (method) {
        sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
        ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
      } else {
        var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
        var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
        sd = start_date.getDate() === smd ? 30 : start_date.getDate();
        if (end_date.getDate() === emd) {
          if (sd < 30) {
            em++;
            ed = 1;
          } else {
            ed = 30;
          }
        } else {
          ed = end_date.getDate();
        }
      }
      return 360 * (end_date.getFullYear() - start_date.getFullYear()) + 30 * (em - sm) + (ed - sd);
    };
    exports.EDATE = function(start_date, months) {
      start_date = utils.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      if (isNaN(months)) {
        return error2.value;
      }
      months = parseInt(months, 10);
      start_date.setMonth(start_date.getMonth() + months);
      return serial(start_date);
    };
    exports.EOMONTH = function(start_date, months) {
      start_date = utils.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      if (isNaN(months)) {
        return error2.value;
      }
      months = parseInt(months, 10);
      return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
    };
    exports.HOUR = function(serial_number) {
      serial_number = utils.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getHours();
    };
    exports.INTERVAL = function(second) {
      if (typeof second !== "number" && typeof second !== "string") {
        return error2.value;
      } else {
        second = parseInt(second, 10);
      }
      var year = Math.floor(second / 94608e4);
      second = second % 94608e4;
      var month = Math.floor(second / 2592e3);
      second = second % 2592e3;
      var day = Math.floor(second / 86400);
      second = second % 86400;
      var hour = Math.floor(second / 3600);
      second = second % 3600;
      var min = Math.floor(second / 60);
      second = second % 60;
      var sec = second;
      year = year > 0 ? year + "Y" : "";
      month = month > 0 ? month + "M" : "";
      day = day > 0 ? day + "D" : "";
      hour = hour > 0 ? hour + "H" : "";
      min = min > 0 ? min + "M" : "";
      sec = sec > 0 ? sec + "S" : "";
      return "P" + year + month + day + "T" + hour + min + sec;
    };
    exports.ISOWEEKNUM = function(date) {
      date = utils.parseDate(date);
      if (date instanceof Error) {
        return date;
      }
      date.setHours(0, 0, 0);
      date.setDate(date.getDate() + 4 - (date.getDay() || 7));
      var yearStart = new Date(date.getFullYear(), 0, 1);
      return Math.ceil(((date - yearStart) / 864e5 + 1) / 7);
    };
    exports.MINUTE = function(serial_number) {
      serial_number = utils.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getMinutes();
    };
    exports.MONTH = function(serial_number) {
      serial_number = utils.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getMonth() + 1;
    };
    exports.NETWORKDAYS = function(start_date, end_date, holidays) {
      return this.NETWORKDAYS.INTL(start_date, end_date, 1, holidays);
    };
    exports.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
      start_date = utils.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      end_date = utils.parseDate(end_date);
      if (end_date instanceof Error) {
        return end_date;
      }
      if (weekend === void 0) {
        weekend = WEEKEND_TYPES[1];
      } else {
        weekend = WEEKEND_TYPES[weekend];
      }
      if (!(weekend instanceof Array)) {
        return error2.value;
      }
      if (holidays === void 0) {
        holidays = [];
      } else if (!(holidays instanceof Array)) {
        holidays = [holidays];
      }
      for (var i = 0; i < holidays.length; i++) {
        var h = utils.parseDate(holidays[i]);
        if (h instanceof Error) {
          return h;
        }
        holidays[i] = h;
      }
      var days = (end_date - start_date) / (1e3 * 60 * 60 * 24) + 1;
      var total = days;
      var day = start_date;
      for (i = 0; i < days; i++) {
        var d = (/* @__PURE__ */ new Date()).getTimezoneOffset() > 0 ? day.getUTCDay() : day.getDay();
        var dec = false;
        if (d === weekend[0] || d === weekend[1]) {
          dec = true;
        }
        for (var j = 0; j < holidays.length; j++) {
          var holiday = holidays[j];
          if (holiday.getDate() === day.getDate() && holiday.getMonth() === day.getMonth() && holiday.getFullYear() === day.getFullYear()) {
            dec = true;
            break;
          }
        }
        if (dec) {
          total--;
        }
        day.setDate(day.getDate() + 1);
      }
      return total;
    };
    exports.NOW = function() {
      return /* @__PURE__ */ new Date();
    };
    exports.SECOND = function(serial_number) {
      serial_number = utils.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getSeconds();
    };
    exports.TIME = function(hour, minute, second) {
      hour = utils.parseNumber(hour);
      minute = utils.parseNumber(minute);
      second = utils.parseNumber(second);
      if (utils.anyIsError(hour, minute, second)) {
        return error2.value;
      }
      if (hour < 0 || minute < 0 || second < 0) {
        return error2.num;
      }
      return (3600 * hour + 60 * minute + second) / 86400;
    };
    exports.TIMEVALUE = function(time_text) {
      time_text = utils.parseDate(time_text);
      if (time_text instanceof Error) {
        return time_text;
      }
      return (3600 * time_text.getHours() + 60 * time_text.getMinutes() + time_text.getSeconds()) / 86400;
    };
    exports.TODAY = function() {
      return /* @__PURE__ */ new Date();
    };
    exports.WEEKDAY = function(serial_number, return_type) {
      serial_number = utils.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      if (return_type === void 0) {
        return_type = 1;
      }
      var day = serial_number.getDay();
      return WEEK_TYPES[return_type][day];
    };
    exports.WEEKNUM = function(serial_number, return_type) {
      serial_number = utils.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      if (return_type === void 0) {
        return_type = 1;
      }
      if (return_type === 21) {
        return this.ISOWEEKNUM(serial_number);
      }
      var week_start = WEEK_STARTS[return_type];
      var jan = new Date(serial_number.getFullYear(), 0, 1);
      var inc = jan.getDay() < week_start ? 1 : 0;
      jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1e3;
      return Math.floor((serial_number - jan) / (1e3 * 60 * 60 * 24) / 7 + 1) + inc;
    };
    exports.WORKDAY = function(start_date, days, holidays) {
      return this.WORKDAY.INTL(start_date, days, 1, holidays);
    };
    exports.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
      start_date = utils.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      days = utils.parseNumber(days);
      if (days instanceof Error) {
        return days;
      }
      if (days < 0) {
        return error2.num;
      }
      if (weekend === void 0) {
        weekend = WEEKEND_TYPES[1];
      } else {
        weekend = WEEKEND_TYPES[weekend];
      }
      if (!(weekend instanceof Array)) {
        return error2.value;
      }
      if (holidays === void 0) {
        holidays = [];
      } else if (!(holidays instanceof Array)) {
        holidays = [holidays];
      }
      for (var i = 0; i < holidays.length; i++) {
        var h = utils.parseDate(holidays[i]);
        if (h instanceof Error) {
          return h;
        }
        holidays[i] = h;
      }
      var d = 0;
      while (d < days) {
        start_date.setDate(start_date.getDate() + 1);
        var day = start_date.getDay();
        if (day === weekend[0] || day === weekend[1]) {
          continue;
        }
        for (var j = 0; j < holidays.length; j++) {
          var holiday = holidays[j];
          if (holiday.getDate() === start_date.getDate() && holiday.getMonth() === start_date.getMonth() && holiday.getFullYear() === start_date.getFullYear()) {
            d--;
            break;
          }
        }
        d++;
      }
      return start_date;
    };
    exports.YEAR = function(serial_number) {
      serial_number = utils.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getFullYear();
    };
    function isLeapYear(year) {
      return new Date(year, 1, 29).getMonth() === 1;
    }
    function daysBetween(start_date, end_date) {
      return Math.ceil((end_date - start_date) / 1e3 / 60 / 60 / 24);
    }
    exports.YEARFRAC = function(start_date, end_date, basis) {
      start_date = utils.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      end_date = utils.parseDate(end_date);
      if (end_date instanceof Error) {
        return end_date;
      }
      basis = basis || 0;
      var sd = start_date.getDate();
      var sm = start_date.getMonth() + 1;
      var sy = start_date.getFullYear();
      var ed = end_date.getDate();
      var em = end_date.getMonth() + 1;
      var ey = end_date.getFullYear();
      switch (basis) {
        case 0:
          if (sd === 31 && ed === 31) {
            sd = 30;
            ed = 30;
          } else if (sd === 31) {
            sd = 30;
          } else if (sd === 30 && ed === 31) {
            ed = 30;
          }
          return (ed + em * 30 + ey * 360 - (sd + sm * 30 + sy * 360)) / 360;
        case 1:
          var feb29Between = function(date1, date2) {
            var year1 = date1.getFullYear();
            var mar1year1 = new Date(year1, 2, 1);
            if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
              return true;
            }
            var year2 = date2.getFullYear();
            var mar1year2 = new Date(year2, 2, 1);
            return isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2;
          };
          var ylength = 365;
          if (sy === ey || sy + 1 === ey && (sm > em || sm === em && sd >= ed)) {
            if (sy === ey && isLeapYear(sy) || feb29Between(start_date, end_date) || em === 1 && ed === 29) {
              ylength = 366;
            }
            return daysBetween(start_date, end_date) / ylength;
          }
          var years = ey - sy + 1;
          var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1e3 / 60 / 60 / 24;
          var average = days / years;
          return daysBetween(start_date, end_date) / average;
        case 2:
          return daysBetween(start_date, end_date) / 360;
        case 3:
          return daysBetween(start_date, end_date) / 365;
        case 4:
          return (ed + em * 30 + ey * 360 - (sd + sm * 30 + sy * 360)) / 360;
      }
    };
    function serial(date) {
      var addOn = date > -22038912e5 ? 2 : 1;
      return Math.ceil((date - d1900) / 864e5) + addOn;
    }
  }
});

// ../../node_modules/@handsontable/formulajs/lib/compatibility.js
var require_compatibility = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/compatibility.js"(exports) {
    var mathTrig = require_math_trig();
    var statistical = require_statistical();
    var engineering = require_engineering();
    var dateTime = require_date_time();
    function set(fn, root) {
      if (root) {
        for (var i in root) {
          fn[i] = root[i];
        }
      }
      return fn;
    }
    exports.BETADIST = statistical.BETA.DIST;
    exports.BETAINV = statistical.BETA.INV;
    exports.BINOMDIST = statistical.BINOM.DIST;
    exports.CEILING = exports.ISOCEILING = set(mathTrig.CEILING.MATH, mathTrig.CEILING);
    exports.CEILINGMATH = mathTrig.CEILING.MATH;
    exports.CEILINGPRECISE = mathTrig.CEILING.PRECISE;
    exports.CHIDIST = statistical.CHISQ.DIST;
    exports.CHIDISTRT = statistical.CHISQ.DIST.RT;
    exports.CHIINV = statistical.CHISQ.INV;
    exports.CHIINVRT = statistical.CHISQ.INV.RT;
    exports.CHITEST = statistical.CHISQ.TEST;
    exports.CONFIDENCE = set(statistical.CONFIDENCE.NORM, statistical.CONFIDENCE);
    exports.COVAR = statistical.COVARIANCE.P;
    exports.COVARIANCEP = statistical.COVARIANCE.P;
    exports.COVARIANCES = statistical.COVARIANCE.S;
    exports.CRITBINOM = statistical.BINOM.INV;
    exports.EXPONDIST = statistical.EXPON.DIST;
    exports.ERFCPRECISE = engineering.ERFC.PRECISE;
    exports.ERFPRECISE = engineering.ERF.PRECISE;
    exports.FDIST = statistical.F.DIST;
    exports.FDISTRT = statistical.F.DIST.RT;
    exports.FINVRT = statistical.F.INV.RT;
    exports.FINV = statistical.F.INV;
    exports.FLOOR = set(mathTrig.FLOOR.MATH, mathTrig.FLOOR);
    exports.FLOORMATH = mathTrig.FLOOR.MATH;
    exports.FLOORPRECISE = mathTrig.FLOOR.PRECISE;
    exports.FTEST = statistical.F.TEST;
    exports.GAMMADIST = statistical.GAMMA.DIST;
    exports.GAMMAINV = statistical.GAMMA.INV;
    exports.GAMMALNPRECISE = statistical.GAMMALN.PRECISE;
    exports.HYPGEOMDIST = statistical.HYPGEOM.DIST;
    exports.LOGINV = statistical.LOGNORM.INV;
    exports.LOGNORMINV = statistical.LOGNORM.INV;
    exports.LOGNORMDIST = statistical.LOGNORM.DIST;
    exports.MODE = set(statistical.MODE.SNGL, statistical.MODE);
    exports.MODEMULT = statistical.MODE.MULT;
    exports.MODESNGL = statistical.MODE.SNGL;
    exports.NEGBINOMDIST = statistical.NEGBINOM.DIST;
    exports.NETWORKDAYSINTL = dateTime.NETWORKDAYS.INTL;
    exports.NORMDIST = statistical.NORM.DIST;
    exports.NORMINV = statistical.NORM.INV;
    exports.NORMSDIST = statistical.NORM.S.DIST;
    exports.NORMSINV = statistical.NORM.S.INV;
    exports.PERCENTILE = set(statistical.PERCENTILE.EXC, statistical.PERCENTILE);
    exports.PERCENTILEEXC = statistical.PERCENTILE.EXC;
    exports.PERCENTILEINC = statistical.PERCENTILE.INC;
    exports.PERCENTRANK = set(statistical.PERCENTRANK.INC, statistical.PERCENTRANK);
    exports.PERCENTRANKEXC = statistical.PERCENTRANK.EXC;
    exports.PERCENTRANKINC = statistical.PERCENTRANK.INC;
    exports.POISSON = set(statistical.POISSON.DIST, statistical.POISSON);
    exports.POISSONDIST = statistical.POISSON.DIST;
    exports.QUARTILE = set(statistical.QUARTILE.INC, statistical.QUARTILE);
    exports.QUARTILEEXC = statistical.QUARTILE.EXC;
    exports.QUARTILEINC = statistical.QUARTILE.INC;
    exports.RANK = set(statistical.RANK.EQ, statistical.RANK);
    exports.RANKAVG = statistical.RANK.AVG;
    exports.RANKEQ = statistical.RANK.EQ;
    exports.SKEWP = statistical.SKEW.P;
    exports.STDEV = set(statistical.STDEV.S, statistical.STDEV);
    exports.STDEVP = statistical.STDEV.P;
    exports.STDEVS = statistical.STDEV.S;
    exports.TDIST = statistical.T.DIST;
    exports.TDISTRT = statistical.T.DIST.RT;
    exports.TINV = statistical.T.INV;
    exports.TTEST = statistical.T.TEST;
    exports.VAR = set(statistical.VAR.S, statistical.VAR);
    exports.VARP = statistical.VAR.P;
    exports.VARS = statistical.VAR.S;
    exports.WEIBULL = set(statistical.WEIBULL.DIST, statistical.WEIBULL);
    exports.WEIBULLDIST = statistical.WEIBULL.DIST;
    exports.WORKDAYINTL = dateTime.WORKDAY.INTL;
    exports.ZTEST = statistical.Z.TEST;
  }
});

// ../../node_modules/@handsontable/formulajs/lib/database.js
var require_database = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/database.js"(exports) {
    var error2 = require_error();
    var stats = require_statistical();
    var maths = require_math_trig();
    var utils = require_common();
    var evalExpression = require_criteria_eval();
    function compact(array) {
      var result = [];
      utils.arrayEach(array, function(value) {
        if (value) {
          result.push(value);
        }
      });
      return result;
    }
    exports.FINDFIELD = function(database, title) {
      var index = null;
      utils.arrayEach(database, function(value, i) {
        if (value[0] === title) {
          index = i;
          return false;
        }
      });
      if (index == null) {
        return error2.value;
      }
      return index;
    };
    function findResultIndex(database, criterias) {
      var matches = {};
      for (var i = 1; i < database[0].length; ++i) {
        matches[i] = true;
      }
      var maxCriteriaLength = criterias[0].length;
      for (i = 1; i < criterias.length; ++i) {
        if (criterias[i].length > maxCriteriaLength) {
          maxCriteriaLength = criterias[i].length;
        }
      }
      for (var k = 1; k < database.length; ++k) {
        for (var l = 1; l < database[k].length; ++l) {
          var currentCriteriaResult = false;
          var hasMatchingCriteria = false;
          for (var j = 0; j < criterias.length; ++j) {
            var criteria = criterias[j];
            if (criteria.length < maxCriteriaLength) {
              continue;
            }
            var criteriaField = criteria[0];
            if (database[k][0] !== criteriaField) {
              continue;
            }
            hasMatchingCriteria = true;
            for (var p = 1; p < criteria.length; ++p) {
              if (!currentCriteriaResult) {
                var isWildcard = criteria[p] === void 0 || criteria[p] === "*";
                if (isWildcard) {
                  currentCriteriaResult = true;
                } else {
                  var tokenizedCriteria = evalExpression.parse(criteria[p] + "");
                  var tokens = [evalExpression.createToken(database[k][l], evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
                  currentCriteriaResult = evalExpression.compute(tokens);
                }
              }
            }
          }
          if (hasMatchingCriteria) {
            matches[l] = matches[l] && currentCriteriaResult;
          }
        }
      }
      var result = [];
      for (var n = 0; n < database[0].length; ++n) {
        if (matches[n]) {
          result.push(n - 1);
        }
      }
      return result;
    }
    exports.DAVERAGE = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var sum = 0;
      utils.arrayEach(resultIndexes, function(value) {
        sum += targetFields[value];
      });
      return resultIndexes.length === 0 ? error2.div0 : sum / resultIndexes.length;
    };
    exports.DCOUNT = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.COUNT(targetValues);
    };
    exports.DCOUNTA = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.COUNTA(targetValues);
    };
    exports.DGET = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      if (resultIndexes.length === 0) {
        return error2.value;
      }
      if (resultIndexes.length > 1) {
        return error2.num;
      }
      return targetFields[resultIndexes[0]];
    };
    exports.DMAX = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var maxValue = targetFields[resultIndexes[0]];
      utils.arrayEach(resultIndexes, function(value) {
        if (maxValue < targetFields[value]) {
          maxValue = targetFields[value];
        }
      });
      return maxValue;
    };
    exports.DMIN = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var minValue = targetFields[resultIndexes[0]];
      utils.arrayEach(resultIndexes, function(value) {
        if (minValue > targetFields[value]) {
          minValue = targetFields[value];
        }
      });
      return minValue;
    };
    exports.DPRODUCT = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      targetValues = compact(targetValues);
      var result = 1;
      utils.arrayEach(targetValues, function(value) {
        result *= value;
      });
      return result;
    };
    exports.DSTDEV = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      targetValues = compact(targetValues);
      return stats.STDEV.S(targetValues);
    };
    exports.DSTDEVP = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      targetValues = compact(targetValues);
      return stats.STDEV.P(targetValues);
    };
    exports.DSUM = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return maths.SUM(targetValues);
    };
    exports.DVAR = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.VAR.S(targetValues);
    };
    exports.DVARP = function(database, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index = exports.FINDFIELD(database, field);
        targetFields = utils.rest(database[index]);
      } else {
        targetFields = utils.rest(database[field]);
      }
      var targetValues = [];
      utils.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.VAR.P(targetValues);
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/logical.js
var require_logical = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/logical.js"(exports) {
    var error2 = require_error();
    var utils = require_common();
    var information = require_information();
    exports.AND = function() {
      var args = utils.flatten(arguments);
      var result = true;
      for (var i = 0; i < args.length; i++) {
        if (!args[i]) {
          result = false;
        }
      }
      return result;
    };
    exports.CHOOSE = function() {
      if (arguments.length < 2) {
        return error2.na;
      }
      var index = arguments[0];
      if (index < 1 || index > 254) {
        return error2.value;
      }
      if (arguments.length < index + 1) {
        return error2.value;
      }
      return arguments[index];
    };
    exports.FALSE = function() {
      return false;
    };
    exports.IF = function(test, then_value, otherwise_value) {
      return test ? then_value : otherwise_value;
    };
    exports.IFERROR = function(value, valueIfError) {
      if (information.ISERROR(value)) {
        return valueIfError;
      }
      return value;
    };
    exports.IFNA = function(value, value_if_na) {
      return value === error2.na ? value_if_na : value;
    };
    exports.NOT = function(logical) {
      return !logical;
    };
    exports.OR = function() {
      var args = utils.flatten(arguments);
      var result = false;
      for (var i = 0; i < args.length; i++) {
        if (args[i]) {
          result = true;
        }
      }
      return result;
    };
    exports.TRUE = function() {
      return true;
    };
    exports.XOR = function() {
      var args = utils.flatten(arguments);
      var result = 0;
      for (var i = 0; i < args.length; i++) {
        if (args[i]) {
          result++;
        }
      }
      return Math.floor(Math.abs(result)) & 1 ? true : false;
    };
    exports.SWITCH = function() {
      var result;
      if (arguments.length > 0) {
        var targetValue = arguments[0];
        var argc = arguments.length - 1;
        var switchCount = Math.floor(argc / 2);
        var switchSatisfied = false;
        var hasDefaultClause = argc % 2 !== 0;
        var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];
        if (switchCount) {
          for (var index = 0; index < switchCount; index++) {
            if (targetValue === arguments[index * 2 + 1]) {
              result = arguments[index * 2 + 2];
              switchSatisfied = true;
              break;
            }
          }
        }
        if (!switchSatisfied) {
          result = hasDefaultClause ? defaultClause : error2.na;
        }
      } else {
        result = error2.value;
      }
      return result;
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/financial.js
var require_financial = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/financial.js"(exports) {
    var error2 = require_error();
    var dateTime = require_date_time();
    var utils = require_common();
    function validDate(d) {
      return d && d.getTime && !isNaN(d.getTime());
    }
    function ensureDate(d) {
      return d instanceof Date ? d : new Date(d);
    }
    exports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
      issue = ensureDate(issue);
      first = ensureDate(first);
      settlement = ensureDate(settlement);
      if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
        return error2.value;
      }
      if (rate <= 0 || par <= 0) {
        return error2.num;
      }
      if ([1, 2, 4].indexOf(frequency) === -1) {
        return error2.num;
      }
      if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
        return error2.num;
      }
      if (settlement <= issue) {
        return error2.num;
      }
      par = par || 0;
      basis = basis || 0;
      return par * rate * dateTime.YEARFRAC(issue, settlement, basis);
    };
    exports.ACCRINTM = function() {
      throw new Error("ACCRINTM is not implemented");
    };
    exports.AMORDEGRC = function() {
      throw new Error("AMORDEGRC is not implemented");
    };
    exports.AMORLINC = function() {
      throw new Error("AMORLINC is not implemented");
    };
    exports.COUPDAYBS = function() {
      throw new Error("COUPDAYBS is not implemented");
    };
    exports.COUPDAYS = function() {
      throw new Error("COUPDAYS is not implemented");
    };
    exports.COUPDAYSNC = function() {
      throw new Error("COUPDAYSNC is not implemented");
    };
    exports.COUPNCD = function() {
      throw new Error("COUPNCD is not implemented");
    };
    exports.COUPNUM = function() {
      throw new Error("COUPNUM is not implemented");
    };
    exports.COUPPCD = function() {
      throw new Error("COUPPCD is not implemented");
    };
    exports.CUMIPMT = function(rate, periods, value, start, end, type) {
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      value = utils.parseNumber(value);
      if (utils.anyIsError(rate, periods, value)) {
        return error2.value;
      }
      if (rate <= 0 || periods <= 0 || value <= 0) {
        return error2.num;
      }
      if (start < 1 || end < 1 || start > end) {
        return error2.num;
      }
      if (type !== 0 && type !== 1) {
        return error2.num;
      }
      var payment = exports.PMT(rate, periods, value, 0, type);
      var interest = 0;
      if (start === 1) {
        if (type === 0) {
          interest = -value;
          start++;
        }
      }
      for (var i = start; i <= end; i++) {
        if (type === 1) {
          interest += exports.FV(rate, i - 2, payment, value, 1) - payment;
        } else {
          interest += exports.FV(rate, i - 1, payment, value, 0);
        }
      }
      interest *= rate;
      return interest;
    };
    exports.CUMPRINC = function(rate, periods, value, start, end, type) {
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      value = utils.parseNumber(value);
      if (utils.anyIsError(rate, periods, value)) {
        return error2.value;
      }
      if (rate <= 0 || periods <= 0 || value <= 0) {
        return error2.num;
      }
      if (start < 1 || end < 1 || start > end) {
        return error2.num;
      }
      if (type !== 0 && type !== 1) {
        return error2.num;
      }
      var payment = exports.PMT(rate, periods, value, 0, type);
      var principal = 0;
      if (start === 1) {
        if (type === 0) {
          principal = payment + value * rate;
        } else {
          principal = payment;
        }
        start++;
      }
      for (var i = start; i <= end; i++) {
        if (type > 0) {
          principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;
        } else {
          principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;
        }
      }
      return principal;
    };
    exports.DB = function(cost, salvage, life, period, month) {
      month = month === void 0 ? 12 : month;
      cost = utils.parseNumber(cost);
      salvage = utils.parseNumber(salvage);
      life = utils.parseNumber(life);
      period = utils.parseNumber(period);
      month = utils.parseNumber(month);
      if (utils.anyIsError(cost, salvage, life, period, month)) {
        return error2.value;
      }
      if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
        return error2.num;
      }
      if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
        return error2.num;
      }
      if (period > life) {
        return error2.num;
      }
      if (salvage >= cost) {
        return 0;
      }
      var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);
      var initial = cost * rate * month / 12;
      var total = initial;
      var current = 0;
      var ceiling = period === life ? life - 1 : period;
      for (var i = 2; i <= ceiling; i++) {
        current = (cost - total) * rate;
        total += current;
      }
      if (period === 1) {
        return initial;
      } else if (period === life) {
        return (cost - total) * rate;
      } else {
        return current;
      }
    };
    exports.DDB = function(cost, salvage, life, period, factor) {
      factor = factor === void 0 ? 2 : factor;
      cost = utils.parseNumber(cost);
      salvage = utils.parseNumber(salvage);
      life = utils.parseNumber(life);
      period = utils.parseNumber(period);
      factor = utils.parseNumber(factor);
      if (utils.anyIsError(cost, salvage, life, period, factor)) {
        return error2.value;
      }
      if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
        return error2.num;
      }
      if (period > life) {
        return error2.num;
      }
      if (salvage >= cost) {
        return 0;
      }
      var total = 0;
      var current = 0;
      for (var i = 1; i <= period; i++) {
        current = Math.min((cost - total) * (factor / life), cost - salvage - total);
        total += current;
      }
      return current;
    };
    exports.DISC = function() {
      throw new Error("DISC is not implemented");
    };
    exports.DOLLARDE = function(dollar, fraction) {
      dollar = utils.parseNumber(dollar);
      fraction = utils.parseNumber(fraction);
      if (utils.anyIsError(dollar, fraction)) {
        return error2.value;
      }
      if (fraction < 0) {
        return error2.num;
      }
      if (fraction >= 0 && fraction < 1) {
        return error2.div0;
      }
      fraction = parseInt(fraction, 10);
      var result = parseInt(dollar, 10);
      result += dollar % 1 * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;
      var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
      result = Math.round(result * power) / power;
      return result;
    };
    exports.DOLLARFR = function(dollar, fraction) {
      dollar = utils.parseNumber(dollar);
      fraction = utils.parseNumber(fraction);
      if (utils.anyIsError(dollar, fraction)) {
        return error2.value;
      }
      if (fraction < 0) {
        return error2.num;
      }
      if (fraction >= 0 && fraction < 1) {
        return error2.div0;
      }
      fraction = parseInt(fraction, 10);
      var result = parseInt(dollar, 10);
      result += dollar % 1 * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;
      return result;
    };
    exports.DURATION = function() {
      throw new Error("DURATION is not implemented");
    };
    exports.EFFECT = function(rate, periods) {
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      if (utils.anyIsError(rate, periods)) {
        return error2.value;
      }
      if (rate <= 0 || periods < 1) {
        return error2.num;
      }
      periods = parseInt(periods, 10);
      return Math.pow(1 + rate / periods, periods) - 1;
    };
    exports.FV = function(rate, periods, payment, value, type) {
      value = value || 0;
      type = type || 0;
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      payment = utils.parseNumber(payment);
      value = utils.parseNumber(value);
      type = utils.parseNumber(type);
      if (utils.anyIsError(rate, periods, payment, value, type)) {
        return error2.value;
      }
      var result;
      if (rate === 0) {
        result = value + payment * periods;
      } else {
        var term = Math.pow(1 + rate, periods);
        if (type === 1) {
          result = value * term + payment * (1 + rate) * (term - 1) / rate;
        } else {
          result = value * term + payment * (term - 1) / rate;
        }
      }
      return -result;
    };
    exports.FVSCHEDULE = function(principal, schedule) {
      principal = utils.parseNumber(principal);
      schedule = utils.parseNumberArray(utils.flatten(schedule));
      if (utils.anyIsError(principal, schedule)) {
        return error2.value;
      }
      var n = schedule.length;
      var future = principal;
      for (var i = 0; i < n; i++) {
        future *= 1 + schedule[i];
      }
      return future;
    };
    exports.INTRATE = function() {
      throw new Error("INTRATE is not implemented");
    };
    exports.IPMT = function(rate, period, periods, present, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils.parseNumber(rate);
      period = utils.parseNumber(period);
      periods = utils.parseNumber(periods);
      present = utils.parseNumber(present);
      future = utils.parseNumber(future);
      type = utils.parseNumber(type);
      if (utils.anyIsError(rate, period, periods, present, future, type)) {
        return error2.value;
      }
      var payment = exports.PMT(rate, periods, present, future, type);
      var interest;
      if (period === 1) {
        if (type === 1) {
          interest = 0;
        } else {
          interest = -present;
        }
      } else {
        if (type === 1) {
          interest = exports.FV(rate, period - 2, payment, present, 1) - payment;
        } else {
          interest = exports.FV(rate, period - 1, payment, present, 0);
        }
      }
      return interest * rate;
    };
    exports.IRR = function(values, guess) {
      guess = guess || 0;
      values = utils.parseNumberArray(utils.flatten(values));
      guess = utils.parseNumber(guess);
      if (utils.anyIsError(values, guess)) {
        return error2.value;
      }
      var irrResult = function(values2, dates2, rate) {
        var r = rate + 1;
        var result = values2[0];
        for (var i2 = 1; i2 < values2.length; i2++) {
          result += values2[i2] / Math.pow(r, (dates2[i2] - dates2[0]) / 365);
        }
        return result;
      };
      var irrResultDeriv = function(values2, dates2, rate) {
        var r = rate + 1;
        var result = 0;
        for (var i2 = 1; i2 < values2.length; i2++) {
          var frac = (dates2[i2] - dates2[0]) / 365;
          result -= frac * values2[i2] / Math.pow(r, frac + 1);
        }
        return result;
      };
      var dates = [];
      var positive = false;
      var negative = false;
      for (var i = 0; i < values.length; i++) {
        dates[i] = i === 0 ? 0 : dates[i - 1] + 365;
        if (values[i] > 0) {
          positive = true;
        }
        if (values[i] < 0) {
          negative = true;
        }
      }
      if (!positive || !negative) {
        return error2.num;
      }
      guess = guess === void 0 ? 0.1 : guess;
      var resultRate = guess;
      var epsMax = 1e-10;
      var newRate, epsRate, resultValue;
      var contLoop = true;
      do {
        resultValue = irrResult(values, dates, resultRate);
        newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
        epsRate = Math.abs(newRate - resultRate);
        resultRate = newRate;
        contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;
      } while (contLoop);
      return resultRate;
    };
    exports.ISPMT = function(rate, period, periods, value) {
      rate = utils.parseNumber(rate);
      period = utils.parseNumber(period);
      periods = utils.parseNumber(periods);
      value = utils.parseNumber(value);
      if (utils.anyIsError(rate, period, periods, value)) {
        return error2.value;
      }
      return value * rate * (period / periods - 1);
    };
    exports.MDURATION = function() {
      throw new Error("MDURATION is not implemented");
    };
    exports.MIRR = function(values, finance_rate, reinvest_rate) {
      values = utils.parseNumberArray(utils.flatten(values));
      finance_rate = utils.parseNumber(finance_rate);
      reinvest_rate = utils.parseNumber(reinvest_rate);
      if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
        return error2.value;
      }
      var n = values.length;
      var payments = [];
      var incomes = [];
      for (var i = 0; i < n; i++) {
        if (values[i] < 0) {
          payments.push(values[i]);
        } else {
          incomes.push(values[i]);
        }
      }
      var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
      var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);
      return Math.pow(num / den, 1 / (n - 1)) - 1;
    };
    exports.NOMINAL = function(rate, periods) {
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      if (utils.anyIsError(rate, periods)) {
        return error2.value;
      }
      if (rate <= 0 || periods < 1) {
        return error2.num;
      }
      periods = parseInt(periods, 10);
      return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
    };
    exports.NPER = function(rate, payment, present, future, type) {
      type = type === void 0 ? 0 : type;
      future = future === void 0 ? 0 : future;
      rate = utils.parseNumber(rate);
      payment = utils.parseNumber(payment);
      present = utils.parseNumber(present);
      future = utils.parseNumber(future);
      type = utils.parseNumber(type);
      if (utils.anyIsError(rate, payment, present, future, type)) {
        return error2.value;
      }
      var num = payment * (1 + rate * type) - future * rate;
      var den = present * rate + payment * (1 + rate * type);
      return Math.log(num / den) / Math.log(1 + rate);
    };
    exports.NPV = function() {
      var args = utils.parseNumberArray(utils.flatten(arguments));
      if (args instanceof Error) {
        return args;
      }
      var rate = args[0];
      var value = 0;
      for (var j = 1; j < args.length; j++) {
        value += args[j] / Math.pow(1 + rate, j);
      }
      return value;
    };
    exports.ODDFPRICE = function() {
      throw new Error("ODDFPRICE is not implemented");
    };
    exports.ODDFYIELD = function() {
      throw new Error("ODDFYIELD is not implemented");
    };
    exports.ODDLPRICE = function() {
      throw new Error("ODDLPRICE is not implemented");
    };
    exports.ODDLYIELD = function() {
      throw new Error("ODDLYIELD is not implemented");
    };
    exports.PDURATION = function(rate, present, future) {
      rate = utils.parseNumber(rate);
      present = utils.parseNumber(present);
      future = utils.parseNumber(future);
      if (utils.anyIsError(rate, present, future)) {
        return error2.value;
      }
      if (rate <= 0) {
        return error2.num;
      }
      return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
    };
    exports.PMT = function(rate, periods, present, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      present = utils.parseNumber(present);
      future = utils.parseNumber(future);
      type = utils.parseNumber(type);
      if (utils.anyIsError(rate, periods, present, future, type)) {
        return error2.value;
      }
      var result;
      if (rate === 0) {
        result = (present + future) / periods;
      } else {
        var term = Math.pow(1 + rate, periods);
        if (type === 1) {
          result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
        } else {
          result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
        }
      }
      return -result;
    };
    exports.PPMT = function(rate, period, periods, present, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      present = utils.parseNumber(present);
      future = utils.parseNumber(future);
      type = utils.parseNumber(type);
      if (utils.anyIsError(rate, periods, present, future, type)) {
        return error2.value;
      }
      return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);
    };
    exports.PRICE = function() {
      throw new Error("PRICE is not implemented");
    };
    exports.PRICEDISC = function() {
      throw new Error("PRICEDISC is not implemented");
    };
    exports.PRICEMAT = function() {
      throw new Error("PRICEMAT is not implemented");
    };
    exports.PV = function(rate, periods, payment, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils.parseNumber(rate);
      periods = utils.parseNumber(periods);
      payment = utils.parseNumber(payment);
      future = utils.parseNumber(future);
      type = utils.parseNumber(type);
      if (utils.anyIsError(rate, periods, payment, future, type)) {
        return error2.value;
      }
      if (rate === 0) {
        return -payment * periods - future;
      } else {
        return ((1 - Math.pow(1 + rate, periods)) / rate * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
      }
    };
    exports.RATE = function(periods, payment, present, future, type, guess) {
      guess = guess === void 0 ? 0.01 : guess;
      future = future === void 0 ? 0 : future;
      type = type === void 0 ? 0 : type;
      periods = utils.parseNumber(periods);
      payment = utils.parseNumber(payment);
      present = utils.parseNumber(present);
      future = utils.parseNumber(future);
      type = utils.parseNumber(type);
      guess = utils.parseNumber(guess);
      if (utils.anyIsError(periods, payment, present, future, type, guess)) {
        return error2.value;
      }
      var epsMax = 1e-10;
      var iterMax = 50;
      var y, y0, y1, x0, x1 = 0, f = 0, i = 0;
      var rate = guess;
      if (Math.abs(rate) < epsMax) {
        y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;
      } else {
        f = Math.exp(periods * Math.log(1 + rate));
        y = present * f + payment * (1 / rate + type) * (f - 1) + future;
      }
      y0 = present + payment * periods + future;
      y1 = present * f + payment * (1 / rate + type) * (f - 1) + future;
      i = x0 = 0;
      x1 = rate;
      while (Math.abs(y0 - y1) > epsMax && i < iterMax) {
        rate = (y1 * x0 - y0 * x1) / (y1 - y0);
        x0 = x1;
        x1 = rate;
        if (Math.abs(rate) < epsMax) {
          y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;
        } else {
          f = Math.exp(periods * Math.log(1 + rate));
          y = present * f + payment * (1 / rate + type) * (f - 1) + future;
        }
        y0 = y1;
        y1 = y;
        ++i;
      }
      return rate;
    };
    exports.RECEIVED = function() {
      throw new Error("RECEIVED is not implemented");
    };
    exports.RRI = function(periods, present, future) {
      periods = utils.parseNumber(periods);
      present = utils.parseNumber(present);
      future = utils.parseNumber(future);
      if (utils.anyIsError(periods, present, future)) {
        return error2.value;
      }
      if (periods === 0 || present === 0) {
        return error2.num;
      }
      return Math.pow(future / present, 1 / periods) - 1;
    };
    exports.SLN = function(cost, salvage, life) {
      cost = utils.parseNumber(cost);
      salvage = utils.parseNumber(salvage);
      life = utils.parseNumber(life);
      if (utils.anyIsError(cost, salvage, life)) {
        return error2.value;
      }
      if (life === 0) {
        return error2.num;
      }
      return (cost - salvage) / life;
    };
    exports.SYD = function(cost, salvage, life, period) {
      cost = utils.parseNumber(cost);
      salvage = utils.parseNumber(salvage);
      life = utils.parseNumber(life);
      period = utils.parseNumber(period);
      if (utils.anyIsError(cost, salvage, life, period)) {
        return error2.value;
      }
      if (life === 0) {
        return error2.num;
      }
      if (period < 1 || period > life) {
        return error2.num;
      }
      period = parseInt(period, 10);
      return (cost - salvage) * (life - period + 1) * 2 / (life * (life + 1));
    };
    exports.TBILLEQ = function(settlement, maturity, discount) {
      settlement = utils.parseDate(settlement);
      maturity = utils.parseDate(maturity);
      discount = utils.parseNumber(discount);
      if (utils.anyIsError(settlement, maturity, discount)) {
        return error2.value;
      }
      if (discount <= 0) {
        return error2.num;
      }
      if (settlement > maturity) {
        return error2.num;
      }
      if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
        return error2.num;
      }
      return 365 * discount / (360 - discount * dateTime.DAYS360(settlement, maturity, false));
    };
    exports.TBILLPRICE = function(settlement, maturity, discount) {
      settlement = utils.parseDate(settlement);
      maturity = utils.parseDate(maturity);
      discount = utils.parseNumber(discount);
      if (utils.anyIsError(settlement, maturity, discount)) {
        return error2.value;
      }
      if (discount <= 0) {
        return error2.num;
      }
      if (settlement > maturity) {
        return error2.num;
      }
      if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
        return error2.num;
      }
      return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);
    };
    exports.TBILLYIELD = function(settlement, maturity, price) {
      settlement = utils.parseDate(settlement);
      maturity = utils.parseDate(maturity);
      price = utils.parseNumber(price);
      if (utils.anyIsError(settlement, maturity, price)) {
        return error2.value;
      }
      if (price <= 0) {
        return error2.num;
      }
      if (settlement > maturity) {
        return error2.num;
      }
      if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
        return error2.num;
      }
      return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));
    };
    exports.VDB = function() {
      throw new Error("VDB is not implemented");
    };
    exports.XNPV = function(rate, values, dates) {
      rate = utils.parseNumber(rate);
      values = utils.parseNumberArray(utils.flatten(values));
      dates = utils.parseDateArray(utils.flatten(dates));
      if (utils.anyIsError(rate, values, dates)) {
        return error2.value;
      }
      var result = 0;
      for (var i = 0; i < values.length; i++) {
        result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);
      }
      return result;
    };
    exports.YIELD = function() {
      throw new Error("YIELD is not implemented");
    };
    exports.YIELDDISC = function() {
      throw new Error("YIELDDISC is not implemented");
    };
    exports.YIELDMAT = function() {
      throw new Error("YIELDMAT is not implemented");
    };
  }
});

// ../../node_modules/@handsontable/formulajs/lib/lookup-reference.js
var require_lookup_reference = __commonJS({
  "../../node_modules/@handsontable/formulajs/lib/lookup-reference.js"(exports) {
    var error2 = require_error();
    var utils = require_common();
    exports.MATCH = function(lookupValue, lookupArray, matchType) {
      if (!lookupValue && !lookupArray) {
        return error2.na;
      }
      if (arguments.length === 2) {
        matchType = 1;
      }
      if (!(lookupArray instanceof Array)) {
        return error2.na;
      }
      if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
        return error2.na;
      }
      var index;
      var indexValue;
      for (var idx = 0; idx < lookupArray.length; idx++) {
        if (matchType === 1) {
          if (lookupArray[idx] === lookupValue) {
            return idx + 1;
          } else if (lookupArray[idx] < lookupValue) {
            if (!indexValue) {
              index = idx + 1;
              indexValue = lookupArray[idx];
            } else if (lookupArray[idx] > indexValue) {
              index = idx + 1;
              indexValue = lookupArray[idx];
            }
          }
        } else if (matchType === 0) {
          if (typeof lookupValue === "string") {
            lookupValue = lookupValue.replace(/\?/g, ".");
            if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
              return idx + 1;
            }
          } else {
            if (lookupArray[idx] === lookupValue) {
              return idx + 1;
            }
          }
        } else if (matchType === -1) {
          if (lookupArray[idx] === lookupValue) {
            return idx + 1;
          } else if (lookupArray[idx] > lookupValue) {
            if (!indexValue) {
              index = idx + 1;
              indexValue = lookupArray[idx];
            } else if (lookupArray[idx] < indexValue) {
              index = idx + 1;
              indexValue = lookupArray[idx];
            }
          }
        }
      }
      return index ? index : error2.na;
    };
    exports.VLOOKUP = function(needle, table, index, rangeLookup) {
      if (!needle || !table || !index) {
        return error2.na;
      }
      rangeLookup = rangeLookup || false;
      for (var i = 0; i < table.length; i++) {
        var row = table[i];
        if (!rangeLookup && row[0] === needle || (row[0] === needle || rangeLookup && typeof row[0] === "string" && row[0].toLowerCase().indexOf(needle.toLowerCase()) !== -1)) {
          return index < row.length + 1 ? row[index - 1] : error2.ref;
        }
      }
      return error2.na;
    };
    exports.HLOOKUP = function(needle, table, index, rangeLookup) {
      if (!needle || !table || !index) {
        return error2.na;
      }
      rangeLookup = rangeLookup || false;
      var transposedTable = utils.transpose(table);
      for (var i = 0; i < transposedTable.length; i++) {
        var row = transposedTable[i];
        if (!rangeLookup && row[0] === needle || (row[0] === needle || rangeLookup && typeof row[0] === "string" && row[0].toLowerCase().indexOf(needle.toLowerCase()) !== -1)) {
          return index < row.length + 1 ? row[index - 1] : error2.ref;
        }
      }
      return error2.na;
    };
  }
});

// ../../node_modules/@handsontable/formulajs/index.js
var require_formulajs = __commonJS({
  "../../node_modules/@handsontable/formulajs/index.js"(exports) {
    var categories = [
      require_compatibility(),
      require_database(),
      require_engineering(),
      require_logical(),
      require_math_trig(),
      require_text(),
      require_date_time(),
      require_financial(),
      require_information(),
      require_lookup_reference(),
      require_statistical(),
      require_miscellaneous()
    ];
    for (c in categories) {
      category = categories[c];
      for (f in category) {
        exports[f] = exports[f] || category[f];
      }
    }
    var category;
    var f;
    var c;
  }
});

// ../../node_modules/hot-formula-parser/parser.mjs
var import_tiny_emitter = __toESM(require_tiny_emitter(), 1);

// ../../node_modules/hot-formula-parser/helper/number.mjs
function toNumber(number) {
  var result;
  if (typeof number === "number") {
    result = number;
  } else if (typeof number === "string") {
    result = number.indexOf(".") > -1 ? parseFloat(number) : parseInt(number, 10);
  }
  return result;
}
function invertNumber(number) {
  return -1 * toNumber(number);
}

// ../../node_modules/hot-formula-parser/error.mjs
var _errors;
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ERROR = "ERROR";
var ERROR_DIV_ZERO = "DIV/0";
var ERROR_NAME = "NAME";
var ERROR_NOT_AVAILABLE = "N/A";
var ERROR_NULL = "NULL";
var ERROR_NUM = "NUM";
var ERROR_REF = "REF";
var ERROR_VALUE = "VALUE";
var errors = (_errors = {}, _defineProperty(_errors, ERROR, "#ERROR!"), _defineProperty(_errors, ERROR_DIV_ZERO, "#DIV/0!"), _defineProperty(_errors, ERROR_NAME, "#NAME?"), _defineProperty(_errors, ERROR_NOT_AVAILABLE, "#N/A"), _defineProperty(_errors, ERROR_NULL, "#NULL!"), _defineProperty(_errors, ERROR_NUM, "#NUM!"), _defineProperty(_errors, ERROR_REF, "#REF!"), _defineProperty(_errors, ERROR_VALUE, "#VALUE!"), _errors);
function error(type) {
  var result;
  type = (type + "").replace(/#|!|\?/g, "");
  if (errors[type]) {
    result = errors[type];
  }
  return result ? result : null;
}
function isValidStrict(type) {
  var valid = false;
  for (var i in errors) {
    if (Object.prototype.hasOwnProperty.call(errors, i) && errors[i] === type) {
      valid = true;
      break;
    }
  }
  return valid;
}

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/add.mjs
var SYMBOL = "+";
function func(first) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }
  var result = rest.reduce(function(acc, value) {
    return acc + toNumber(value);
  }, toNumber(first));
  if (isNaN(result)) {
    throw Error(ERROR_VALUE);
  }
  return result;
}
func.SYMBOL = SYMBOL;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/ampersand.mjs
var SYMBOL2 = "&";
function func2() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }
  return params.reduce(function(acc, value) {
    return acc + value.toString();
  }, "");
}
func2.SYMBOL = SYMBOL2;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/divide.mjs
var SYMBOL3 = "/";
function func3(first) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }
  var result = rest.reduce(function(acc, value) {
    return acc / toNumber(value);
  }, toNumber(first));
  if (result === Infinity) {
    throw Error(ERROR_DIV_ZERO);
  }
  if (isNaN(result)) {
    throw Error(ERROR_VALUE);
  }
  return result;
}
func3.SYMBOL = SYMBOL3;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/equal.mjs
var SYMBOL4 = "=";
function func4(exp1, exp2) {
  return exp1 === exp2;
}
func4.SYMBOL = SYMBOL4;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/formula-function.mjs
var import_formulajs = __toESM(require_formulajs(), 1);

// ../../node_modules/hot-formula-parser/supported-formulas.mjs
var SUPPORTED_FORMULAS = ["ABS", "ACCRINT", "ACOS", "ACOSH", "ACOT", "ACOTH", "ADD", "AGGREGATE", "AND", "ARABIC", "ARGS2ARRAY", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "AVEDEV", "AVERAGE", "AVERAGEA", "AVERAGEIF", "AVERAGEIFS", "BASE", "BESSELI", "BESSELJ", "BESSELK", "BESSELY", "BETA.DIST", "BETA.INV", "BETADIST", "BETAINV", "BIN2DEC", "BIN2HEX", "BIN2OCT", "BINOM.DIST", "BINOM.DIST.RANGE", "BINOM.INV", "BINOMDIST", "BITAND", "BITLSHIFT", "BITOR", "BITRSHIFT", "BITXOR", "CEILING", "CEILINGMATH", "CEILINGPRECISE", "CHAR", "CHISQ.DIST", "CHISQ.DIST.RT", "CHISQ.INV", "CHISQ.INV.RT", "CHOOSE", "CHOOSE", "CLEAN", "CODE", "COLUMN", "COLUMNS", "COMBIN", "COMBINA", "COMPLEX", "CONCATENATE", "CONFIDENCE", "CONFIDENCE.NORM", "CONFIDENCE.T", "CONVERT", "CORREL", "COS", "COSH", "COT", "COTH", "COUNT", "COUNTA", "COUNTBLANK", "COUNTIF", "COUNTIFS", "COUNTIN", "COUNTUNIQUE", "COVARIANCE.P", "COVARIANCE.S", "CSC", "CSCH", "CUMIPMT", "CUMPRINC", "DATE", "DATEVALUE", "DAY", "DAYS", "DAYS360", "DB", "DDB", "DEC2BIN", "DEC2HEX", "DEC2OCT", "DECIMAL", "DEGREES", "DELTA", "DEVSQ", "DIVIDE", "DOLLARDE", "DOLLARFR", "E", "EDATE", "EFFECT", "EOMONTH", "EQ", "ERF", "ERFC", "EVEN", "EXACT", "EXP", "EXPON.DIST", "EXPONDIST", "F.DIST", "F.DIST.RT", "F.INV", "F.INV.RT", "FACT", "FACTDOUBLE", "FALSE", "FDIST", "FDISTRT", "FIND", "FINV", "FINVRT", "FISHER", "FISHERINV", "FLATTEN", "FLOOR", "FORECAST", "FREQUENCY", "FV", "FVSCHEDULE", "GAMMA", "GAMMA.DIST", "GAMMA.INV", "GAMMADIST", "GAMMAINV", "GAMMALN", "GAMMALN.PRECISE", "GAUSS", "GCD", "GEOMEAN", "GESTEP", "GROWTH", "GTE", "HARMEAN", "HEX2BIN", "HEX2DEC", "HEX2OCT", "HOUR", "HTML2TEXT", "HYPGEOM.DIST", "HYPGEOMDIST", "IF", "IMABS", "IMAGINARY", "IMARGUMENT", "IMCONJUGATE", "IMCOS", "IMCOSH", "IMCOT", "IMCSC", "IMCSCH", "IMDIV", "IMEXP", "IMLN", "IMLOG10", "IMLOG2", "IMPOWER", "IMPRODUCT", "IMREAL", "IMSEC", "IMSECH", "IMSIN", "IMSINH", "IMSQRT", "IMSUB", "IMSUM", "IMTAN", "INT", "INTERCEPT", "INTERVAL", "IPMT", "IRR", "ISBINARY", "ISBLANK", "ISEVEN", "ISLOGICAL", "ISNONTEXT", "ISNUMBER", "ISODD", "ISODD", "ISOWEEKNUM", "ISPMT", "ISTEXT", "JOIN", "KURT", "LARGE", "LCM", "LEFT", "LEN", "LINEST", "LN", "LOG", "LOG10", "LOGEST", "LOGNORM.DIST", "LOGNORM.INV", "LOGNORMDIST", "LOGNORMINV", "LOWER", "LT", "LTE", "MATCH", "MAX", "MAXA", "MEDIAN", "MID", "MIN", "MINA", "MINUS", "MINUTE", "MIRR", "MOD", "MODE.MULT", "MODE.SNGL", "MODEMULT", "MODESNGL", "MONTH", "MROUND", "MULTINOMIAL", "MULTIPLY", "NE", "NEGBINOM.DIST", "NEGBINOMDIST", "NETWORKDAYS", "NOMINAL", "NORM.DIST", "NORM.INV", "NORM.S.DIST", "NORM.S.INV", "NORMDIST", "NORMINV", "NORMSDIST", "NORMSINV", "NOT", "NOW", "NPER", "NPV", "NUMBERS", "OCT2BIN", "OCT2DEC", "OCT2HEX", "ODD", "OR", "PDURATION", "PEARSON", "PERCENTILEEXC", "PERCENTILEINC", "PERCENTRANKEXC", "PERCENTRANKINC", "PERMUT", "PERMUTATIONA", "PHI", "PI", "PMT", "POISSON.DIST", "POISSONDIST", "POW", "POWER", "PPMT", "PROB", "PRODUCT", "PROPER", "PV", "QUARTILE.EXC", "QUARTILE.INC", "QUARTILEEXC", "QUARTILEINC", "QUOTIENT", "RADIANS", "RAND", "RANDBETWEEN", "RANK.AVG", "RANK.EQ", "RANKAVG", "RANKEQ", "RATE", "REFERENCE", "REGEXEXTRACT", "REGEXMATCH", "REGEXREPLACE", "REPLACE", "REPT", "RIGHT", "ROMAN", "ROUND", "ROUNDDOWN", "ROUNDUP", "ROW", "ROWS", "RRI", "RSQ", "SEARCH", "SEC", "SECH", "SECOND", "SERIESSUM", "SIGN", "SIN", "SINH", "SKEW", "SKEW.P", "SKEWP", "SLN", "SLOPE", "SMALL", "SPLIT", "SPLIT", "SQRT", "SQRTPI", "STANDARDIZE", "STDEV.P", "STDEV.S", "STDEVA", "STDEVP", "STDEVPA", "STDEVS", "STEYX", "SUBSTITUTE", "SUBTOTAL", "SUM", "SUMIF", "SUMIFS", "SUMPRODUCT", "SUMSQ", "SUMX2MY2", "SUMX2PY2", "SUMXMY2", "SWITCH", "SYD", "T", "T.DIST", "T.DIST.2T", "T.DIST.RT", "T.INV", "T.INV.2T", "TAN", "TANH", "TBILLEQ", "TBILLPRICE", "TBILLYIELD", "TDIST", "TDIST2T", "TDISTRT", "TIME", "TIMEVALUE", "TINV", "TINV2T", "TODAY", "TRANSPOSE", "TREND", "TRIM", "TRIMMEAN", "TRUE", "TRUNC", "UNICHAR", "UNICODE", "UNIQUE", "UPPER", "VAR.P", "VAR.S", "VARA", "VARP", "VARPA", "VARS", "WEEKDAY", "WEEKNUM", "WEIBULL.DIST", "WEIBULLDIST", "WORKDAY", "XIRR", "XNPV", "XOR", "YEAR", "YEARFRAC"];
var supported_formulas_default = SUPPORTED_FORMULAS;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/formula-function.mjs
var SYMBOL5 = supported_formulas_default;
function func5(symbol) {
  return function __formulaFunction() {
    symbol = symbol.toUpperCase();
    var symbolParts = symbol.split(".");
    var foundFormula = false;
    var result;
    if (symbolParts.length === 1) {
      if (import_formulajs.default[symbolParts[0]]) {
        foundFormula = true;
        result = import_formulajs.default[symbolParts[0]].apply(import_formulajs.default, arguments);
      }
    } else {
      var length = symbolParts.length;
      var index = 0;
      var nestedFormula = import_formulajs.default;
      while (index < length) {
        nestedFormula = nestedFormula[symbolParts[index]];
        index++;
        if (!nestedFormula) {
          nestedFormula = null;
          break;
        }
      }
      if (nestedFormula) {
        foundFormula = true;
        result = nestedFormula.apply(void 0, arguments);
      }
    }
    if (!foundFormula) {
      throw Error(ERROR_NAME);
    }
    return result;
  };
}
func5.isFactory = true;
func5.SYMBOL = SYMBOL5;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/greater-than.mjs
var SYMBOL6 = ">";
function func6(exp1, exp2) {
  return exp1 > exp2;
}
func6.SYMBOL = SYMBOL6;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/greater-than-or-equal.mjs
var SYMBOL7 = ">=";
function func7(exp1, exp2) {
  return exp1 >= exp2;
}
func7.SYMBOL = SYMBOL7;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/less-than.mjs
var SYMBOL8 = "<";
function func8(exp1, exp2) {
  return exp1 < exp2;
}
func8.SYMBOL = SYMBOL8;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/less-than-or-equal.mjs
var SYMBOL9 = "<=";
function func9(exp1, exp2) {
  return exp1 <= exp2;
}
func9.SYMBOL = SYMBOL9;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/minus.mjs
var SYMBOL10 = "-";
function func10(first) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }
  var result = rest.reduce(function(acc, value) {
    return acc - toNumber(value);
  }, toNumber(first));
  if (isNaN(result)) {
    throw Error(ERROR_VALUE);
  }
  return result;
}
func10.SYMBOL = SYMBOL10;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/multiply.mjs
var SYMBOL11 = "*";
function func11(first) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }
  var result = rest.reduce(function(acc, value) {
    return acc * toNumber(value);
  }, toNumber(first));
  if (isNaN(result)) {
    throw Error(ERROR_VALUE);
  }
  return result;
}
func11.SYMBOL = SYMBOL11;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/not-equal.mjs
var SYMBOL12 = "<>";
function func12(exp1, exp2) {
  return exp1 !== exp2;
}
func12.SYMBOL = SYMBOL12;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/operator/power.mjs
var SYMBOL13 = "^";
function func13(exp1, exp2) {
  var result = Math.pow(toNumber(exp1), toNumber(exp2));
  if (isNaN(result)) {
    throw Error(ERROR_VALUE);
  }
  return result;
}
func13.SYMBOL = SYMBOL13;

// ../../node_modules/hot-formula-parser/evaluate-by-operator/evaluate-by-operator.mjs
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray(o3, minLen);
  var n = Object.prototype.toString.call(o3).slice(8, -1);
  if (n === "Object" && o3.constructor) n = o3.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o3);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o3, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var availableOperators = /* @__PURE__ */ Object.create(null);
function evaluateByOperator(operator) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  operator = operator.toUpperCase();
  if (!availableOperators[operator]) {
    throw Error(ERROR_NAME);
  }
  return availableOperators[operator].apply(availableOperators, _toConsumableArray(params));
}
function registerOperation(symbol, func14) {
  if (!Array.isArray(symbol)) {
    symbol = [symbol.toUpperCase()];
  }
  symbol.forEach(function(s) {
    if (func14.isFactory) {
      availableOperators[s] = func14(s);
    } else {
      availableOperators[s] = func14;
    }
  });
}
registerOperation(func.SYMBOL, func);
registerOperation(func2.SYMBOL, func2);
registerOperation(func3.SYMBOL, func3);
registerOperation(func4.SYMBOL, func4);
registerOperation(func13.SYMBOL, func13);
registerOperation(func5.SYMBOL, func5);
registerOperation(func6.SYMBOL, func6);
registerOperation(func7.SYMBOL, func7);
registerOperation(func8.SYMBOL, func8);
registerOperation(func9.SYMBOL, func9);
registerOperation(func11.SYMBOL, func11);
registerOperation(func12.SYMBOL, func12);
registerOperation(func10.SYMBOL, func10);

// ../../node_modules/hot-formula-parser/grammar-parser/grammar-parser.mjs
var o = function o2(k, v, _o, l) {
  for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
    ;
  }
  return _o;
};
var $V0 = [1, 5];
var $V1 = [1, 8];
var $V2 = [1, 6];
var $V3 = [1, 7];
var $V4 = [1, 9];
var $V5 = [1, 14];
var $V6 = [1, 15];
var $V7 = [1, 16];
var $V8 = [1, 12];
var $V9 = [1, 13];
var $Va = [1, 17];
var $Vb = [1, 19];
var $Vc = [1, 20];
var $Vd = [1, 21];
var $Ve = [1, 22];
var $Vf = [1, 23];
var $Vg = [1, 24];
var $Vh = [1, 25];
var $Vi = [1, 26];
var $Vj = [1, 27];
var $Vk = [1, 28];
var $Vl = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30];
var $Vm = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 32];
var $Vn = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 34];
var $Vo = [5, 10, 11, 13, 14, 15, 16, 17, 29, 30];
var $Vp = [5, 10, 13, 14, 15, 16, 29, 30];
var $Vq = [5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 29, 30];
var $Vr = [13, 29, 30];
var parser = {
  trace: function trace() {
  },
  yy: {},
  symbols_: {
    "error": 2,
    "expressions": 3,
    "expression": 4,
    "EOF": 5,
    "variableSequence": 6,
    "number": 7,
    "STRING": 8,
    "&": 9,
    "=": 10,
    "+": 11,
    "(": 12,
    ")": 13,
    "<": 14,
    ">": 15,
    "NOT": 16,
    "-": 17,
    "*": 18,
    "/": 19,
    "^": 20,
    "FUNCTION": 21,
    "expseq": 22,
    "cell": 23,
    "ABSOLUTE_CELL": 24,
    "RELATIVE_CELL": 25,
    "MIXED_CELL": 26,
    ":": 27,
    "ARRAY": 28,
    ";": 29,
    ",": 30,
    "VARIABLE": 31,
    "DECIMAL": 32,
    "NUMBER": 33,
    "%": 34,
    "ERROR": 35,
    "$accept": 0,
    "$end": 1
  },
  terminals_: {
    5: "EOF",
    8: "STRING",
    9: "&",
    10: "=",
    11: "+",
    12: "(",
    13: ")",
    14: "<",
    15: ">",
    16: "NOT",
    17: "-",
    18: "*",
    19: "/",
    20: "^",
    21: "FUNCTION",
    24: "ABSOLUTE_CELL",
    25: "RELATIVE_CELL",
    26: "MIXED_CELL",
    27: ":",
    28: "ARRAY",
    29: ";",
    30: ",",
    31: "VARIABLE",
    32: "DECIMAL",
    33: "NUMBER",
    34: "%",
    35: "ERROR"
  },
  productions_: [0, [3, 2], [4, 1], [4, 1], [4, 1], [4, 3], [4, 3], [4, 3], [4, 3], [4, 4], [4, 4], [4, 4], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 2], [4, 2], [4, 3], [4, 4], [4, 1], [4, 1], [4, 2], [23, 1], [23, 1], [23, 1], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [22, 1], [22, 1], [22, 3], [22, 3], [6, 1], [6, 3], [7, 1], [7, 3], [7, 2], [2, 1]],
  performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
    var $0 = $$.length - 1;
    switch (yystate) {
      case 1:
        return $$[$0 - 1];
        break;
      case 2:
        this.$ = yy.callVariable($$[$0][0]);
        break;
      case 3:
        this.$ = yy.toNumber($$[$0]);
        break;
      case 4:
        this.$ = yy.trimEdges($$[$0]);
        break;
      case 5:
        this.$ = yy.evaluateByOperator("&", [$$[$0 - 2], $$[$0]]);
        break;
      case 6:
        this.$ = yy.evaluateByOperator("=", [$$[$0 - 2], $$[$0]]);
        break;
      case 7:
        this.$ = yy.evaluateByOperator("+", [$$[$0 - 2], $$[$0]]);
        break;
      case 8:
        this.$ = $$[$0 - 1];
        break;
      case 9:
        this.$ = yy.evaluateByOperator("<=", [$$[$0 - 3], $$[$0]]);
        break;
      case 10:
        this.$ = yy.evaluateByOperator(">=", [$$[$0 - 3], $$[$0]]);
        break;
      case 11:
        this.$ = yy.evaluateByOperator("<>", [$$[$0 - 3], $$[$0]]);
        break;
      case 12:
        this.$ = yy.evaluateByOperator("NOT", [$$[$0 - 2], $$[$0]]);
        break;
      case 13:
        this.$ = yy.evaluateByOperator(">", [$$[$0 - 2], $$[$0]]);
        break;
      case 14:
        this.$ = yy.evaluateByOperator("<", [$$[$0 - 2], $$[$0]]);
        break;
      case 15:
        this.$ = yy.evaluateByOperator("-", [$$[$0 - 2], $$[$0]]);
        break;
      case 16:
        this.$ = yy.evaluateByOperator("*", [$$[$0 - 2], $$[$0]]);
        break;
      case 17:
        this.$ = yy.evaluateByOperator("/", [$$[$0 - 2], $$[$0]]);
        break;
      case 18:
        this.$ = yy.evaluateByOperator("^", [$$[$0 - 2], $$[$0]]);
        break;
      case 19:
        var n1 = yy.invertNumber($$[$0]);
        this.$ = n1;
        if (isNaN(this.$)) {
          this.$ = 0;
        }
        break;
      case 20:
        var n1 = yy.toNumber($$[$0]);
        this.$ = n1;
        if (isNaN(this.$)) {
          this.$ = 0;
        }
        break;
      case 21:
        this.$ = yy.callFunction($$[$0 - 2]);
        break;
      case 22:
        this.$ = yy.callFunction($$[$0 - 3], $$[$0 - 1]);
        break;
      case 26:
      case 27:
      case 28:
        this.$ = yy.cellValue($$[$0]);
        break;
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
        this.$ = yy.rangeValue($$[$0 - 2], $$[$0]);
        break;
      case 38:
      case 42:
        this.$ = [$$[$0]];
        break;
      case 39:
        this.$ = yy.trimEdges(yytext).split(",");
        break;
      case 40:
      case 41:
        $$[$0 - 2].push($$[$0]);
        this.$ = $$[$0 - 2];
        break;
      case 43:
        this.$ = Array.isArray($$[$0 - 2]) ? $$[$0 - 2] : [$$[$0 - 2]];
        this.$.push($$[$0]);
        break;
      case 44:
        this.$ = $$[$0];
        break;
      case 45:
        this.$ = ($$[$0 - 2] + "." + $$[$0]) * 1;
        break;
      case 46:
        this.$ = $$[$0 - 1] * 0.01;
        break;
      case 47:
        this.$ = yy.throwError($$[$0]);
        break;
    }
  },
  table: [{
    2: 11,
    3: 1,
    4: 2,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    1: [3]
  }, {
    5: [1, 18],
    9: $Vb,
    10: $Vc,
    11: $Vd,
    14: $Ve,
    15: $Vf,
    16: $Vg,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }, o($Vl, [2, 2], {
    32: [1, 29]
  }), o($Vl, [2, 3], {
    34: [1, 30]
  }), o($Vl, [2, 4]), {
    2: 11,
    4: 31,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 32,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 33,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    12: [1, 34]
  }, o($Vl, [2, 23]), o($Vl, [2, 24], {
    2: 35,
    35: $Va
  }), o($Vm, [2, 42]), o($Vn, [2, 44], {
    32: [1, 36]
  }), o($Vl, [2, 26], {
    27: [1, 37]
  }), o($Vl, [2, 27], {
    27: [1, 38]
  }), o($Vl, [2, 28], {
    27: [1, 39]
  }), o([5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 35], [2, 47]), {
    1: [2, 1]
  }, {
    2: 11,
    4: 40,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 41,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 42,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 45,
    6: 3,
    7: 4,
    8: $V0,
    10: [1, 43],
    11: $V1,
    12: $V2,
    15: [1, 44],
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 47,
    6: 3,
    7: 4,
    8: $V0,
    10: [1, 46],
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 48,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 49,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 50,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 51,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 52,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    31: [1, 53]
  }, o($Vn, [2, 46]), {
    9: $Vb,
    10: $Vc,
    11: $Vd,
    13: [1, 54],
    14: $Ve,
    15: $Vf,
    16: $Vg,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }, o($Vo, [2, 19], {
    9: $Vb,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vo, [2, 20], {
    9: $Vb,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), {
    2: 11,
    4: 57,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    13: [1, 55],
    17: $V3,
    21: $V4,
    22: 56,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    28: [1, 58],
    31: $V8,
    33: $V9,
    35: $Va
  }, o($Vl, [2, 25]), {
    33: [1, 59]
  }, {
    24: [1, 60],
    25: [1, 61],
    26: [1, 62]
  }, {
    24: [1, 63],
    25: [1, 64],
    26: [1, 65]
  }, {
    24: [1, 66],
    25: [1, 67],
    26: [1, 68]
  }, o($Vl, [2, 5]), o([5, 10, 13, 29, 30], [2, 6], {
    9: $Vb,
    11: $Vd,
    14: $Ve,
    15: $Vf,
    16: $Vg,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vo, [2, 7], {
    9: $Vb,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), {
    2: 11,
    4: 69,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 70,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, o($Vp, [2, 14], {
    9: $Vb,
    11: $Vd,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), {
    2: 11,
    4: 71,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, o($Vp, [2, 13], {
    9: $Vb,
    11: $Vd,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o([5, 10, 13, 16, 29, 30], [2, 12], {
    9: $Vb,
    11: $Vd,
    14: $Ve,
    15: $Vf,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vo, [2, 15], {
    9: $Vb,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vq, [2, 16], {
    9: $Vb,
    20: $Vk
  }), o($Vq, [2, 17], {
    9: $Vb,
    20: $Vk
  }), o([5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30], [2, 18], {
    9: $Vb
  }), o($Vm, [2, 43]), o($Vl, [2, 8]), o($Vl, [2, 21]), {
    13: [1, 72],
    29: [1, 73],
    30: [1, 74]
  }, o($Vr, [2, 38], {
    9: $Vb,
    10: $Vc,
    11: $Vd,
    14: $Ve,
    15: $Vf,
    16: $Vg,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vr, [2, 39]), o($Vn, [2, 45]), o($Vl, [2, 29]), o($Vl, [2, 30]), o($Vl, [2, 31]), o($Vl, [2, 32]), o($Vl, [2, 33]), o($Vl, [2, 34]), o($Vl, [2, 35]), o($Vl, [2, 36]), o($Vl, [2, 37]), o($Vp, [2, 9], {
    9: $Vb,
    11: $Vd,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vp, [2, 11], {
    9: $Vb,
    11: $Vd,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vp, [2, 10], {
    9: $Vb,
    11: $Vd,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vl, [2, 22]), {
    2: 11,
    4: 75,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, {
    2: 11,
    4: 76,
    6: 3,
    7: 4,
    8: $V0,
    11: $V1,
    12: $V2,
    17: $V3,
    21: $V4,
    23: 10,
    24: $V5,
    25: $V6,
    26: $V7,
    31: $V8,
    33: $V9,
    35: $Va
  }, o($Vr, [2, 40], {
    9: $Vb,
    10: $Vc,
    11: $Vd,
    14: $Ve,
    15: $Vf,
    16: $Vg,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  }), o($Vr, [2, 41], {
    9: $Vb,
    10: $Vc,
    11: $Vd,
    14: $Ve,
    15: $Vf,
    16: $Vg,
    17: $Vh,
    18: $Vi,
    19: $Vj,
    20: $Vk
  })],
  defaultActions: {
    18: [2, 1]
  },
  parseError: function parseError(str, hash) {
    if (hash.recoverable) {
      this.trace(str);
    } else {
      var error2 = new Error(str);
      error2.hash = hash;
      throw error2;
    }
  },
  parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer2 = Object.create(this.lexer);
    var sharedState = {
      yy: {}
    };
    for (var k in this.yy) {
      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
        sharedState.yy[k] = this.yy[k];
      }
    }
    lexer2.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer2;
    sharedState.yy.parser = this;
    if (typeof lexer2.yylloc == "undefined") {
      lexer2.yylloc = {};
    }
    var yyloc = lexer2.yylloc;
    lstack.push(yyloc);
    var ranges = lexer2.options && lexer2.options.ranges;
    if (typeof sharedState.yy.parseError === "function") {
      this.parseError = sharedState.yy.parseError;
    } else {
      this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
      stack.length = stack.length - 2 * n;
      vstack.length = vstack.length - n;
      lstack.length = lstack.length - n;
    }
    var lex = function lex2() {
      var token;
      token = lexer2.lex() || EOF;
      if (typeof token !== "number") {
        token = self.symbols_[token] || token;
      }
      return token;
    };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
      state = stack[stack.length - 1];
      if (this.defaultActions[state]) {
        action = this.defaultActions[state];
      } else {
        if (symbol === null || typeof symbol == "undefined") {
          symbol = lex();
        }
        action = table[state] && table[state][symbol];
      }
      if (typeof action === "undefined" || !action.length || !action[0]) {
        var locateNearestErrorRecoveryRule = function locateNearestErrorRecoveryRule2(state2) {
          var stack_probe = stack.length - 1;
          var depth = 0;
          for (; ; ) {
            if (TERROR.toString() in table[state2]) {
              return depth;
            }
            if (state2 === 0 || stack_probe < 2) {
              return false;
            }
            stack_probe -= 2;
            state2 = stack[stack_probe];
            ++depth;
          }
        };
        var error_rule_depth;
        var errStr = "";
        if (!recovering) {
          error_rule_depth = locateNearestErrorRecoveryRule(state);
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer2.yylineno,
            loc: yyloc,
            expected,
            recoverable: error_rule_depth !== false
          });
        } else if (preErrorSymbol !== EOF) {
          error_rule_depth = locateNearestErrorRecoveryRule(state);
        }
        if (recovering == 3) {
          if (symbol === EOF || preErrorSymbol === EOF) {
            throw new Error(errStr || "Parsing halted while starting to recover from another error.");
          }
          yyleng = lexer2.yyleng;
          yytext = lexer2.yytext;
          yylineno = lexer2.yylineno;
          yyloc = lexer2.yylloc;
          symbol = lex();
        }
        if (error_rule_depth === false) {
          throw new Error(errStr || "Parsing halted. No suitable error recovery rule available.");
        }
        popStack(error_rule_depth);
        preErrorSymbol = symbol == TERROR ? null : symbol;
        symbol = TERROR;
        state = stack[stack.length - 1];
        action = table[state] && table[state][TERROR];
        recovering = 3;
      }
      if (action[0] instanceof Array && action.length > 1) {
        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
      }
      switch (action[0]) {
        case 1:
          stack.push(symbol);
          vstack.push(lexer2.yytext);
          lstack.push(lexer2.yylloc);
          stack.push(action[1]);
          symbol = null;
          if (!preErrorSymbol) {
            yyleng = lexer2.yyleng;
            yytext = lexer2.yytext;
            yylineno = lexer2.yylineno;
            yyloc = lexer2.yylloc;
            if (recovering > 0) {
              recovering--;
            }
          } else {
            symbol = preErrorSymbol;
            preErrorSymbol = null;
          }
          break;
        case 2:
          len = this.productions_[action[1]][1];
          yyval.$ = vstack[vstack.length - len];
          yyval._$ = {
            first_line: lstack[lstack.length - (len || 1)].first_line,
            last_line: lstack[lstack.length - 1].last_line,
            first_column: lstack[lstack.length - (len || 1)].first_column,
            last_column: lstack[lstack.length - 1].last_column
          };
          if (ranges) {
            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
          }
          r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
          if (typeof r !== "undefined") {
            return r;
          }
          if (len) {
            stack = stack.slice(0, -1 * len * 2);
            vstack = vstack.slice(0, -1 * len);
            lstack = lstack.slice(0, -1 * len);
          }
          stack.push(this.productions_[action[1]][0]);
          vstack.push(yyval.$);
          lstack.push(yyval._$);
          newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
          stack.push(newState);
          break;
        case 3:
          return true;
      }
    }
    return true;
  }
};
var lexer = /* @__PURE__ */ function() {
  var lexer2 = {
    EOF: 1,
    parseError: function parseError2(str, hash) {
      if (this.yy.parser) {
        this.yy.parser.parseError(str, hash);
      } else {
        throw new Error(str);
      }
    },
    // resets the lexer, sets new input
    setInput: function setInput(input, yy) {
      this.yy = yy || this.yy || {};
      this._input = input;
      this._more = this._backtrack = this.done = false;
      this.yylineno = this.yyleng = 0;
      this.yytext = this.matched = this.match = "";
      this.conditionStack = ["INITIAL"];
      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0
      };
      if (this.options.ranges) {
        this.yylloc.range = [0, 0];
      }
      this.offset = 0;
      return this;
    },
    // consumes and returns one char from the input
    input: function input() {
      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;
      var lines = ch.match(/(?:\r\n?|\n).*/g);
      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
      } else {
        this.yylloc.last_column++;
      }
      if (this.options.ranges) {
        this.yylloc.range[1]++;
      }
      this._input = this._input.slice(1);
      return ch;
    },
    // unshifts one char (or a string) into the input
    unput: function unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.offset -= len;
      var oldLines = this.match.split(/(?:\r\n?|\n)/g);
      this.match = this.match.substr(0, this.match.length - 1);
      this.matched = this.matched.substr(0, this.matched.length - 1);
      if (lines.length - 1) {
        this.yylineno -= lines.length - 1;
      }
      var r = this.yylloc.range;
      this.yylloc = {
        first_line: this.yylloc.first_line,
        last_line: this.yylineno + 1,
        first_column: this.yylloc.first_column,
        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
      };
      if (this.options.ranges) {
        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
      }
      this.yyleng = this.yytext.length;
      return this;
    },
    // When called from action, caches matched text and appends it on next action
    more: function more() {
      this._more = true;
      return this;
    },
    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
    reject: function reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }
      return this;
    },
    // retain first n characters of the match
    less: function less(n) {
      this.unput(this.match.slice(n));
    },
    // displays already matched input, i.e. for error messages
    pastInput: function pastInput() {
      var past = this.matched.substr(0, this.matched.length - this.match.length);
      return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
    },
    // displays upcoming input, i.e. for error messages
    upcomingInput: function upcomingInput() {
      var next = this.match;
      if (next.length < 20) {
        next += this._input.substr(0, 20 - next.length);
      }
      return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
    },
    // displays the character position where the lexing error occurred, i.e. for error messages
    showPosition: function showPosition() {
      var pre = this.pastInput();
      var c = new Array(pre.length + 1).join("-");
      return pre + this.upcomingInput() + "\n" + c + "^";
    },
    // test the lexed token: return FALSE when not a match, otherwise return token
    test_match: function test_match(match, indexed_rule) {
      var token, lines, backup;
      if (this.options.backtrack_lexer) {
        backup = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
        if (this.options.ranges) {
          backup.yylloc.range = this.yylloc.range.slice(0);
        }
      }
      lines = match[0].match(/(?:\r\n?|\n).*/g);
      if (lines) {
        this.yylineno += lines.length;
      }
      this.yylloc = {
        first_line: this.yylloc.last_line,
        last_line: this.yylineno + 1,
        first_column: this.yylloc.last_column,
        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
      };
      this.yytext += match[0];
      this.match += match[0];
      this.matches = match;
      this.yyleng = this.yytext.length;
      if (this.options.ranges) {
        this.yylloc.range = [this.offset, this.offset += this.yyleng];
      }
      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match[0].length);
      this.matched += match[0];
      token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
      if (this.done && this._input) {
        this.done = false;
      }
      if (token) {
        return token;
      } else if (this._backtrack) {
        for (var k in backup) {
          this[k] = backup[k];
        }
        return false;
      }
      return false;
    },
    // return next match in input
    next: function next() {
      if (this.done) {
        return this.EOF;
      }
      if (!this._input) {
        this.done = true;
      }
      var token, match, tempMatch, index;
      if (!this._more) {
        this.yytext = "";
        this.match = "";
      }
      var rules = this._currentRules();
      for (var i = 0; i < rules.length; i++) {
        tempMatch = this._input.match(this.rules[rules[i]]);
        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;
          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rules[i]);
            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = false;
              continue;
            } else {
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }
      if (match) {
        token = this.test_match(match, rules[index]);
        if (token !== false) {
          return token;
        }
        return false;
      }
      if (this._input === "") {
        return this.EOF;
      } else {
        return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }
    },
    // return next match that has a token
    lex: function lex() {
      var r = this.next();
      if (r) {
        return r;
      } else {
        return this.lex();
      }
    },
    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
    begin: function begin(condition) {
      this.conditionStack.push(condition);
    },
    // pop the previously active lexer condition state off the condition stack
    popState: function popState() {
      var n = this.conditionStack.length - 1;
      if (n > 0) {
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },
    // produce the lexer rule set which is active for the currently active lexer condition state
    _currentRules: function _currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
      } else {
        return this.conditions["INITIAL"].rules;
      }
    },
    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
    topState: function topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);
      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return "INITIAL";
      }
    },
    // alias for begin(condition)
    pushState: function pushState(condition) {
      this.begin(condition);
    },
    // return the number of states currently on the stack
    stateStackSize: function stateStackSize() {
      return this.conditionStack.length;
    },
    options: {},
    performAction: function anonymous2(yy, yy_, $avoiding_name_collisions, YY_START) {
      var YYSTATE = YY_START;
      switch ($avoiding_name_collisions) {
        case 0:
          break;
        case 1:
          return 8;
          break;
        case 2:
          return 8;
          break;
        case 3:
          return 21;
          break;
        case 4:
          return 35;
          break;
        case 5:
          return 24;
          break;
        case 6:
          return 26;
          break;
        case 7:
          return 26;
          break;
        case 8:
          return 25;
          break;
        case 9:
          return 21;
          break;
        case 10:
          return 31;
          break;
        case 11:
          return 31;
          break;
        case 12:
          return 33;
          break;
        case 13:
          return 28;
          break;
        case 14:
          return 9;
          break;
        case 15:
          return " ";
          break;
        case 16:
          return 32;
          break;
        case 17:
          return 27;
          break;
        case 18:
          return 29;
          break;
        case 19:
          return 30;
          break;
        case 20:
          return 18;
          break;
        case 21:
          return 19;
          break;
        case 22:
          return 17;
          break;
        case 23:
          return 11;
          break;
        case 24:
          return 20;
          break;
        case 25:
          return 12;
          break;
        case 26:
          return 13;
          break;
        case 27:
          return 15;
          break;
        case 28:
          return 14;
          break;
        case 29:
          return 16;
          break;
        case 30:
          return '"';
          break;
        case 31:
          return "'";
          break;
        case 32:
          return "!";
          break;
        case 33:
          return 10;
          break;
        case 34:
          return 34;
          break;
        case 35:
          return "#";
          break;
        case 36:
          return 5;
          break;
      }
    },
    rules: [/^(?:\s+)/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9\.]+(?=[(]))/, /^(?:#[A-Z0-9\/]+(!|\?)?)/, /^(?:\$[A-Za-z]+\$[0-9]+)/, /^(?:\$[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z]+\$[0-9]+)/, /^(?:[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z\.]+(?=[(]))/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9]+)/, /^(?:[A-Za-z_]+)/, /^(?:[0-9]+)/, /^(?:\[(.*)?\])/, /^(?:&)/, /^(?: )/, /^(?:[.])/, /^(?::)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\/)/, /^(?:-)/, /^(?:\+)/, /^(?:\^)/, /^(?:\()/, /^(?:\))/, /^(?:>)/, /^(?:<)/, /^(?:NOT\b)/, /^(?:")/, /^(?:')/, /^(?:!)/, /^(?:=)/, /^(?:%)/, /^(?:[#])/, /^(?:$)/],
    conditions: {
      "INITIAL": {
        "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
        "inclusive": true
      }
    }
  };
  return lexer2;
}();
parser.lexer = lexer;
function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

// ../../node_modules/hot-formula-parser/helper/string.mjs
function trimEdges(string) {
  var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  string = string.substring(margin, string.length - margin);
  return string;
}

// ../../node_modules/hot-formula-parser/helper/cell.mjs
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray2(o3, minLen);
  var n = Object.prototype.toString.call(o3).slice(8, -1);
  if (n === "Object" && o3.constructor) n = o3.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o3);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray2(o3, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function rowLabelToIndex(label) {
  var result = parseInt(label, 10);
  if (isNaN(result)) {
    result = -1;
  } else {
    result = Math.max(result - 1, -1);
  }
  return result;
}
function rowIndexToLabel(row) {
  var result = "";
  if (row >= 0) {
    result = "".concat(row + 1);
  }
  return result;
}
var COLUMN_LABEL_BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;
function columnLabelToIndex(label) {
  var result = 0;
  if (typeof label === "string") {
    label = label.toUpperCase();
    for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
      result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
    }
  }
  --result;
  return result;
}
function columnIndexToLabel(column) {
  var result = "";
  while (column >= 0) {
    result = String.fromCharCode(column % COLUMN_LABEL_BASE_LENGTH + 97) + result;
    column = Math.floor(column / COLUMN_LABEL_BASE_LENGTH) - 1;
  }
  return result.toUpperCase();
}
var LABEL_EXTRACT_REGEXP = /^([$])?([A-Za-z]+)([$])?([0-9]+)$/;
function extractLabel(label) {
  if (typeof label !== "string" || !LABEL_EXTRACT_REGEXP.test(label)) {
    return [];
  }
  var _label$toUpperCase$ma = label.toUpperCase().match(LABEL_EXTRACT_REGEXP), _label$toUpperCase$ma2 = _slicedToArray(_label$toUpperCase$ma, 5), columnAbs = _label$toUpperCase$ma2[1], column = _label$toUpperCase$ma2[2], rowAbs = _label$toUpperCase$ma2[3], row = _label$toUpperCase$ma2[4];
  return [{
    index: rowLabelToIndex(row),
    label: row,
    isAbsolute: rowAbs === "$"
  }, {
    index: columnLabelToIndex(column),
    label: column,
    isAbsolute: columnAbs === "$"
  }];
}
function toLabel(row, column) {
  var rowLabel = (row.isAbsolute ? "$" : "") + rowIndexToLabel(row.index);
  var columnLabel = (column.isAbsolute ? "$" : "") + columnIndexToLabel(column.index);
  return columnLabel + rowLabel;
}

// ../../node_modules/hot-formula-parser/parser.mjs
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray3(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray3(o3, minLen);
  var n = Object.prototype.toString.call(o3).slice(8, -1);
  if (n === "Object" && o3.constructor) n = o3.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o3);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray3(o3, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o3, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p2) {
    o4.__proto__ = p2;
    return o4;
  };
  return _setPrototypeOf(o3, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf(o3);
}
var Parser2 = function(_Emitter) {
  _inherits(Parser3, _Emitter);
  var _super = _createSuper(Parser3);
  function Parser3() {
    var _this;
    _classCallCheck(this, Parser3);
    _this = _super.call(this);
    _this.parser = new Parser();
    _this.parser.yy = {
      toNumber,
      trimEdges,
      invertNumber,
      throwError: function throwError(errorName) {
        return _this._throwError(errorName);
      },
      callVariable: function callVariable(variable) {
        return _this._callVariable(variable);
      },
      evaluateByOperator,
      callFunction: function callFunction(name, params) {
        return _this._callFunction(name, params);
      },
      cellValue: function cellValue(value) {
        return _this._callCellValue(value);
      },
      rangeValue: function rangeValue(start, end) {
        return _this._callRangeValue(start, end);
      }
    };
    _this.variables = /* @__PURE__ */ Object.create(null);
    _this.functions = /* @__PURE__ */ Object.create(null);
    _this.setVariable("TRUE", true).setVariable("FALSE", false).setVariable("NULL", null);
    return _this;
  }
  _createClass(Parser3, [{
    key: "parse",
    value: function parse2(expression) {
      var result = null;
      var error2 = null;
      try {
        if (expression === "") {
          result = "";
        } else {
          result = this.parser.parse(expression);
        }
      } catch (ex) {
        var message = error(ex.message);
        if (message) {
          error2 = message;
        } else {
          error2 = error(ERROR);
        }
      }
      if (result instanceof Error) {
        error2 = error(result.message) || error(ERROR);
        result = null;
      }
      return {
        error: error2,
        result
      };
    }
    /**
     * Set predefined variable name which can be visible while parsing formula expression.
     *
     * @param {String} name Variable name.
     * @param {*} value Variable value.
     * @returns {Parser}
     */
  }, {
    key: "setVariable",
    value: function setVariable(name, value) {
      this.variables[name] = value;
      return this;
    }
    /**
     * Get variable name.
     *
     * @param {String} name Variable name.
     * @returns {*}
     */
  }, {
    key: "getVariable",
    value: function getVariable(name) {
      return this.variables[name];
    }
    /**
     * Retrieve variable value by its name.
     *
     * @param name Variable name.
     * @returns {*}
     * @private
     */
  }, {
    key: "_callVariable",
    value: function _callVariable(name) {
      var value = this.getVariable(name);
      this.emit("callVariable", name, function(newValue) {
        if (newValue !== void 0) {
          value = newValue;
        }
      });
      if (value === void 0) {
        throw Error(ERROR_NAME);
      }
      return value;
    }
    /**
     * Set custom function which can be visible while parsing formula expression.
     *
     * @param {String} name Custom function name.
     * @param {Function} fn Custom function.
     * @returns {Parser}
     */
  }, {
    key: "setFunction",
    value: function setFunction(name, fn) {
      this.functions[name] = fn;
      return this;
    }
    /**
     * Get custom function.
     *
     * @param {String} name Custom function name.
     * @returns {*}
     */
  }, {
    key: "getFunction",
    value: function getFunction(name) {
      return this.functions[name];
    }
    /**
     * Call function with provided params.
     *
     * @param name Function name.
     * @param params Function params.
     * @returns {*}
     * @private
     */
  }, {
    key: "_callFunction",
    value: function _callFunction(name) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var fn = this.getFunction(name);
      var value;
      if (fn) {
        value = fn(params);
      }
      this.emit("callFunction", name, params, function(newValue) {
        if (newValue !== void 0) {
          value = newValue;
        }
      });
      return value === void 0 ? evaluateByOperator(name, params) : value;
    }
    /**
     * Retrieve value by its label (`B3`, `B$3`, `B$3`, `$B$3`).
     *
     * @param {String} label Coordinates.
     * @returns {*}
     * @private
     */
  }, {
    key: "_callCellValue",
    value: function _callCellValue(label) {
      label = label.toUpperCase();
      var _extractLabel = extractLabel(label), _extractLabel2 = _slicedToArray2(_extractLabel, 2), row = _extractLabel2[0], column = _extractLabel2[1];
      var value = void 0;
      this.emit("callCellValue", {
        label,
        row,
        column
      }, function(_value) {
        value = _value;
      });
      return value;
    }
    /**
     * Retrieve value by its label (`B3:A1`, `B$3:A1`, `B$3:$A1`, `$B$3:A$1`).
     *
     * @param {String} startLabel Coordinates of the first cell.
     * @param {String} endLabel Coordinates of the last cell.
     * @returns {Array} Returns an array of mixed values.
     * @private
     */
  }, {
    key: "_callRangeValue",
    value: function _callRangeValue(startLabel, endLabel) {
      startLabel = startLabel.toUpperCase();
      endLabel = endLabel.toUpperCase();
      var _extractLabel3 = extractLabel(startLabel), _extractLabel4 = _slicedToArray2(_extractLabel3, 2), startRow = _extractLabel4[0], startColumn = _extractLabel4[1];
      var _extractLabel5 = extractLabel(endLabel), _extractLabel6 = _slicedToArray2(_extractLabel5, 2), endRow = _extractLabel6[0], endColumn = _extractLabel6[1];
      var startCell = {};
      var endCell = {};
      if (startRow.index <= endRow.index) {
        startCell.row = startRow;
        endCell.row = endRow;
      } else {
        startCell.row = endRow;
        endCell.row = startRow;
      }
      if (startColumn.index <= endColumn.index) {
        startCell.column = startColumn;
        endCell.column = endColumn;
      } else {
        startCell.column = endColumn;
        endCell.column = startColumn;
      }
      startCell.label = toLabel(startCell.row, startCell.column);
      endCell.label = toLabel(endCell.row, endCell.column);
      var value = [];
      this.emit("callRangeValue", startCell, endCell, function() {
        var _value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        value = _value;
      });
      return value;
    }
    /**
     * Try to throw error by its name.
     *
     * @param {String} errorName Error name.
     * @returns {String}
     * @private
     */
  }, {
    key: "_throwError",
    value: function _throwError(errorName) {
      if (isValidStrict(errorName)) {
        throw Error(errorName);
      }
      throw Error(ERROR);
    }
  }]);
  return Parser3;
}(import_tiny_emitter.default);
var parser_default = Parser2;
export {
  ERROR,
  ERROR_DIV_ZERO,
  ERROR_NAME,
  ERROR_NOT_AVAILABLE,
  ERROR_NULL,
  ERROR_NUM,
  ERROR_REF,
  ERROR_VALUE,
  parser_default as Parser,
  supported_formulas_default as SUPPORTED_FORMULAS,
  columnIndexToLabel,
  columnLabelToIndex,
  error,
  extractLabel,
  rowIndexToLabel,
  rowLabelToIndex,
  toLabel
};
//# sourceMappingURL=hot-formula-parser.js.map
