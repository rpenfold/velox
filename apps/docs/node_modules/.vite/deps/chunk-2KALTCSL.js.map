{
  "version": 3,
  "sources": ["../../preact-router/src/util.js", "../../preact-router/src/index.js"],
  "sourcesContent": ["const EMPTY = {};\n\nexport function assign(obj, props) {\n\t// eslint-disable-next-line guard-for-in\n\tfor (let i in props) {\n\t\tobj[i] = props[i];\n\t}\n\treturn obj;\n}\n\nexport function exec(url, route, opts) {\n\tlet reg = /(?:\\?([^#]*))?(#.*)?$/,\n\t\tc = url.match(reg),\n\t\tmatches = {},\n\t\tret;\n\tif (c && c[1]) {\n\t\tlet p = c[1].split('&');\n\t\tfor (let i = 0; i < p.length; i++) {\n\t\t\tlet r = p[i].split('=');\n\t\t\tmatches[decodeURIComponent(r[0])] = decodeURIComponent(\n\t\t\t\tr.slice(1).join('=')\n\t\t\t);\n\t\t}\n\t}\n\turl = segmentize(url.replace(reg, ''));\n\troute = segmentize(route || '');\n\tlet max = Math.max(url.length, route.length);\n\tfor (let i = 0; i < max; i++) {\n\t\tif (route[i] && route[i].charAt(0) === ':') {\n\t\t\tlet param = route[i].replace(/(^:|[+*?]+$)/g, ''),\n\t\t\t\tflags = (route[i].match(/[+*?]+$/) || EMPTY)[0] || '',\n\t\t\t\tplus = ~flags.indexOf('+'),\n\t\t\t\tstar = ~flags.indexOf('*'),\n\t\t\t\tval = url[i] || '';\n\t\t\tif (!val && !star && (flags.indexOf('?') < 0 || plus)) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatches[param] = decodeURIComponent(val);\n\t\t\tif (plus || star) {\n\t\t\t\tmatches[param] = url.slice(i).map(decodeURIComponent).join('/');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (route[i] !== url[i]) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (opts.default !== true && ret === false) return false;\n\treturn matches;\n}\n\nexport function pathRankSort(a, b) {\n\treturn a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : a.index - b.index;\n}\n\n// filter out VNodes without attributes (which are unrankeable), and add `index`/`rank` properties to be used in sorting.\nexport function prepareVNodeForRanking(vnode, index) {\n\tvnode.index = index;\n\tvnode.rank = rankChild(vnode);\n\treturn vnode.props;\n}\n\nexport function segmentize(url) {\n\treturn url.replace(/(^\\/+|\\/+$)/g, '').split('/');\n}\n\nexport function rankSegment(segment) {\n\treturn segment.charAt(0) == ':'\n\t\t? 1 + '*+?'.indexOf(segment.charAt(segment.length - 1)) || 4\n\t\t: 5;\n}\n\nexport function rank(path) {\n\treturn segmentize(path).map(rankSegment).join('');\n}\n\nfunction rankChild(vnode) {\n\treturn vnode.props.default ? 0 : rank(vnode.props.path);\n}\n", "import {\n\th,\n\tcloneElement,\n\tComponent,\n\ttoChildArray,\n\tcreateContext\n} from 'preact';\nimport { useContext, useState, useEffect } from 'preact/hooks';\nimport { exec, prepareVNodeForRanking, assign, pathRankSort } from './util';\n\nconst EMPTY = {};\nconst ROUTERS = [];\nconst SUBS = [];\nlet customHistory = null;\n\nconst GLOBAL_ROUTE_CONTEXT = {\n\turl: getCurrentUrl()\n};\n\nconst RouterContext = createContext(GLOBAL_ROUTE_CONTEXT);\n\nfunction useRouter() {\n\tconst ctx = useContext(RouterContext);\n\t// Note: this condition can't change without a remount, so it's a safe conditional hook call\n\tif (ctx === GLOBAL_ROUTE_CONTEXT) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst update = useState()[1];\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tuseEffect(() => {\n\t\t\tSUBS.push(update);\n\t\t\treturn () => SUBS.splice(SUBS.indexOf(update), 1);\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t}, []);\n\t}\n\treturn [ctx, route];\n}\n\nfunction setUrl(url, type = 'push') {\n\tif (customHistory && customHistory[type]) {\n\t\tcustomHistory[type](url);\n\t} else if (typeof history !== 'undefined' && history[`${type}State`]) {\n\t\thistory[`${type}State`](null, null, url);\n\t}\n}\n\nfunction getCurrentUrl() {\n\tlet url;\n\tif (customHistory && customHistory.location) {\n\t\turl = customHistory.location;\n\t} else if (customHistory && customHistory.getCurrentLocation) {\n\t\turl = customHistory.getCurrentLocation();\n\t} else {\n\t\turl = typeof location !== 'undefined' ? location : EMPTY;\n\t}\n\treturn `${url.pathname || ''}${url.search || ''}`;\n}\n\nfunction route(url, replace = false) {\n\tif (typeof url !== 'string' && url.url) {\n\t\treplace = url.replace;\n\t\turl = url.url;\n\t}\n\n\t// only push URL into history if we can handle it\n\tif (canRoute(url)) {\n\t\tsetUrl(url, replace ? 'replace' : 'push');\n\t}\n\n\treturn routeTo(url);\n}\n\n/** Check if the given URL can be handled by any router instances. */\nfunction canRoute(url) {\n\tfor (let i = ROUTERS.length; i--; ) {\n\t\tif (ROUTERS[i].canRoute(url)) return true;\n\t}\n\treturn false;\n}\n\n/** Tell all router instances to handle the given URL.  */\nfunction routeTo(url) {\n\tlet didRoute = false;\n\tfor (let i = 0; i < ROUTERS.length; i++) {\n\t\tif (ROUTERS[i].routeTo(url)) {\n\t\t\tdidRoute = true;\n\t\t}\n\t}\n\treturn didRoute;\n}\n\nfunction routeFromLink(node) {\n\t// only valid elements\n\tif (!node || !node.getAttribute) return;\n\n\tlet href = node.getAttribute('href'),\n\t\ttarget = node.getAttribute('target');\n\n\t// ignore links with targets and non-path URLs\n\tif (!href || !href.match(/^\\//g) || (target && !target.match(/^_?self$/i)))\n\t\treturn;\n\n\t// attempt to route, if no match simply cede control to browser\n\treturn route(href);\n}\n\nfunction prevent(e) {\n\tif (e.stopImmediatePropagation) e.stopImmediatePropagation();\n\tif (e.stopPropagation) e.stopPropagation();\n\te.preventDefault();\n\treturn false;\n}\n\n// Handles both delegated and direct-bound link clicks\nfunction delegateLinkHandler(e) {\n\t// ignore events the browser takes care of already:\n\tif (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button) return;\n\n\tlet t = e.target;\n\tdo {\n\t\tif (t.localName === 'a' && t.getAttribute('href')) {\n\t\t\tif (t.hasAttribute('data-native') || t.hasAttribute('native')) return;\n\t\t\t// if link is handled by the router, prevent browser defaults\n\t\t\tif (routeFromLink(t)) {\n\t\t\t\treturn prevent(e);\n\t\t\t}\n\t\t}\n\t} while ((t = t.parentNode));\n}\n\nlet eventListenersInitialized = false;\n\nfunction initEventListeners() {\n\tif (eventListenersInitialized) return;\n\teventListenersInitialized = true;\n\n\tif (!customHistory) {\n\t\taddEventListener('popstate', () => {\n\t\t\trouteTo(getCurrentUrl());\n\t\t});\n\t}\n\taddEventListener('click', delegateLinkHandler);\n}\n\n/**\n * @class\n * @this {import('preact').Component}\n */\nfunction Router(props) {\n\tif (props.history) {\n\t\tcustomHistory = props.history;\n\t}\n\n\tthis.state = {\n\t\turl: props.url || getCurrentUrl()\n\t};\n}\n\n// @ts-ignore-next-line\nconst RouterProto = (Router.prototype = new Component());\n\nassign(RouterProto, {\n\tshouldComponentUpdate(props) {\n\t\tif (props.static !== true) return true;\n\t\treturn (\n\t\t\tprops.url !== this.props.url || props.onChange !== this.props.onChange\n\t\t);\n\t},\n\n\t/** Check if the given URL can be matched against any children */\n\tcanRoute(url) {\n\t\tconst children = toChildArray(this.props.children);\n\t\treturn this._getMatchingChild(children, url) !== undefined;\n\t},\n\n\t/** Re-render children with a new URL to match against. */\n\trouteTo(url) {\n\t\tthis.setState({ url });\n\n\t\tconst didRoute = this.canRoute(url);\n\n\t\t// trigger a manual re-route if we're not in the middle of an update:\n\t\tif (!this._updating) this.forceUpdate();\n\n\t\treturn didRoute;\n\t},\n\n\tcomponentWillMount() {\n\t\tthis._updating = true;\n\t},\n\n\tcomponentDidMount() {\n\t\tinitEventListeners();\n\t\tROUTERS.push(this);\n\t\tif (customHistory) {\n\t\t\tthis._unlisten = customHistory.listen(action => {\n\t\t\t\tlet location = action.location || action;\n\t\t\t\tthis.routeTo(`${location.pathname || ''}${location.search || ''}`);\n\t\t\t});\n\t\t}\n\t\tthis._updating = false;\n\t},\n\n\tcomponentWillUnmount() {\n\t\tif (typeof this._unlisten === 'function') this._unlisten();\n\t\tROUTERS.splice(ROUTERS.indexOf(this), 1);\n\t},\n\n\tcomponentWillUpdate() {\n\t\tthis._updating = true;\n\t},\n\n\tcomponentDidUpdate() {\n\t\tthis._updating = false;\n\t},\n\n\t_getMatchingChild(children, url) {\n\t\tchildren = children.filter(prepareVNodeForRanking).sort(pathRankSort);\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tlet vnode = children[i];\n\t\t\tlet matches = exec(url, vnode.props.path, vnode.props);\n\t\t\tif (matches) return [vnode, matches];\n\t\t}\n\t},\n\n\trender({ children, onChange }, { url }) {\n\t\tlet ctx = this._contextValue;\n\n\t\tlet active = this._getMatchingChild(toChildArray(children), url);\n\t\tlet matches, current;\n\t\tif (active) {\n\t\t\tmatches = active[1];\n\t\t\tcurrent = cloneElement(\n\t\t\t\tactive[0],\n\t\t\t\tassign(assign({ url, matches }, matches), {\n\t\t\t\t\tkey: undefined,\n\t\t\t\t\tref: undefined\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tif (url !== (ctx && ctx.url)) {\n\t\t\tlet newCtx = {\n\t\t\t\turl,\n\t\t\t\tprevious: ctx && ctx.url,\n\t\t\t\tcurrent,\n\t\t\t\tpath: current ? current.props.path : null,\n\t\t\t\tmatches\n\t\t\t};\n\n\t\t\t// only copy simple properties to the global context:\n\t\t\tassign(GLOBAL_ROUTE_CONTEXT, (ctx = this._contextValue = newCtx));\n\n\t\t\t// these are only available within the subtree of a Router:\n\t\t\tctx.router = this;\n\t\t\tctx.active = current ? [current] : [];\n\n\t\t\t// notify useRouter subscribers outside this subtree:\n\t\t\tfor (let i = SUBS.length; i--; ) SUBS[i]({});\n\n\t\t\tif (typeof onChange === 'function') {\n\t\t\t\tonChange(ctx);\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\t<RouterContext.Provider value={ctx}>{current}</RouterContext.Provider>\n\t\t);\n\t}\n});\n\nconst Link = props => h('a', assign({ onClick: delegateLinkHandler }, props));\n\nconst Route = props => h(props.component, props);\n\nexport { getCurrentUrl, route, Router, Route, Link, exec, useRouter };\nexport default Router;\n"],
  "mappings": "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",
  "names": ["EMPTY", "assign", "obj", "props", "i", "exec", "url", "route", "opts", "ret", "reg", "c", "match", "matches", "p", "split", "length", "r", "decodeURIComponent", "slice", "join", "segmentize", "replace", "max", "Math", "charAt", "param", "flags", "plus", "indexOf", "star", "val", "map", "pathRankSort", "a", "b", "rank", "index", "prepareVNodeForRanking", "vnode", "path", "rankSegment", "segment", "ROUTERS", "SUBS", "customHistory", "GLOBAL_ROUTE_CONTEXT", "getCurrentUrl", "RouterContext", "createContext", "useRouter", "ctx", "useContext", "update", "useState", "useEffect", "push", "splice", "location", "getCurrentLocation", "pathname", "search", "canRoute", "type", "history", "routeTo", "didRoute", "routeFromLink", "node", "getAttribute", "href", "target", "prevent", "e", "stopImmediatePropagation", "stopPropagation", "preventDefault", "delegateLinkHandler", "ctrlKey", "metaKey", "altKey", "shiftKey", "button", "t", "localName", "hasAttribute", "parentNode", "eventListenersInitialized", "Router", "this", "state", "prototype", "Component", "shouldComponentUpdate", "onChange", "children", "toChildArray", "undefined", "_getMatchingChild", "setState", "_updating", "forceUpdate", "componentWillMount", "componentDidMount", "addEventListener", "_unlisten", "listen", "action", "_this", "componentWillUnmount", "componentWillUpdate", "componentDidUpdate", "filter", "sort", "render", "current", "_contextValue", "active", "cloneElement", "key", "ref", "previous", "router", "Provider", "value", "Link", "h", "onClick", "Route", "component"]
}
